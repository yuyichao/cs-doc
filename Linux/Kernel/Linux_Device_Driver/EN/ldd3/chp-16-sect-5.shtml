<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>16.5. Quick Reference</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-16-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-16-sect-5"></a>
<h3 class="docSection1Title">16.5. Quick Reference</h3>

<a name="chp-16-ITERM-7456"></a><a name="chp-16-ITERM-7457"></a><a name="chp-16-ITERM-7458"></a><a name="chp-16-ITERM-7459"></a><a name="chp-16-ITERM-7460"></a><a name="chp-16-ITERM-7461"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/fs.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int register_blkdev(unsigned int major, const char *name);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int unregister_blkdev(unsigned int major, const char *name);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">register_blkdev</span> <a name="chp-16-ITERM-7456"></a>
<a name="chp-16-ITERM-7457"></a>
<a name="chp-16-ITERM-7458"></a>registers a block driver with the
kernel and, optionally, obtains a major number. A driver can be
unregistered with <span class="docEmphasis">unregister_blkdev</span>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct block_device_operations</span></span></span></dt></P>
<dd>
<p class="docList">Structure that holds most of the methods for block drivers.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/genhd.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct gendisk;</span></span></span></dt></P>
<dd>
<p class="docList">Structure that describes a single block device within the kernel.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct gendisk *alloc_disk(int minors);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void add_disk(struct gendisk *gd);</span></span></span></dt></P>
<dd>
<p class="docList">Functions that allocate <tt>gendisk</tt> structures and
return them to the system.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void set_capacity(struct gendisk *gd, sector_t sectors);</span></span></span></dt></P>
<dd>
<p class="docList">Stores the capacity of the device (in 512-byte sectors) within the
<tt>gendisk</tt> structure.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void add_disk(struct gendisk *gd);</span></span></span></dt></p>
<dd>
<p class="docList">Adds a disk to the kernel. As soon as this function is called, your
disk's methods can be invoked by the kernel.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int check_disk_change(struct block_device *bdev);</span></span></span></dt></p>
<dd>
<p class="docList">A kernel function that checks for a media change in the given disk
drive and takes the required cleanup action when such a change is
detected.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/blkdev.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">request_queue_t blk_init_queue(request_fn_proc *request, spinlock_t *lock);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_cleanup_queue(request_queue_t *);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that handle the creation and deletion of block request
queues.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct request *elv_next_request(request_queue_t *queue);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void end_request(struct request *req, int success);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">elv_next_request</span> obtains the next request from a
request queue; <span class="docEmphasis">end_request</span> may be used in very
simple drivers to mark the completion of (or part of) a request.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blkdev_dequeue_request(struct request *req);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void elv_requeue_request(request_queue_t *queue, struct request *req);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that remove a request from a queue and put it back on if
necessary.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_stop_queue(request_queue_t *queue);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_start_queue(request_queue_t *queue);</span></span></span></dt></P>
<dd>
<p class="docList">If you need to prevent further calls to your
<span class="docEmphasis">request</span> method, a call to
<span class="docEmphasis">blk_stop_queue</span> does the trick. A call to
<span class="docEmphasis">blk_start_queue</span> is necessary to cause your
<span class="docEmphasis">request</span> method to be invoked again.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_bounce_limit(request_queue_t *queue, u64 dma_addr);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_max_sectors(request_queue_t *queue, unsigned short max);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_max_phys_segments(request_queue_t *queue, unsigned short max);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_max_hw_segments(request_queue_t *queue, unsigned short max);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_max_segment_size(request_queue_t *queue, unsigned int max);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">blk_queue_segment_boundary(request_queue_t *queue, unsigned long mask);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_dma_alignment(request_queue_t *queue, int mask);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_hardsect_size(request_queue_t *queue, unsigned short max);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that set various queue parameters that control how requests
are created for a particular device; the parameters are described in
the <a class="docLink" href="chp-16-sect-3.shtml#chp-16-sect-3.3.3">Section 16.3.3.3</a>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/bio.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct bio;</span></span></span></dt></p>
<dd>
<p class="docList">Low-level structure representing a portion of a block I/O request.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">bio_sectors(struct bio *bio);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">bio_data_dir(struct bio *bio);</span></span></span></dt></P>
<dd>
<p class="docList">Two macros that yield the size and direction of a transfer described
by a <tt>bio</tt> structure.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">bio_for_each_segment(bvec, bio, segno);</span></span></span></dt></p>
<dd>
<p class="docList">A pseudocontrol structure used to loop through the segments that make
up a <tt>bio</tt> structure.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">char *_ _bio_kmap_atomic(struct bio *bio, int i, enum km_type type);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void _ _bio_kunmap_atomic(char *buffer, enum km_type type);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">_ _bio_kmap_atomic</span> may be used to create a
kernel virtual address for a given segment within a
<tt>bio</tt> structure. The mapping must be undone with
<span class="docEmphasis">_ _bio_kunmap_atomic</span>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct page *bio_page(struct bio *bio);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int bio_offset(struct bio *bio);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int bio_cur_sectors(struct bio *bio);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">char *bio_data(struct bio *bio);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">char *bio_kmap_irq(struct bio *bio, unsigned long *flags);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void bio_kunmap_irq(char *buffer, unsigned long *flags);</span></span></span></dt></P>
<dd>
<p class="docList">A set of accessor macros that provide access to the
"current" segment within a
<tt>bio</tt> structure.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_ordered(request_queue_t *queue, int flag);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int blk_barrier_rq(struct request *req);</span></span></span></dt></p>
<dd>
<p class="docList">Call <span class="docEmphasis">blk_queue_ordered</span> if your driver implements
barrier requestsâ€”as it should. The macro
<span class="docEmphasis">blk_barrier_rq</span> returns a nonzero value if the
current request is a barrier request.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int blk_noretry_request(struct request *req);</span></span></span></dt></p>
<dd>
<p class="docList">This macro returns a nonzero value if the given request should not be
retried on errors.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int end_that_request_first(struct request *req, int success, int count);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void end_that_request_last(struct request *req);</span></span></span></dt></P>
<dd>
<p class="docList">Use <span class="docEmphasis">end_that_request_first</span> to indicate
completion of a portion of a block I/O request. When that function
returns <tt>0</tt>, the request is complete and should be
passed to <span class="docEmphasis">end_that_request_last</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">rq_for_each_bio(bio, request)</span></span></span></dt></p>
<dd>
<p class="docList">Another macro-implemented control structure; it steps through each
<tt>bio</tt> that makes up a request.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int blk_rq_map_sg(request_queue_t *queue, struct request *req, struct</span></span> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">scatterlist *list);</span></span></span></dt></p>
<dd>
<p class="docList">Fills the given scatterlist with the information needed to map the
buffers in the given request for a DMA transfer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">typedef int (make_request_fn) (request_queue_t *q, struct bio *bio);</span></span></span></dt></P>
<dd>
<p class="docList">The prototype for the <span class="docEmphasis">make_request</span> function.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void bio_endio(struct bio *bio, unsigned int bytes, int error);</span></span></span></dt></P>
<dd>
<p class="docList">Signal completion for a given <tt>bio</tt>. This function
should be used only if your driver obtained the
<tt>bio</tt> directly from the block layer via the
<span class="docEmphasis">make_request</span> function.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">request_queue_t *blk_alloc_queue(int flags);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_make_request(request_queue_t *queue, make_request_fn *func);</span></span></span></dt></p>
<dd>
<p class="docList">Use <span class="docEmphasis">blk_alloc_queue</span> to allocate a request queue
that is used with a custom <span class="docEmphasis">make_request</span>
function. That function should be set with
<span class="docEmphasis">blk_queue_make_request</span>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">typedef int (prep_rq_fn) (request_queue_t *queue, struct request *req);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_prep_rq(request_queue_t *queue, prep_rq_fn *func);</span></span></span></dt></p>
<dd>
<p class="docList">The prototype and setup functions for a command preparation function,
which can be used to prepare the necessary hardware command before
the request is passed to your <span class="docEmphasis">request</span> function.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int blk_queue_init_tags(request_queue_t *queue, int depth, struct</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">blk_queue_tag *tags);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int blk_queue_resize_tags(request_queue_t *queue, int new_depth);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int blk_queue_start_tag(request_queue_t *queue, struct request *req);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_end_tag(request_queue_t *queue, struct request *req);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct request *blk_queue_find_tag(request_queue_t *qeue, int tag);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void blk_queue_invalidate_tags(request_queue_t *queue);</span></span></span></dt></P>
<dd>
<p class="docList">Support functions for drivers using tagged command <a name="chp-16-ITERM-7459"></a> <a name="chp-16-ITERM-7460"></a> <a name="chp-16-ITERM-7461"></a>queueing.</P>
</dd>
</dl>


<UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-16-sect-4.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-17.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
