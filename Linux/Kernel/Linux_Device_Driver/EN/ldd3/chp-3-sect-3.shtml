<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>3.3. Some Important Data Structures</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-3-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-3-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-3-sect-3"></a>
<H3 class="docSection1Title">3.3. Some Important Data Structures</H3>

<p class="docText">As you can imagine, device number registration
<a name="chp-3-ITERM-4405"></a>
<a name="chp-3-ITERM-4406"></a>
<a name="chp-3-ITERM-4407"></a>is just the first of many tasks
that driver code must carry out. We will soon look at other important
driver components, but one other digression is needed first. Most of
the fundamental driver operations involve three important kernel data
structures, called <tt>file_operations</tt>,
<tt>file</tt>, and <tt>inode</tt>. A basic
familiarity with these structures is required to be able to do much
of anything interesting, so we will now take a quick look at each of
them before getting into the details of how to implement the
fundamental driver operations.</p>

<a name="chp-3-sect-3.1"></a>
<h4 class="docSection2Title">3.3.1. File Operations</h4>

<p class="docText"><a name="chp-3-ITERM-4408"></a><a name="chp-3-ITERM-4409"></a><a name="chp-3-ITERM-4410"></a><a name="chp-3-ITERM-4411"></a>So far, we have reserved som<a name="chp-3-ITERM-4412"></a>
<a name="chp-3-ITERM-4413"></a> <a name="chp-3-ITERM-4414"></a>
<a name="chp-3-ITERM-4415"></a>
<a name="chp-3-ITERM-4416"></a> <a name="chp-3-ITERM-4417"></a>
<a name="chp-3-ITERM-4418"></a>e
device numbers for our use, but we have not yet connected any of our
driver's operations to those numbers. The
<tt>file_operations</tt> structure is how a char driver
sets up this connection. The structure, defined in
<i>&lt;linux/fs.h&gt;</I>, is a collection of function
pointers. Each open file (represented internally by a
<tt>file</tt> structure, which we will examine shortly) is
associated with its own set of functions (by including a field called
<tt>f_op</tt> that points to a
<tt>file_operations</tt> structure). The operations are
mostly in charge of implementing the system calls and are therefore,
named <span class="docEmphasis">open</span>, <span class="docEmphasis">read</span>, and so
on. We can consider the file to be an
"object" and the functions
operating on it to be its
"methods," using object-oriented
programming terminology to denote actions declared by an object to
act on itself. This is the first sign of object-oriented programming
we see in the Linux kernel, and we'll see more in
later chapters.</p>

<p class="docText"><a name="chp-3-ITERM-4419"></a>Conventionally, a
<tt>file_operations</tt> structure or a pointer to one is
called <tt>fops</tt> (or some variation thereof ). Each
field in the structure must point to the function in the driver that
implements a specific operation, or be left <tt>NULL</tt>
for unsupported operations. The exact behavior of the kernel when a
<tt>NULL</tt> pointer is specified is different for each
function, as the list later in this section shows.</p>

<p class="docText">The following list introduces all the operations that an application
can invoke on a device. We've tried to keep the list
brief so it can be used as a reference, merely summarizing each
operation and the default kernel behavior when a
<tt>NULL</tt> pointer is used.</P>

<p class="docText">As you read through the list of <tt>file_operations</tt>
methods, you will note that a number of parameters include the string
<tt>_ _user</tt>. This annotation is a form of
documentation, noting that a pointer is a user-space address that
cannot be directly dereferenced. For normal compilation, <tt>_
_user</tt> has no effect, but it can be used by external
checking software to find misuse of user-space addresses.</p>

<p class="docText">The rest of the chapter, after describing some other important data
structures, explains the role of the most important operations and
offers hints, caveats, and real code examples. We defer discussion of
the more complex operations to later chapters, because we
aren't ready to dig into topics such as memory
management, blocking operations, and asynchronous notification quite
yet.</p>

<a name="chp-3-ITERM-4420"></a><a name="chp-3-ITERM-4421"></a><a name="chp-3-ITERM-4422"></a><a name="chp-3-ITERM-4423"></a><a name="chp-3-ITERM-4424"></a><a name="chp-3-ITERM-4425"></a><a name="chp-3-ITERM-4426"></a><a name="chp-3-ITERM-4427"></a><a name="chp-3-ITERM-4428"></a><a name="chp-3-ITERM-4429"></a><a name="chp-3-ITERM-4430"></a><a name="chp-3-ITERM-4431"></a><a name="chp-3-ITERM-4432"></a><a name="chp-3-ITERM-4433"></a><a name="chp-3-ITERM-4434"></a><a name="chp-3-ITERM-4435"></a><a name="chp-3-ITERM-4436"></a><a name="chp-3-ITERM-4437"></a><a name="chp-3-ITERM-4438"></a><a name="chp-3-ITERM-4439"></a><a name="chp-3-ITERM-4440"></a><a name="chp-3-ITERM-4441"></a><a name="chp-3-ITERM-4442"></a><a name="chp-3-ITERM-4443"></a><a name="chp-3-ITERM-4444"></a><a name="chp-3-ITERM-4445"></a><a name="chp-3-ITERM-4446"></a><a name="chp-3-ITERM-4447"></a><a name="chp-3-ITERM-4448"></a><a name="chp-3-ITERM-4449"></a><a name="chp-3-ITERM-4450"></a><a name="chp-3-ITERM-4451"></a><a name="chp-3-ITERM-4452"></a><a name="chp-3-ITERM-4453"></a><a name="chp-3-ITERM-4454"></a><a name="chp-3-ITERM-4455"></a><a name="chp-3-ITERM-4456"></a><a name="chp-3-ITERM-4457"></a><a name="chp-3-ITERM-4458"></a><a name="chp-3-ITERM-4459"></a><a name="chp-3-ITERM-4460"></a><a name="chp-3-ITERM-4461"></a><a name="chp-3-ITERM-4462"></a><a name="chp-3-ITERM-4463"></a><a name="chp-3-ITERM-4464"></a><a name="chp-3-ITERM-4465"></a><a name="chp-3-ITERM-4466"></a><a name="chp-3-ITERM-4467"></a><a name="chp-3-ITERM-4468"></a><a name="chp-3-ITERM-4469"></a><a name="chp-3-ITERM-4470"></a><a name="chp-3-ITERM-4471"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct module *owner</span></span><a name="chp-3-ITERM-4420"></a>
<a name="chp-3-ITERM-4421"></a></span></dt></P>
<dd>
<p class="docList">The first <tt>file_operations</tt> field is not an
operation at all; it is a pointer to the module that
"owns" the structure. This field is
used to prevent the module from being unloaded while its operations
are in use. Almost all the time, it is simply initialized to
<tt>THIS_MODULE</tt>, a macro defined in
<i>&lt;linux/module.h&gt;</i>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">loff_t (*llseek) (struct file *, loff_t, int);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4422"></a>
<a name="chp-3-ITERM-4423"></a><a name="chp-3-ITERM-4424"></a><a name="chp-3-ITERM-4425"></a>The
<span class="docEmphasis">llseek</span><a name="chp-3-ITERM-4426"></a> method is used to change the current
read/write position in a file, and the new position is returned as a
(positive) return value. The <tt>loff_t</tt> parameter is a
"long offset" and is at least 64
bits wide even on 32-bit platforms. Errors are signaled by a negative
return value. If this function pointer is <tt>NULL</tt>,
seek calls will modify the position counter in the
<tt>file</tt> structure (described in <a class="docLink" href="chp-3-sect-3.shtml#chp-3-sect-3.2">Section 3.3.2</a>)
in potentially unpredictable ways.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*read) (struct file *, char _ _user *, size_t, loff_t *);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4427"></a>
<a name="chp-3-ITERM-4428"></a>Used
to retrieve data from the device. A null pointer in this position
causes the <span class="docEmphasis">read</span> system call to fail with
<tt>-EINVAL</tt> ("Invalid
argument"). A nonnegative return value represents
the number of bytes successfully read (the return value is a
"signed size" type, usually the
native integer type for the target platform).</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*aio_read)(struct kiocb *, char _ _user *, size_t, loff_t);</span></span></span></dt></P>
<dd>
<p class="docList">Initiates an asynchronous readâ€”a read operation that might not
complete before the function returns. If this method is
<tt>NULL</tt>, all operations will be processed
(synchronously) by <span class="docEmphasis">read</span> instead.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*write) (struct file *, const char _ _user *, size_t, loff_t *);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4429"></a>
<a name="chp-3-ITERM-4430"></a>Sends
data to the device. If <tt>NULL</tt>,
<tt>-EINVAL</tt> is returned to the program calling the
<span class="docEmphasis">write</span><a name="chp-3-ITERM-4431"></a> system call. The return value, if
nonnegative, represents the number of bytes successfully written.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*aio_write)(struct kiocb *, const char _ _user *, size_t, loff_t *);</span></span></span></dt></p>
<dd>
<p class="docList">Initiates an asynchronous write operation on the device.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*readdir) (struct file *, void *, filldir_t);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4432"></a>
<a name="chp-3-ITERM-4433"></a>This
field should be <tt>NULL</tt> for device files; it is used
for reading directories and is useful only for filesystems.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int (*poll) (struct file *, struct poll_table_struct *);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-3-ITERM-4434"></a>
<a name="chp-3-ITERM-4435"></a><a name="chp-3-ITERM-4436"></a>
<a name="chp-3-ITERM-4437"></a>The
<span class="docEmphasis">poll</span><a name="chp-3-ITERM-4438"></a> method is the back end of three system
calls: <span class="docEmphasis">poll, epoll</span>, and
<span class="docEmphasis">select</span>, all of which are used to query whether a
read or write to one or more file descriptors would block. The
<span class="docEmphasis">poll</span> method should return a bit mask indicating
whether non-blocking reads or writes are possible, and, possibly,
provide the kernel with information that can be used to put the
calling process to sleep until I/O becomes possible. If a driver
leaves its <span class="docEmphasis">poll</span> method <tt>NULL</tt>,
the device is assumed to be both readable and writable without
blocking.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-3-ITERM-4439"></a>
<a name="chp-3-ITERM-4440"></a>The
<span class="docEmphasis">ioctl</span> system call offers a way to issue
device-specific commands (such as formatting a track of a floppy
disk, which is neither reading nor writing). Additionally, a few
<span class="docEmphasis">ioctl</span> commands are recognized by the kernel
without referring to the <tt>fops</tt> table. If the device
doesn't provide an <span class="docEmphasis">ioctl</span>
method, the system call returns an error for any request that
isn't predefined (<tt>-ENOTTY</tt>,
"No such ioctl for device").</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*mmap) (struct file *, struct vm_area_struct *);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4441"></a>
<a name="chp-3-ITERM-4442"></a><span class="docEmphasis">mmap</span>
is used to request a mapping of device memory to a
process's address space. If this method is
<tt>NULL</tt>, the <span class="docEmphasis">mmap</span> system call
returns <tt>-ENODEV</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*open) (struct inode *, struct file *);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4443"></a>
<a name="chp-3-ITERM-4444"></a>Though
this is always the first operation performed on the device file, the
driver is not required to declare a corresponding method. If this
entry is <tt>NULL</tt>, opening the device always succeeds,
but your driver isn't notified.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*flush) (struct file *);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-3-ITERM-4445"></a>
<a name="chp-3-ITERM-4446"></a>The
<span class="docEmphasis">flush</span><a name="chp-3-ITERM-4447"></a>
<a name="chp-3-ITERM-4448"></a>
<a name="chp-3-ITERM-4449"></a>
operation is invoked when a process closes its copy of a file
descriptor for a device; it should execute (and wait for) any
outstanding operations on the device. This must not be confused with
the <span class="docEmphasis">fsync</span> operation requested by user programs.
Currently, <span class="docEmphasis">flush</span> is used in very few drivers;
the SCSI tape driver uses it, for example, to ensure that all data
written makes it to the tape before the device is closed. If
<span class="docEmphasis">flush</span> is <tt>NULL</tt>, the kernel
simply ignores the user application request.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*release) (struct inode *, struct file *);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4450"></a>
<a name="chp-3-ITERM-4451"></a>This
operation is invoked when the <tt>file</tt> structure is
being released. Like <span class="docEmphasis">open</span>,
<span class="docEmphasis">release</span> can be
<tt>NULL</tt>.<sup class="docFootnote"><a class="docLink" href="chp-3-sect-3.shtml#chp-3-FNOTE-5">[5]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="chp-3-FNOTE-5">[5]</a></sup> Note that
<span class="docEmphasis">release</span> isn't invoked every
time a process calls <span class="docEmphasis">close</span>. Whenever a
<tt>file</tt> structure is shared (for example, after a
<span class="docEmphasis">fork</span> or a <span class="docEmphasis">dup</span>),
<span class="docEmphasis">release</span> won't be invoked until
all copies are closed. If you need to flush pending data when any
copy is closed, you should implement the <span class="docEmphasis">flush</span>
method.</p></blockquote>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*fsync) (struct file *, struct dentry *, int);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4452"></a>
<a name="chp-3-ITERM-4453"></a>This
method is the back end of the <span class="docEmphasis">fsync</span> system call,
which a user calls to flush any pending data. If this pointer is
<tt>NULL</tt>, the system call returns
<tt>-EINVAL</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*aio_fsync)(struct kiocb *, int);</span></span></span></dt></p>
<dd>
<p class="docList">This is the asynchronous version of the <span class="docEmphasis">fsync</span>
method.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*fasync) (int, struct file *, int);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4454"></a>
<a name="chp-3-ITERM-4455"></a>This
operation is used to notify the device of a change in its
<tt>FASYNC</tt><a name="chp-3-ITERM-4456"></a> flag. Asynchronous notification is an
advanced topic and is described in <a class="docLink" href="chp-6.shtml#chp-6">Chapter 6</a>. The field can be
<tt>NULL</tt> if the driver doesn't
support asynchronous notification.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*lock) (struct file *, int, struct file_lock *);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4457"></a>
<a name="chp-3-ITERM-4458"></a>The<a name="chp-3-ITERM-4459"></a> <span class="docEmphasis">lock</span> method is used
to implement file locking; locking is an indispensable feature for
regular files but is almost never implemented by device drivers.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t</span></span> <span class="docPubcolor"><span class="docMonofont">*);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t</span></span> <span class="docPubcolor"><span class="docMonofont">*);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4460"></a>
<a name="chp-3-ITERM-4461"></a><a name="chp-3-ITERM-4462"></a>
<a name="chp-3-ITERM-4463"></a>These
methods implement scatter/gather read and write operations.
Applications occasionally need to do a single read or write operation
involving multiple memory areas; these system calls allow them to do
so without forcing extra copy operations on the data. If these
function pointers are left <tt>NULL</tt>, the
<span class="docEmphasis">read</span> and <span class="docEmphasis">write</span> methods are
called (perhaps more than once) instead.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*sendfile)(struct file *, loff_t *, size_t, read_actor_t, void *);</span></span></span></dt></P>
<dd>
<p class="docList">This method implements the read side of the
<span class="docEmphasis">sendfile</span><a name="chp-3-ITERM-4464"></a> system call, which moves the data from
one file descriptor to another with a minimum of copying. It is used,
for example, by a web server that needs to send the contents of a
file out a network connection. Device drivers usually leave
<span class="docEmphasis">sendfile</span> <tt>NULL</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *</span></span>, </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">int);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">sendpage</span><a name="chp-3-ITERM-4465"></a> is the other half of
<span class="docEmphasis">sendfile</span>; it is called by the kernel to send
data, one page at a time, to the corresponding file. Device drivers
do not usually implement <span class="docEmphasis">sendpage</span>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">long, unsigned long, unsigned long);</span></span></span></dt></p>
<dd>
<p class="docList">The purpose of this<a name="chp-3-ITERM-4466"></a>
<a name="chp-3-ITERM-4467"></a> method is to find a suitable location in
the process's address space to map in a memory
segment on the underlying device. This task is normally performed by
the memory management code; this method exists to allow drivers to
enforce any alignment requirements a particular device may have. Most
drivers can leave this method <tt>NULL</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*check_flags)(int)</span></span></span></dt></P>
<dd>
<p class="docList">This method allows a module to <a name="chp-3-ITERM-4468"></a>
<a name="chp-3-ITERM-4469"></a>check
the flags passed to an <span class="docEmphasis">fcntl(F_SETFL...)</span> call.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*dir_notify)(struct file *, unsigned long);</span></span></span></dt></p>
<dd>
<p class="docList">This method is invoked when an<a name="chp-3-ITERM-4470"></a>
<a name="chp-3-ITERM-4471"></a> application
uses <span class="docEmphasis">fcntl</span> to request directory change
notifications. It is useful only to filesystems; drivers need not
implement <span class="docEmphasis">dir_notify</span>.</p>
</dd>
</dl>

<p class="docText"><a name="chp-3-ITERM-4472"></a><a name="chp-3-ITERM-4473"></a>The <span class="docEmphasis">scull</span>
device driver implements only the most important device methods. Its
<tt>file_operations</tt> structure is initialized as
follows:</p>

<pre>struct file_operations scull_fops = {
    .owner =    THIS_MODULE,
    .llseek =   scull_llseek,
    .read =     scull_read,
    .write =    scull_write,
    .ioctl =    scull_ioctl,
    .open =     scull_open,
    .release =  scull_release,
};</pre><br>


<p class="docText">This declaration uses the standard C tagged structure initialization
syntax. This syntax is preferred because it makes drivers more
portable across changes in the definitions of the structures and,
arguably, makes the code more compact and readable. Tagged
initialization allows the reordering of structure members; in some
cases, substantial performance improvements have been realized by
placing pointers to frequently accessed members in the same
<a name="chp-3-ITERM-4474"></a>
<a name="chp-3-ITERM-4475"></a>
<a name="chp-3-ITERM-4476"></a>
<a name="chp-3-ITERM-4477"></a>
<a name="chp-3-ITERM-4478"></a>
<a name="chp-3-ITERM-4479"></a>
<a name="chp-3-ITERM-4480"></a>hardware
cache line.</p>


<a name="chp-3-sect-3.2"></a>
<h4 class="docSection2Title">3.3.2. The file Structure</h4>

<p class="docText"><tt>struct</tt> <tt>file</tt>, defined in
<i>&lt;linux/fs.h&gt;</i>, is
the<a name="chp-3-ITERM-4481"></a>
<a name="chp-3-ITERM-4482"></a>
<a name="chp-3-ITERM-4483"></a> second most
important data structure used in device drivers. Note that a
<tt>file</tt> has nothing to do with the
<tt>FILE</tt> pointers of user-space programs. A
<tt>FILE</tt> is defined in the C library and never appears
in kernel code. A <tt>struct</tt> <tt>file</tt>,
on the other hand, is a kernel structure that never appears in user
programs.</p>

<p class="docText"><a name="chp-3-ITERM-4484"></a>The <tt>file</tt> structure
represents an <span class="docEmphasis">open file</span><a name="chp-3-ITERM-4485"></a>
<a name="chp-3-ITERM-4486"></a>.
(It is not specific to device drivers; every open file in the system
has an associated <tt>struct</tt> <tt>file</tt>
in kernel space.) It is created by the kernel on
<span class="docEmphasis">open</span> and is passed to any function that operates
on the file, until the last <span class="docEmphasis">close</span>. After all
instances of the file are closed, the kernel releases the data
structure.</P>

<p class="docText"><a name="chp-3-ITERM-4487"></a>In the kernel
sources, a pointer to <tt>struct</tt>
<tt>file</tt> is usually called either
<tt>file</tt> or <tt>filp</tt>
("file pointer").
We'll consistently call the pointer
<tt>filp</tt> to prevent ambiguities with the structure
itself. Thus, <tt>file</tt> refers to the structure and
<tt>filp</tt> to a pointer to the structure.</p>

<p class="docText">The most important fields of <tt>struct</tt>
<tt>file</tt> are shown here. As in the previous section,
the list can be skipped on a first reading. However, later in this
chapter, when we face some real C code, we'll
discuss the fields in more detail.</P>

<a name="chp-3-ITERM-4488"></a><a name="chp-3-ITERM-4489"></a><a name="chp-3-ITERM-4490"></a><a name="chp-3-ITERM-4491"></a><a name="chp-3-ITERM-4492"></a><a name="chp-3-ITERM-4493"></a><a name="chp-3-ITERM-4494"></a><a name="chp-3-ITERM-4495"></a><a name="chp-3-ITERM-4496"></a><a name="chp-3-ITERM-4497"></a><a name="chp-3-ITERM-4498"></a><a name="chp-3-ITERM-4499"></a><a name="chp-3-ITERM-4500"></a><a name="chp-3-ITERM-4501"></a><a name="chp-3-ITERM-4502"></a><a name="chp-3-ITERM-4503"></a><a name="chp-3-ITERM-4504"></a><a name="chp-3-ITERM-4505"></a><a name="chp-3-ITERM-4506"></a><a name="chp-3-ITERM-4507"></a><a name="chp-3-ITERM-4508"></a><a name="chp-3-ITERM-4509"></a><a name="chp-3-ITERM-4510"></a><a name="chp-3-ITERM-4511"></a><a name="chp-3-ITERM-4512"></a><a name="chp-3-ITERM-4513"></a><a name="chp-3-ITERM-4514"></a><a name="chp-3-ITERM-4515"></a><a name="chp-3-ITERM-4516"></a><a name="chp-3-ITERM-4517"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">mode_t f_mode;</span></span><a name="chp-3-ITERM-4488"></a></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4489"></a><a name="chp-3-ITERM-4490"></a><a name="chp-3-ITERM-4491"></a>The
file mode identifies the file as either readable or writable (or
both), by means of the bits <tt>FMODE_READ</tt> and
<tt>FMODE_WRITE</tt>. You might want to check this field
for read/write permission in your <span class="docEmphasis">open</span> or
<span class="docEmphasis">ioctl</span> function, but you don't
need to check permissions for <span class="docEmphasis">read</span> and
<span class="docEmphasis">write</span>, because the kernel checks before invoking
your method. An attempt to read or write when the file has not been
opened for that type of access is rejected without the driver even
knowing about it.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">loff_t f_pos;</span></span><a name="chp-3-ITERM-4492"></a></span></dt></P>
<dd>
<p class="docList"><a name="chp-3-ITERM-4493"></a><a name="chp-3-ITERM-4494"></a>
<a name="chp-3-ITERM-4495"></a><a name="chp-3-ITERM-4496"></a>
<a name="chp-3-ITERM-4497"></a><a name="chp-3-ITERM-4498"></a>The current reading or writing position.
<tt>loff_t</tt> is a 64-bit value on all platforms
(<tt>long long</tt> in <span class="docEmphasis">gcc</span>
terminology). The driver can read this value if it needs to know the
current position in the file but should not normally change it;
<span class="docEmphasis">read</span> and <span class="docEmphasis">write</span> should
update a position using the pointer they receive as the last argument
instead of acting on <tt>filp-&gt;f_pos</tt> directly. The
one exception to this rule is in the <span class="docEmphasis">llseek</span>
method, the purpose of which is to change the file position.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned int f_flags;</span></span><a name="chp-3-ITERM-4499"></a></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4500"></a><a name="chp-3-ITERM-4501"></a><a name="chp-3-ITERM-4502"></a><a name="chp-3-ITERM-4503"></a><a name="chp-3-ITERM-4504"></a><a name="chp-3-ITERM-4505"></a>These are the file flags, such
as <tt>O_RDONLY</tt>, <tt>O_NONBLOCK</tt>, and
<tt>O_SYNC</tt>. A driver should check the
<tt>O_NONBLOCK</tt> flag to see if nonblocking operation
has been requested (we discuss nonblocking I/O in <a class="docLink" href="chp-6-sect-2.shtml#chp-6-sect-2.3">Section 6.2.3</a>); the other
flags are seldom used. In particular, read/write permission should be
checked using <tt>f_mode</tt> rather than
<tt>f_flags</tt>. All the flags are defined in the header
<i>&lt;linux/fcntl.h&gt;</i>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct file_operations *f_op;</span></span><a name="chp-3-ITERM-4506"></a></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4507"></a><a name="chp-3-ITERM-4508"></a><a name="chp-3-ITERM-4509"></a>The
operations associated with the file. The kernel assigns the pointer
as part of its implementation of <span class="docEmphasis">open</span> and then
reads it when it needs to dispatch any operations. The value in
<tt>filp-&gt;f_op</tt> is never saved by the kernel for
later reference; this means that you can change the file operations
associated with your file, and the new methods will be effective
after you return to the caller. For example, the code for
<span class="docEmphasis">open</span> associated with major number 1
(<I>/dev/null</I>, <i>/dev/zero</i>, and
so on) substitutes the operations in <tt>filp-&gt;f_op</tt>
depending on the minor number being opened. This practice allows the
implementation of several behaviors under the same major number
without introducing overhead at each system call. The ability to
replace the file operations is the kernel equivalent of
"method overriding" in
object-oriented programming.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *private_data;</span></span><a name="chp-3-ITERM-4510"></a></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4511"></a>
<a name="chp-3-ITERM-4512"></a><a name="chp-3-ITERM-4513"></a>The <span class="docEmphasis">open</span>
system call sets this pointer to <tt>NULL</tt> before
calling the <span class="docEmphasis">open</span> method for the driver. You are
free to make its own use of the field or to ignore it; you can use
the field to point to allocated data, but then you must remember to
free that memory in the <span class="docEmphasis">release</span> method before
the <tt>file</tt> structure is destroyed by the kernel.
<tt>private_data</tt> is a useful resource for preserving
state information across system calls and is used by most of our
sample modules.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct dentry *f_dentry;</span></span><a name="chp-3-ITERM-4514"></a></span></dt></p>
<dd>
<p class="docList"><a name="chp-3-ITERM-4515"></a><a name="chp-3-ITERM-4516"></a><a name="chp-3-ITERM-4517"></a>The directory entry
(<I>dentry</i>) structure associated with the file.
Device driver writers normally need not concern themselves with
dentry structures, other than to access the <tt>inode</tt>
structure as <tt>filp-&gt;f_dentry-&gt;d_inode</tt>.</P>
</dd>
</dl>

<p class="docText">The real structure has a few more fields, but they
aren't useful to device drivers. We can safely
ignore those fields, because drivers never create
<tt>file</tt> structures; they only access structures
created elsewhere.</p>


<a name="chp-3-sect-3.3"></a>
<h4 class="docSection2Title">3.3.3. The inode Structure</h4>

<p class="docText">The <i>inode</i> structure is<a name="chp-3-ITERM-4518"></a>
<a name="chp-3-ITERM-4519"></a>
<a name="chp-3-ITERM-4520"></a> <a name="chp-3-ITERM-4521"></a> used by the
<a name="chp-3-ITERM-4522"></a>kernel internally to represent
files. Therefore, it is different from the <tt>file</tt>
structure that represents an open file descriptor. There can be
numerous <tt>file</tt> structures representing multiple
open descriptors on a single file, but they all point to a single
<tt>inode</tt> structure.</p>

<p class="docText">The <tt>inode</tt> structure contains a great deal of
information about the file. As a general rule, only two fields of
this structure are of interest for writing driver code:</p>

<a name="chp-3-ITERM-4523"></a><a name="chp-3-ITERM-4524"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">dev_t i_rdev;</span></span><a name="chp-3-ITERM-4523"></a></span></dt></p>
<dd>
<p class="docList">For inodes that represent device files, this field contains the
actual device number.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct cdev *i_cdev;</span></span><a name="chp-3-ITERM-4524"></a></span></dt></P>
<dd>
<p class="docList"><tt>struct cdev</tt> is the kernel's
internal structure that represents char devices; this field contains
a pointer to that structure when the inode refers to a char device
file.</p>
</dd>
</dl>

<p class="docText">The type of <tt>i_rdev</tt> changed over the course of the
2.5 development series, breaking a lot of drivers. As a way of
encouraging more portable programming, the kernel developers have
added two macros that can be used to obtain the major and minor
number from an inode:</P>

<pre>unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);</pre><BR>


<p class="docText">In the interest of not being caught by the next change, these macros
should be used instead of manipulating <tt>i_rdev</tt>
directly.</p>



<ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-3-sect-2.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-3-sect-4.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
