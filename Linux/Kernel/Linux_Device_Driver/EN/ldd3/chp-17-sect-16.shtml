<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>17.16. Quick Reference</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-15.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-18.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-17-sect-16"></a>
<h3 class="docSection1Title" >17.16. Quick Reference</H3>

<p class="docText">This section provides a<a name="chp-17-ITERM-7881"></a>
<a name="chp-17-ITERM-7882"></a> <a name="chp-17-ITERM-7883"></a>
reference for the concepts introduced in this chapter. It also
explains the role of each header file that a driver needs to include.
The lists of fields in the <tt>net_device</tt> and
<tt>sk_buff</tt> structures, however, are not repeated
here.</p>

<a name="chp-17-ITERM-7884"></a><a name="chp-17-ITERM-7885"></a><a name="chp-17-ITERM-7886"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/netdevice.h&gt;</span></span></span></dt></p>
<dd>
<p class="docList">Header that hosts the definitions of <tt>struct</tt>
<tt>net_device</tt> and <tt>struct</tt>
<tt>net_device_stats</tt>, and includes a few other headers
that are needed by network drivers.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct net_device *alloc_netdev(int sizeof_priv, char *name, void</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">(*setup)(struct net_device *);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct net_device *alloc_etherdev(int sizeof_priv);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void free_netdev(struct net_device *dev);</span></span></span></dt></p>
<dd>
<p class="docList">Functions for allocating and freeing <tt>net_device</tt>
structures.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int register_netdev(struct net_device *dev);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void unregister_netdev(struct net_device *dev);</span></span></span></dt></p>
<dd>
<p class="docList">Registers and unregisters a network device.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *netdev_priv(struct net_device *dev);</span></span></span></dt></P>
<dd>
<p class="docList">A function that retrieves the pointer to the driver-private area of a
network device structure.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct net_device_stats;</span></span></span></dt></p>
<dd>
<p class="docList">A structure that holds device statistics.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">netif_start_queue(struct net_device *dev);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">netif_stop_queue(struct net_device *dev);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">netif_wake_queue(struct net_device *dev);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that control the passing of packets to the driver for
transmission. No packets are transmitted until
<span class="docEmphasis">netif_start_queue</span> has been called.
<span class="docEmphasis">netif_stop_queue</span> suspends transmission, and
<span class="docEmphasis">netif_wake_queue</span> restarts the queue and pokes
the network layer to restart transmitting packets.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">skb_shinfo(struct sk_buff *skb);</span></span></span></dt></p>
<dd>
<p class="docList">A macro that provides access to the "shared
info" portion of a packet buffer.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void netif_rx(struct sk_buff *skb);</span></span></span></dt></p>
<dd>
<p class="docList">Function that can be called (including at interrupt time) to notify
the kernel that a packet has been received and encapsulated into a
socket buffer.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void netif_rx_schedule(dev);</span></span></span></dt></p>
<dd>
<p class="docList">Function that informs the kernel that packets are available and that
polling should be started on the interface; it is used only by
NAPI-compliant drivers.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int netif_receive_skb(struct sk_buff *skb);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void netif_rx_complete(struct net_device *dev);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that should be used only by NAPI-compliant drivers.
<span class="docEmphasis">netif_receive_skb</span> is the NAPI equivalent to
<span class="docEmphasis">netif_rx</span>; it feeds a packet into the kernel.
When a NAPI-compliant driver has exhausted the supply of received
packets, it should reenable interrupts, and call
<span class="docEmphasis">netif_rx_complete</span> to stop polling.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/if.h&gt;</span></span></span></dt></p>
<dd>
<p class="docList">Included by <i>netdevice.h</I>, this file declares the
interface flags (<tt>IFF_</tt> macros) and <tt>struct
ifmap</tt>, which has a major role in the
<span class="docEmphasis">ioctl</span> implementation for network drivers.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void netif_carrier_off(struct net_device *dev);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void netif_carrier_on(struct net_device *dev);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int netif_carrier_ok(struct net_device *dev);</span></span></span></dt></P>
<dd>
<p class="docList">The first two functions may be used to tell the kernel whether a
carrier signal is currently present on the given interface.
<span class="docEmphasis">netif_carrier_ok</span> tests the carrier state as
reflected in the device structure.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/if_ether.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ETH_ALEN</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">ETH_P_IP</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct ethhdr;</span></span></span></dt></p>
<dd>
<p class="docList">Included by <i>netdevice.h</i>,
<I>if_ether.h</i> defines all the
<tt>ETH_</tt> macros used to represent octet lengths (such
as the address length) and network protocols (such as IP). It also
defines the <tt>ethhdr</tt> structure.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/skbuff.h&gt;</span></span></span></dt></p>
<dd>
<p class="docList">The definition of <tt>struct sk_buff</tt> and related
structures, as well as several inline functions to act on the
buffers. This header is included by <I>netdevice.h</i>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct sk_buff *alloc_skb(unsigned int len, int priority);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct sk_buff *dev_alloc_skb(unsigned int len);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void kfree_skb(struct sk_buff *skb);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dev_kfree_skb(struct sk_buff *skb);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dev_kfree_skb_irq(struct sk_buff *skb);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void dev_kfree_skb_any(struct sk_buff *skb);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that handle the allocation and freeing of socket buffers.
Drivers should normally use the <tt>dev_</tt> variants,
which are intended for that purpose.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned char *skb_put(struct sk_buff *skb, int len);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned char *_ _skb_put(struct sk_buff *skb, int len);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned char *skb_push(struct sk_buff *skb, int len);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned char *_ _skb_push(struct sk_buff *skb, int len);</span></span></span></dt></P>
<dd>
<p class="docList">Functions that add data to an <tt>skb</tt>;
<span class="docEmphasis">skb_put</span> puts the data at the end of the
<tt>skb</tt>, while <span class="docEmphasis">skb_push</span> puts it
at the beginning. The regular versions perform checking to ensure
that adequate space is available; double-underscore versions leave
those tests out.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int skb_headroom(struct sk_buff *skb);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int skb_tailroom(struct sk_buff *skb);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void skb_reserve(struct sk_buff *skb, int len);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that perform management of space within an
<tt>skb</tt>. <span class="docEmphasis">skb_headroom</span> and
<span class="docEmphasis">skb_tailroom</span> tell how much space is available at
the beginning and end, respectively, of an <tt>skb</tt>.
<span class="docEmphasis">skb_reserve</span> may be used to reserve space at the
beginning of an <tt>skb</tt>, which must be empty.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned char *skb_pull(struct sk_buff *skb, int len);</span></span></span></dt></p>
<dd>
<p class="docList"><span class="docEmphasis">skb_pull</span>
"removes" data from an
<tt>skb</tt> by adjusting the internal pointers.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int skb_is_nonlinear(struct sk_buff *skb);</span></span></span></dt></p>
<dd>
<p class="docList">Function that returns a true value if this skb is separated into
multiple fragments for scatter/gather I/O.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int skb_headlen(struct sk_buff *skb);</span></span></span></dt></p>
<dd>
<p class="docList">Returns the length of the first segment of the skbâ€”that part
pointed to by <tt>skb-&gt;data</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *kmap_skb_frag(skb_frag_t *frag);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void kunmap_skb_frag(void *vaddr);</span></span></span></dt></p>
<dd>
<p class="docList">Functions that provide direct access to fragments within a nonlinear
skb.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/etherdevice.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void ether_setup(struct net_device *dev);</span></span></span></dt></p>
<dd>
<p class="docList">Function that sets most device methods to the general-purpose
implementation for Ethernet drivers. It also sets
<tt>dev-&gt;flags</tt> and assigns the next available
<tt>eth</tt>x name to <tt>dev-&gt;name</tt> if
the first character in the name is a blank space or the
<tt>NULL</tt> character.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned short eth_type_trans(struct sk_buff *skb, struct net_device *dev);</span></span></span></dt></P>
<dd>
<p class="docList">When an Ethernet interface receives a packet, this function can be
called to set <tt>skb-&gt;pkt_type</tt>. The return value
is a protocol number that is usually stored in
<tt>skb-&gt;protocol</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/sockios.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">SIOCDEVPRIVATE</span></span></span></dt></P>
<dd>
<p class="docList">The first of 16 <span class="docEmphasis">ioctl</span> commands that can be
implemented by each driver for its own private use. All the network
<span class="docEmphasis">ioctl</span> commands are defined in
<I>sockios.h</I>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/mii.h&gt;</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct mii_if_info;</span></span></span></dt></p>
<dd>
<p class="docList">Declarations and a structure supporting drivers of devices that
implement the MII standard.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">#include &lt;linux/ethtool.h&gt;</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct ethtool_ops;</span></span></span></dt></P>
<dd>
<p class="docList">Declarations and structures that let devices work with the<a name="chp-17-ITERM-7884"></a> <a name="chp-17-ITERM-7885"></a> <a name="chp-17-ITERM-7886"></a>
<span class="docEmphasis">ethtool</span> utility.</p>
</dd>
</dl>


<UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-17-sect-15.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-18.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
