<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta name="generator" content="Muse">
    <meta http-equiv="Content-Type"
          content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" charset="utf-8" media="all"
          href="../main.css" >
    <link rel="shortcut icon" href="../favicon.ico" type="image/vnd.microsoft.icon">
    <script type="text/javascript" charset="utf-8" src="../main.js"></script>
    <title>基础数论算法 - maTH&mu; - 计算机代数系统</title>
  </head>
  <body>
<div id="banner"></div><!-- banner -->    
<div id="header">
    <h1>基础数论算法
  </h1>
  <a name="top"></a>
  <div id="tab">
  <ul>
    <li><a href="../index.html" title="主页"><span>主页</span></a></li>
    <li><a href="../Doc.html" title="文档"><span>文档</span></a></li>
    <li><a href="../Dev.html" title="开发"><span>开发</span></a></li>
    <li><a href="http://groups.google.com/group/maTHmU?hl=zh-CN" title="论坛"><span>论坛</span></a></li>
    <li><a href="../JoinUs.html" title="加入我们"><span>加入我们</span></a></li>
  </ul>
  </div><!-- tab -->
</div><!-- header -->
<div id="container">
  <div id="body">
    <div id="leftshadow">
      <div id="page"> 
 <!-- Page published by Emacs Muse begins here -->
<a href="NumberTheory.html#" onClick="ShowHide(content)">隐藏目录</a>
<div id="content" class="contents">
<dl>
  <dt>
    <a href="NumberTheory.html#sec1">快速求幂</a>
  </dt>
  <dd>
    <dl>
      <dt>
	<a href="NumberTheory.html#sec2">二进方法</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec3"><img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">进方法，窗口方法及加法链</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec4">Montgomery约化</a>
      </dt>
    </dl>
  </dd>
  <dt>
    <a href="NumberTheory.html#sec5">幂次检测</a>
  </dt>
  <dd>
    <dl>
      <dt>
	<a href="NumberTheory.html#sec6">整数开方</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec7">平方检测</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec8">素数幂检测</a>
      </dt>
    </dl>
  </dd>
  <dt>
    <a href="NumberTheory.html#sec9">最大公因子</a>
  </dt>
  <dd>
    <dl>
      <dt>
	<a href="NumberTheory.html#sec10">Euclid算法</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec11">Lehmer加速算法</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec12">二进方法（Binary GCD）</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec13">扩展Euclid算法</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec14">dmod与bmod</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec15">Jebelean-Weber-Sorenson加速算法</a>
      </dt>
    </dl>
  </dd>
  <dt>
    <a href="NumberTheory.html#sec16">Legendre-Jacobi-Kronecker符号</a>
  </dt>
  <dt>
    <a href="NumberTheory.html#sec17">中国剩余定理</a>
  </dt>
  <dt>
    <a href="NumberTheory.html#sec18">连分数展式</a>
  </dt>
  <dt>
    <a href="NumberTheory.html#sec19">素数计数函数<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18"></a>
  </dt>
  <dd>
    <dl>
      <dt>
	<a href="NumberTheory.html#sec20">部分筛函数</a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec21">计算<img src="latex/latex2png-NumberTheory_266655327_-5.gif" alt="$P_2(x,a)$" class="latex-inline" style="vertical-align: -5px" width="55" height="18"></a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec22">计算<img src="latex/latex2png-NumberTheory_228837297_-5.gif" alt="$\phi(x,a)$" class="latex-inline" style="vertical-align: -5px" width="47" height="18"></a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec23">计算<img src="latex/latex2png-NumberTheory_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13"></a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec24">计算<img src="latex/latex2png-NumberTheory_115117036_-2.gif" alt="$S_1$" class="latex-inline" style="vertical-align: -2px" width="15" height="14"></a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec25">计算<img src="latex/latex2png-NumberTheory_114985964_-3.gif" alt="$S_3$" class="latex-inline" style="vertical-align: -3px" width="15" height="15"></a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec26">计算<img src="latex/latex2png-NumberTheory_115051500_-2.gif" alt="$S_2$" class="latex-inline" style="vertical-align: -2px" width="15" height="14"></a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec27">计算<img src="latex/latex2png-NumberTheory_43545618_-1.gif" alt="$V$" class="latex-inline" style="vertical-align: -1px" width="13" height="13"></a>
      </dt>
      <dt>
	<a href="NumberTheory.html#sec28">计算<img src="latex/latex2png-NumberTheory_64719852_-2.gif" alt="$V_2$" class="latex-inline" style="vertical-align: -2px" width="16" height="14"></a>
      </dt>
    </dl>
  </dd>
  <dt>
    <a href="NumberTheory.html#sec29">第<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">个素数<img src="latex/latex2png-NumberTheory_238580756_-4.gif" alt="$p_n$" class="latex-inline" style="vertical-align: -4px" width="17" height="12"></a>
  </dt>
  <dt>
    <a href="NumberTheory.html#sec30">M&ouml;bius函数<img src="latex/latex2png-NumberTheory_57958885_-5.gif" alt="$\mu(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">和Euler函数<img src="latex/latex2png-NumberTheory_110973654_-5.gif" alt="$\varphi(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18"></a>
  </dt>
</dl>
</div>

<p><span class="nocite"><a class="cite" href="NumberTheory.html#ref-1" name="cite-1">[1]</a></span></p>

<h2><a name="sec1" id="sec1"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>快速求幂</h2>

<h3><a name="sec2" id="sec2"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>二进方法</h3>

<p class="first">设<img src="latex/latex2png-NumberTheory_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">为一乘法群，<img src="latex/latex2png-NumberTheory_16588715_-1.gif" alt="$n\in \mathbb{Z}$" class="latex-inline" style="vertical-align: -1px" width="41" height="13">（<img src="latex/latex2png-NumberTheory_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">可只为乘法半群，此时限定<img src="latex/latex2png-NumberTheory_29171627_-1.gif" alt="$n\in \mathbb{N}$" class="latex-inline" style="vertical-align: -1px" width="42" height="13">），计算<img src="latex/latex2png-NumberTheory_129393566_-4.gif" alt="$g\in G$" class="latex-inline" style="vertical-align: -4px" width="42" height="16">的幂次<img src="latex/latex2png-NumberTheory_86537236_-4.gif" alt="$g^n$" class="latex-inline" style="vertical-align: -4px" width="17" height="15">是在计算机代数系统中到处出现的运算（尤其是<img src="latex/latex2png-NumberTheory_43581359_-5.gif" alt="$G=\mathbb{Z}/N\mathbb{Z}$" class="latex-inline" style="vertical-align: -5px" width="79" height="18">的情形），因此快速进行求幂起着非常基本的作用。最平凡的方法需要<img src="latex/latex2png-NumberTheory_151221268_0.gif" alt="$n-1$" class="latex-inline" style="vertical-align: 0px" width="37" height="11">个乘法，不过我们有办法大幅地改进乘法的次数。</p>

<p>一个启发性的想法是二分策略。例如我们要求<img src="latex/latex2png-NumberTheory_73899109_-4.gif" alt="$g^{11}$" class="latex-inline" style="vertical-align: -4px" width="22" height="18">，而11的二进制表示为<img src="latex/latex2png-NumberTheory_203979816_-2.gif" alt="$11=2^3+2+1$" class="latex-inline" style="vertical-align: -2px" width="109" height="16">，可以依次求出<img src="latex/latex2png-NumberTheory_38798277_-4.gif" alt="$g^1, g^2, g^4, g^8$" class="latex-inline" style="vertical-align: -4px" width="85" height="18">，再计算<img src="latex/latex2png-NumberTheory_156453311_-4.gif" alt="$g^3=g^1\cdot g^2$" class="latex-inline" style="vertical-align: -4px" width="81" height="18">及<img src="latex/latex2png-NumberTheory_69162140_-4.gif" alt="$g^{11}=g^3\cdot g^8$" class="latex-inline" style="vertical-align: -4px" width="87" height="18">，总共只用了5次乘法便得到了结果。这种方法被称为自右向左的二进方法（Right-left Binary）。另外还有一种自左向右的二进方法（Left-right Binary）：对于上面的例子依次求出<img src="latex/latex2png-NumberTheory_85160980_-4.gif" alt="$g^1$" class="latex-inline" style="vertical-align: -4px" width="15" height="18">，<img src="latex/latex2png-NumberTheory_85226516_-4.gif" alt="$g^2$" class="latex-inline" style="vertical-align: -4px" width="15" height="18">，<img src="latex/latex2png-NumberTheory_198414235_-5.gif" alt="$g^4=(g^2)^2$" class="latex-inline" style="vertical-align: -5px" width="73" height="19">，<img src="latex/latex2png-NumberTheory_153373087_-4.gif" alt="$g^5=g^4\cdot g^1$" class="latex-inline" style="vertical-align: -4px" width="81" height="18">，<img src="latex/latex2png-NumberTheory_57514166_-5.gif" alt="$g^{10}=(g^5)^2$" class="latex-inline" style="vertical-align: -5px" width="79" height="19">，<img src="latex/latex2png-NumberTheory_254583385_-4.gif" alt="$g^{11}=g^{10}\cdot g^1$" class="latex-inline" style="vertical-align: -4px" width="94" height="18">，同样用5次乘法得到结果。</p>

<div class="algorithm">
<span class="theorem-header">算法1<a name="al:r2l"></a></span><span class="theorem-name">(自右向左的二进方法)</span>
设二进表示<img src="latex/latex2png-NumberTheory_123276339_-16.gif" alt="$n=\sum\limits_{k=0}^m\varepsilon_k2^k$" class="latex-inline" style="vertical-align: -16px" width="90" height="37">（假定<img src="latex/latex2png-NumberTheory_168981524_-1.gif" alt="$n>0$" class="latex-inline" style="vertical-align: -1px" width="40" height="12">，否则考虑<img src="latex/latex2png-NumberTheory_27138575_-5.gif" alt="$(g^{-1})^{|n|}$" class="latex-inline" style="vertical-align: -5px" width="53" height="20">），<img src="latex/latex2png-NumberTheory_50105324_0.gif" alt="$a=1$" class="latex-inline" style="vertical-align: 0px" width="38" height="11">，重复以下步骤，第<img src="latex/latex2png-NumberTheory_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">步（<img src="latex/latex2png-NumberTheory_13699146_-4.gif" alt="$k=0, 1, \ldots, m$" class="latex-inline" style="vertical-align: -4px" width="106" height="16">)执行：

<ol>
<li>计算<img src="latex/latex2png-NumberTheory_165107206_-5.gif" alt="$g^{2^k}=(g^{2^{k-1}})^2$" class="latex-inline" style="vertical-align: -5px" width="102" height="22">。</li>
<li>若<img src="latex/latex2png-NumberTheory_120230420_-2.gif" alt="$\varepsilon_k=1$" class="latex-inline" style="vertical-align: -2px" width="45" height="13">，则令<img src="latex/latex2png-NumberTheory_98415000_-4.gif" alt="$a\leftarrow a\cdot g^{2^k}$" class="latex-inline" style="vertical-align: -4px" width="77" height="21">。</li>
<li>若<img src="latex/latex2png-NumberTheory_118977556_0.gif" alt="$k=m$" class="latex-inline" style="vertical-align: 0px" width="45" height="12">，输出<img src="latex/latex2png-NumberTheory_168523415_-4.gif" alt="$g^n=a$" class="latex-inline" style="vertical-align: -4px" width="48" height="15">，算法终止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注1<a name=""></a></span><span class="theorem-name"></span>
实践中<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的二进表达式不需要预先存储，其计算（通过位操作）可以与<img src="latex/latex2png-NumberTheory_42596680_-4.gif" alt="$g^{2^k}$" class="latex-inline" style="vertical-align: -4px" width="22" height="21">的计算同步进行。


</div>

<div class="remark">
<span class="proof-header">注2<a name=""></a></span><span class="theorem-name"></span>
不难验证<img src="latex/latex2png-NumberTheory_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">中进行求<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">次幂的乘法次数为<img src="latex/latex2png-NumberTheory_228636278_-16.gif" alt="$m-1+\sum\limits_{k=0}^m\varepsilon_k=O(\log n)$" class="latex-inline" style="vertical-align: -16px" width="187" height="37">，这要远小于平凡算法的<img src="latex/latex2png-NumberTheory_151221268_0.gif" alt="$n-1$" class="latex-inline" style="vertical-align: 0px" width="37" height="11">。


</div>

<div class="algorithm">
<span class="theorem-header">算法2<a name="al:l2r"></a></span><span class="theorem-name">(自左向右的二进方法)</span>
设二进表示<img src="latex/latex2png-NumberTheory_123276339_-16.gif" alt="$n=\sum\limits_{k=0}^m\varepsilon_k2^k$" class="latex-inline" style="vertical-align: -16px" width="90" height="37">（假定<img src="latex/latex2png-NumberTheory_168981524_-1.gif" alt="$n>0$" class="latex-inline" style="vertical-align: -1px" width="40" height="12">，否则考虑<img src="latex/latex2png-NumberTheory_27138575_-5.gif" alt="$(g^{-1})^{|n|}$" class="latex-inline" style="vertical-align: -5px" width="53" height="20">），<img src="latex/latex2png-NumberTheory_49187820_-4.gif" alt="$a=g$" class="latex-inline" style="vertical-align: -4px" width="39" height="12">，重复以下步骤，第<img src="latex/latex2png-NumberTheory_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">步（<img src="latex/latex2png-NumberTheory_187485373_-4.gif" alt="$k=m-1, m-2,\ldots, 0$" class="latex-inline" style="vertical-align: -4px" width="170" height="16">)执行：

<ol>
<li>若<img src="latex/latex2png-NumberTheory_120295956_-2.gif" alt="$\varepsilon_k=0$" class="latex-inline" style="vertical-align: -2px" width="46" height="13">，则<img src="latex/latex2png-NumberTheory_233512485_-1.gif" alt="$a\leftarrow a^2$" class="latex-inline" style="vertical-align: -1px" width="50" height="15">。</li>
<li>若<img src="latex/latex2png-NumberTheory_120230420_-2.gif" alt="$\varepsilon_k=1$" class="latex-inline" style="vertical-align: -2px" width="45" height="13">，则<img src="latex/latex2png-NumberTheory_233512485_-1.gif" alt="$a\leftarrow a^2$" class="latex-inline" style="vertical-align: -1px" width="50" height="15">，<img src="latex/latex2png-NumberTheory_86600695_-4.gif" alt="$a\leftarrow a\cdot g$" class="latex-inline" style="vertical-align: -4px" width="63" height="13">。</li>
<li>若<img src="latex/latex2png-NumberTheory_117601300_-1.gif" alt="$k=0$" class="latex-inline" style="vertical-align: -1px" width="39" height="13">，输出<img src="latex/latex2png-NumberTheory_168523415_-4.gif" alt="$g^n=a$" class="latex-inline" style="vertical-align: -4px" width="48" height="15">，算法中止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注3<a name=""></a></span><span class="theorem-name"></span>
算法<a class="ref-th" href="NumberTheory.html#al:r2l">1</a>与算法<a class="ref-th" href="NumberTheory.html#al:l2r">2</a>求<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">次幂所用的乘法次数相同，但在算法<a class="ref-th" href="NumberTheory.html#al:l2r">2</a>第二步累乘时乘上的因子<img src="latex/latex2png-NumberTheory_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">要比算法<a class="ref-th" href="NumberTheory.html#al:r2l">1</a>乘上的因子<img src="latex/latex2png-NumberTheory_42596680_-4.gif" alt="$g^{2^k}$" class="latex-inline" style="vertical-align: -4px" width="22" height="21">小一些。


</div>


<h3><a name="sec3" id="sec3"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a><img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">进方法，窗口方法及加法链</h3>

<p class="first">二进方法的一个很自然的推广就是<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">进方法，利用<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">进表示，类似二进方法的平方而不断地进行<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">次幂。<img src="latex/latex2png-NumberTheory_136672923_0.gif" alt="$m=2^k$" class="latex-inline" style="vertical-align: 0px" width="52" height="14">的情形尤其简单，因此在实践中也很常用。不同于二进方法，<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">进方法还需要额外储存<img src="latex/latex2png-NumberTheory_54066270_-4.gif" alt="$g^2,g^3,\ldots,g^{m-1}$" class="latex-inline" style="vertical-align: -4px" width="113" height="18">的值。</p>

<p><img src="latex/latex2png-NumberTheory_131763180_0.gif" alt="$2^k$" class="latex-inline" style="vertical-align: 0px" width="15" height="14">进方法的进一步改进是所谓窗口算法(Window Method)，取一个固定长度<img src="latex/latex2png-NumberTheory_98792468_-2.gif" alt="$k+1$" class="latex-inline" style="vertical-align: -2px" width="36" height="14">的“窗口”，用窗口自左向右扫描<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的二进表达，计算窗口内的乘幂（往往预先计算好<img src="latex/latex2png-NumberTheory_3231032_-4.gif" alt="$g^3,\ldots,g^{2^k-1}$" class="latex-inline" style="vertical-align: -4px" width="91" height="21">），然后通过乘幂将窗口向右平移，将下一个窗口内的数乘以已经得到的幂，再重复平移过程。例如考虑<img src="latex/latex2png-NumberTheory_125913266_-1.gif" alt="$n=26235947428953663183191$" class="latex-inline" style="vertical-align: -1px" width="221" height="13">。用8进方法需要102次乘法，而通过长度4的窗口算法可以减少到93次<span class="cite"><a class="cite" href="NumberTheory.html#ref-2" name="cite-2">[2]</a></span>，下式表示了此窗口算法的过程。</p>

<p class="image"><img src="latex/latex2png-NumberTheory_21977350_.gif" alt="
{\scriptsize$$\ul{1011}{11}000\ul{111}{7}00\ul{1}{1}000000\ul{1110}{7}\ul{1001}{9}0\ul{1001}{9}\ul{1101}{13}0\ul{1}{1}000000\ul{1011}{11}\ul{11}{3}00000\ul{1111}{15}\ul{1001}{9}\ul{1001}{9}0\ul{101}{5}0\ul{111}{7}$$}
" class="latex-display" width="580" height="19"></p>

<p>二进方法的乘法次数较平凡算法有本质的减少，一个很自然的问题是：计算<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">次幂所需要的最少乘法次数是多少？这等价于求<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的加法链的最短长度<img src="latex/latex2png-NumberTheory_210465850_-5.gif" alt="$l(n)$" class="latex-inline" style="vertical-align: -5px" width="26" height="18"><span class="cite"><a class="cite" href="NumberTheory.html#ref-3" name="cite-3">[3]</a></span>。构造最短长度的加法链是较为困难的问题，在实践中只能构造“近似”最短的加法链。一个构造方法是通过“幂树”，其构造方法是：首先在第一层置1，当置完<img src="latex/latex2png-NumberTheory_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">层后，从左到右依次取第<img src="latex/latex2png-NumberTheory_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">层每个节点<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">，在其下附加节点<img src="latex/latex2png-NumberTheory_65445030_-4.gif" alt="$n+1,n+a_1,\ldots,n+a_{k-1}=2n$" class="latex-inline" style="vertical-align: -4px" width="234" height="15">，其中<img src="latex/latex2png-NumberTheory_210699603_-4.gif" alt="$1,a_1,a_2,\ldots,a_{k-1}$" class="latex-inline" style="vertical-align: -4px" width="124" height="15">是树根到<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的到<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的通路上的点，但已出现的节点不予添加。下图显示了前4层幂树。</p>

<table class="image" width="100%">
  <tr><td align="center"><img src="images/powertree.png" alt="前4层幂树"></td></tr>
  <tr><td align="center" class="image-caption">前4层幂树</td></tr>
</table>

<p>有了幂树之后，当我们要计算某个<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">次幂时，只需要在该树上找到<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">，依次计算从根节点到<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的路径上的幂次即可。</p>

<p>幂树构造简单，但对较大的<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">树的规模会很大（实际得到了<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">以下所有数的近似加法链）。有许多启发性的算法来构造直接<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的近似最短加法链（参见<span class="cite"><a class="cite" href="NumberTheory.html#ref-2" name="cite-2">[2]</a></span>,<span class="cite"><a class="cite" href="NumberTheory.html#ref-4" name="cite-4">[4]</a></span>）。</p>

<p>另外窗口算法和加法链也可以结合起来使用。由于当窗口长度增加时，需要预先计算的<img src="latex/latex2png-NumberTheory_42038290_-4.gif" alt="$g$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">的幂数量增多，可以构造加法序列（含所需幂次的加法链）来减少预先的计算量。使用长度较大的窗口的确能够减少乘法的次数，例如对前面的例子，可以将93次乘法进一步减少到89次。下式显示了长度为8的窗口算法过程。</p>

<p class="image"><img src="latex/latex2png-NumberTheory_26843668_.gif" alt="
{\scriptsize$$\ul{1011000111001}{5689}000000\ul{1110100101}{933}00\ul{1110101}{117}000000\ul{101111}{47}00000\ul{111110011}{499}00\ul{101010111}{343}$$}
" class="latex-display" width="580" height="19"></p>

<div class="remark">
<span class="proof-header">注4<a name=""></a></span><span class="theorem-name"></span>
前面所述的乘幂算法对一般的乘法半群均适用（例如矩阵乘法，多项式乘法）。考虑乘幂运算对象的特性，还有更多可能改进的空间。例如<img src="latex/latex2png-NumberTheory_42562578_-1.gif" alt="$G$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">为椭圆曲线的特殊情形（在这里是加法群），由于元素的逆较为容易求得，可以考虑形如<img src="latex/latex2png-NumberTheory_236271670_-19.gif" alt="$n=\sum\limits_{i\ge0}\varepsilon_i2^i\,(\varepsilon_i\in\{0,\pm1\})$" class="latex-inline" style="vertical-align: -19px" width="184" height="33">的冗余二进制表示，来减少乘法次数。对于<img src="latex/latex2png-NumberTheory_43581359_-5.gif" alt="$G=\mathbb{Z}/N\mathbb{Z}$" class="latex-inline" style="vertical-align: -5px" width="79" height="18">的特殊情形则有下面将要介绍的著名的Montgomery约化过程。


</div>


<h3><a name="sec4" id="sec4"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>Montgomery约化</h3>

<p class="first">乘幂运算最常见还是出现在<img src="latex/latex2png-NumberTheory_43581359_-5.gif" alt="$G=\mathbb{Z}/N\mathbb{Z}$" class="latex-inline" style="vertical-align: -5px" width="79" height="18">中。Montgomery<span class="cite"><a class="cite" href="NumberTheory.html#ref-5" name="cite-5">[5]</a></span>提出一个避免试除的计算模乘法的方法，对于<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">固定，需要大量乘法的模幂运算尤其有效。主要想法是将模<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">的运算转化为模机器字长（例如<img src="latex/latex2png-NumberTheory_108501909_0.gif" alt="$2^{32}$" class="latex-inline" style="vertical-align: 0px" width="21" height="14">）的运算，而后者是硬件快速实现的。</p>

<div class="definition">
<span class="theorem-header">定义1<a name=""></a></span><span class="theorem-name"></span>
记<img src="latex/latex2png-NumberTheory_33220268_-5.gif" alt="$\overline{x}=x\bmod{N}\in\{0, 1, \ldots, N-1\}$" class="latex-inline" style="vertical-align: -5px" width="237" height="18">，即<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">模<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">的余数。设<img src="latex/latex2png-NumberTheory_43283474_-1.gif" alt="$R$" class="latex-inline" style="vertical-align: -1px" width="13" height="13">为一个进制的基（通常取为机器字长或其幂次），满足<img src="latex/latex2png-NumberTheory_220874999_-5.gif" alt="$(R, N)=1$" class="latex-inline" style="vertical-align: -5px" width="76" height="18">，<img src="latex/latex2png-NumberTheory_164596716_-1.gif" alt="$R>N$" class="latex-inline" style="vertical-align: -1px" width="50" height="13">。则<img src="latex/latex2png-NumberTheory_9774016_-3.gif" alt="$\exists\, 0\leq u<N$" class="latex-inline" style="vertical-align: -3px" width="88" height="15">，<img src="latex/latex2png-NumberTheory_192250835_-3.gif" alt="$0\leq v<R$" class="latex-inline" style="vertical-align: -3px" width="74" height="15">成立Bezout等式<img src="latex/latex2png-NumberTheory_146640712_-1.gif" alt="$u\cdot R-v\cdot N=1$" class="latex-inline" style="vertical-align: -1px" width="119" height="13">，我们定义<img src="latex/latex2png-NumberTheory_48519065_0.gif" alt="$\widetilde{x}:=\overline{xu}$" class="latex-inline" style="vertical-align: 0px" width="55" height="12">，称为<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">的Montgomery表示。


</div>

<div class="remark">
<span class="proof-header">注5<a name=""></a></span><span class="theorem-name"></span>
由定义可知<img src="latex/latex2png-NumberTheory_141838506_-1.gif" alt="$\overline{uR}=1$" class="latex-inline" style="vertical-align: -1px" width="51" height="15">以及<img src="latex/latex2png-NumberTheory_119571024_-1.gif" alt="$\overline{x}=\widetilde{xR}$" class="latex-inline" style="vertical-align: -1px" width="54" height="18">。并且当<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">跑遍模<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">的一个完全剩余系时，<img src="latex/latex2png-NumberTheory_44467149_0.gif" alt="$\widetilde{x}$" class="latex-inline" style="vertical-align: 0px" width="10" height="12">也跑遍模<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">的完全剩余系，因此<img src="latex/latex2png-NumberTheory_44467149_0.gif" alt="$\widetilde{x}$" class="latex-inline" style="vertical-align: 0px" width="10" height="12">这种表示不会损失信息。


</div>

<p>下面的快速计算<img src="latex/latex2png-NumberTheory_44467149_0.gif" alt="$\widetilde{x}$" class="latex-inline" style="vertical-align: 0px" width="10" height="12">的算法是Montgomery模幂乘法的核心。</p>

<div class="algorithm">
<span class="theorem-header">算法3<a name="al:monredc"></a></span><span class="theorem-name">(Montgomery约化)</span>
设<img src="latex/latex2png-NumberTheory_65436679_-3.gif" alt="$0\le x<RN$" class="latex-inline" style="vertical-align: -3px" width="90" height="15">，以下步骤计算<img src="latex/latex2png-NumberTheory_44467149_0.gif" alt="$\widetilde{x}$" class="latex-inline" style="vertical-align: 0px" width="10" height="12">。

<ol>
<li>计算<img src="latex/latex2png-NumberTheory_181150718_-5.gif" alt="$m=(x \bmod R)\cdot v \bmod R$" class="latex-inline" style="vertical-align: -5px" width="188" height="18">，<img src="latex/latex2png-NumberTheory_154915985_-3.gif" alt="$0\le m<R$" class="latex-inline" style="vertical-align: -3px" width="80" height="15">。</li>
<li>计算<img src="latex/latex2png-NumberTheory_180074740_-5.gif" alt="$t=(x+mN)/R$" class="latex-inline" style="vertical-align: -5px" width="121" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_256941362_-3.gif" alt="$t\ge N$" class="latex-inline" style="vertical-align: -3px" width="43" height="15">输出<img src="latex/latex2png-NumberTheory_253785108_0.gif" alt="$t-N$" class="latex-inline" style="vertical-align: 0px" width="41" height="12">，否则输出<img src="latex/latex2png-NumberTheory_42890258_0.gif" alt="$t$" class="latex-inline" style="vertical-align: 0px" width="5" height="11">，算法终止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注6<a name=""></a></span><span class="theorem-name"></span>
当<img src="latex/latex2png-NumberTheory_43283474_-1.gif" alt="$R$" class="latex-inline" style="vertical-align: -1px" width="13" height="13">取为机器字长时，第一、二步中的模运算和出发运算都可直接通过位操作快速进行。


</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法的有效性)</span>
首先由<img src="latex/latex2png-NumberTheory_186158823_-5.gif" alt="$x+mN\equiv x+ xv N\equiv x(1+vN)\equiv x uR\equiv0\pmod{R}$" class="latex-inline" style="vertical-align: -5px" width="395" height="18">知<img src="latex/latex2png-NumberTheory_42890258_0.gif" alt="$t$" class="latex-inline" style="vertical-align: 0px" width="5" height="11">为整数。再由<img src="latex/latex2png-NumberTheory_180074740_-5.gif" alt="$t=(x+mN)/R$" class="latex-inline" style="vertical-align: -5px" width="121" height="18">，知<img src="latex/latex2png-NumberTheory_17516859_-5.gif" alt="$uRt=(xu+umN)$" class="latex-inline" style="vertical-align: -5px" width="140" height="18">，从而<img src="latex/latex2png-NumberTheory_74515607_-1.gif" alt="$\overline{uRt}=\overline{xu}$" class="latex-inline" style="vertical-align: -1px" width="69" height="15">，即有<img src="latex/latex2png-NumberTheory_26064043_0.gif" alt="$\overline{t}=\widetilde{x}$" class="latex-inline" style="vertical-align: 0px" width="38" height="13">。最后由<img src="latex/latex2png-NumberTheory_65436679_-3.gif" alt="$0\le x<RN$" class="latex-inline" style="vertical-align: -3px" width="90" height="15">，<img src="latex/latex2png-NumberTheory_154915985_-3.gif" alt="$0\le m<R$" class="latex-inline" style="vertical-align: -3px" width="80" height="15">，知<img src="latex/latex2png-NumberTheory_181465954_-3.gif" alt="$0\le t< 2N$" class="latex-inline" style="vertical-align: -3px" width="82" height="15">，可得算法的有效性。
<span class="proof-end">□</span>

</div>


<p>下面的命题表明，在Montgomery表示下，<img src="latex/latex2png-NumberTheory_165148199_0.gif" alt="$\widetilde{mn}$" class="latex-inline" style="vertical-align: 0px" width="25" height="13">即表示<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">与<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的乘积。
<div class="proposition">
<span class="theorem-header">命题1<a name="pr:tilde"></a></span><span class="theorem-name"></span>
设<img src="latex/latex2png-NumberTheory_142067440_-4.gif" alt="$m, n\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -4px" width="63" height="16">，则<img src="latex/latex2png-NumberTheory_170871263_.gif" alt="$$\overline{\widetilde{m}\cdot\widetilde{n}}=\widetilde{\widetilde{m\cdot n}}.$$" class="latex-display" width="580" height="20"></p>


</div>

<div class="proof">
<span class="proof-header">证明</span>
由定义，<img src="latex/latex2png-NumberTheory_213490292_0.gif" alt="$\overline{\widetilde{m}\cdot\widetilde{n}}=\overline{mu}\cdot\overline{nu}=\overline{mnu^2}=\widetilde{mnu}=\widetilde{\widetilde{m\cdot n}}$" class="latex-inline" style="vertical-align: 0px" width="293" height="20">。
<span class="proof-end">□</span>

</div>

<p>为求<img src="latex/latex2png-NumberTheory_145723814_-4.gif" alt="$\overline{x\cdot y}$" class="latex-inline" style="vertical-align: -4px" width="31" height="14">，首先将<img src="latex/latex2png-NumberTheory_121776582_-4.gif" alt="$\overline{x}, \overline{y}$" class="latex-inline" style="vertical-align: -4px" width="26" height="14">逆变换为Montgomery表示<img src="latex/latex2png-NumberTheory_204485693_-4.gif" alt="$\widetilde{xR}, \widetilde{yR}$" class="latex-inline" style="vertical-align: -4px" width="51" height="21">，再利用命题<a class="ref-th" href="NumberTheory.html#pr:tilde">1</a>和算法<a class="ref-th" href="NumberTheory.html#al:monredc">3</a>即可。</p>

<div class="remark">
<span class="proof-header">注7<a name=""></a></span><span class="theorem-name"></span>
应用算法<a class="ref-th" href="NumberTheory.html#al:monredc">3</a>时要注意保证输入满足在0和<img src="latex/latex2png-NumberTheory_158364690_-1.gif" alt="$RN$" class="latex-inline" style="vertical-align: -1px" width="28" height="13">之间，而<img src="latex/latex2png-NumberTheory_247231262_-4.gif" alt="$xR\cdot yR$" class="latex-inline" style="vertical-align: -4px" width="56" height="16">并不满足此条件。可对两乘数先做一个模<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">处理，这可利用<img src="latex/latex2png-NumberTheory_265142521_-1.gif" alt="$\overline{xR}=\widetilde{x\overline{R^2}}$" class="latex-inline" style="vertical-align: -1px" width="74" height="22">来完成，而<img src="latex/latex2png-NumberTheory_56621126_-1.gif" alt="$\overline{R^2}$" class="latex-inline" style="vertical-align: -1px" width="21" height="16">作为一个固定的常数可预先计算好，反复使用。在求幂的过程中，由于<img src="latex/latex2png-NumberTheory_240153659_-4.gif" alt="$R, N$" class="latex-inline" style="vertical-align: -4px" width="35" height="16">固定，只需要在第一步逆变换为Montgomery表示，中间结果全部用Montgomery表示来运算（运用算法<a class="ref-th" href="NumberTheory.html#al:r2l">1</a>或<a class="ref-th" href="NumberTheory.html#al:l2r">2</a>），并对最终结果变换回正常表示即可，由此加快了求幂的运算速度。


</div>
<div class="remark">
<span class="proof-header">注8<a name=""></a></span><span class="theorem-name"></span>
当<img src="latex/latex2png-NumberTheory_208717089_-5.gif" alt="$(R,N)\ne1$" class="latex-inline" style="vertical-align: -5px" width="76" height="18">，通常即<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">为偶数的情形，模幂运算可通过将<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">分解为<img src="latex/latex2png-NumberTheory_163420937_-3.gif" alt="$2^d\cdot N_0$" class="latex-inline" style="vertical-align: -3px" width="47" height="17">（<img src="latex/latex2png-NumberTheory_199068652_-3.gif" alt="$N_0$" class="latex-inline" style="vertical-align: -3px" width="19" height="15">为奇数），先对用算法<a class="ref-th" href="NumberTheory.html#al:monredc">3</a>对<img src="latex/latex2png-NumberTheory_199068652_-3.gif" alt="$N_0$" class="latex-inline" style="vertical-align: -3px" width="19" height="15">模幂，再对<img src="latex/latex2png-NumberTheory_132221932_0.gif" alt="$2^d$" class="latex-inline" style="vertical-align: 0px" width="15" height="14">模幂（位操作本身就很快），最后用中国剩余定理<a class="ref-th" href="NumberTheory.html#th:crt">16</a>重构出结果来。


</div>

<div class="remark">
<span class="proof-header">注9<a name=""></a></span><span class="theorem-name"></span>
<span class="cite"><a class="cite" href="NumberTheory.html#ref-6" name="cite-6">[6]</a></span>提出了比Montgomery方法更快的模幂算法，执行效率约能提升30%到50%。


</div>



<h2><a name="sec5" id="sec5"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>幂次检测</h2>




<p>在许多算法中（例如SQUFOF），需要判断一个整数是否是完全平方数（更一般地判断是否为素数幂），如果是的话，还要求出其平方根。对于很大的整数，这些算法都要更有针对性，更高效一些才能满足需要。</p>

<h3><a name="sec6" id="sec6"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>整数开方</h3>

<p class="first">对于整数开方，直接动用浮点数运算显然是低效而且不精确的，但我们可以将经典到Newton迭代法做一个改进使之变得更经济。
<div class="algorithm">
<span class="theorem-header">算法4<a name="al:intsqrt"></a></span><span class="theorem-name">(整数开方)</span>
输入整数<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">，以下算法计算<img src="latex/latex2png-NumberTheory_99897338_-5.gif" alt="$\lfloor\sqrt{n}\rfloor$" class="latex-inline" style="vertical-align: -5px" width="34" height="18">。</p>

<ol>
<li>令<img src="latex/latex2png-NumberTheory_68712104_-3.gif" alt="$x_0=n$" class="latex-inline" style="vertical-align: -3px" width="49" height="11">。</li>
<li>顺次计算<img src="latex/latex2png-NumberTheory_165457562_-16.gif" alt="$x_{k+1}=\left\lfloor\dfrac{x_k+\lfloor{n/x_k\rfloor}}{2}\right\rfloor$" class="latex-inline" style="vertical-align: -16px" width="165" height="40">。</li>
<li>若<img src="latex/latex2png-NumberTheory_203181477_-4.gif" alt="$x_{k+1}\ge x_k$" class="latex-inline" style="vertical-align: -4px" width="73" height="15">，输出<img src="latex/latex2png-NumberTheory_164269036_-2.gif" alt="$x_k$" class="latex-inline" style="vertical-align: -2px" width="16" height="10">，算法终止，否则跳到第二步。</li>
</ol>


</div>
<div class="remark">
<span class="proof-header">注10<a name=""></a></span><span class="theorem-name"></span>
算法中所有运算均为整数运算，没有动用浮点数运算。


</div>
<div class="proof">
<span class="proof-header">证明</span><span class="">(算法的有效性)</span>
由<img src="latex/latex2png-NumberTheory_205228948_.gif" alt="$$\left\lfloor\dfrac{x_{k-1}+\lfloor{n/x_{k-1}\rfloor}}{2}\right\rfloor>\dfrac{x_{k-1}+n/x_{k-1}-1}{2}-\dfrac{1}{2}\ge\sqrt{n}-1,$$" class="latex-display" width="580" height="40">可知对于任意<img src="latex/latex2png-NumberTheory_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">，均有<img src="latex/latex2png-NumberTheory_159668516_-5.gif" alt="$x_k\ge\lfloor\sqrt{n}\rfloor$" class="latex-inline" style="vertical-align: -5px" width="76" height="18">。若<img src="latex/latex2png-NumberTheory_203181477_-4.gif" alt="$x_{k+1}\ge x_k$" class="latex-inline" style="vertical-align: -4px" width="73" height="15">且<img src="latex/latex2png-NumberTheory_159697188_-5.gif" alt="$x_k\ne\lfloor\sqrt{n}\rfloor$" class="latex-inline" style="vertical-align: -5px" width="76" height="18">，则必有<img src="latex/latex2png-NumberTheory_80250395_-5.gif" alt="$x_k\ge\lfloor\sqrt{n}\rfloor+1$" class="latex-inline" style="vertical-align: -5px" width="106" height="18">。于是<img src="latex/latex2png-NumberTheory_122820230_.gif" alt="$$x_{k+1}-x_k=\left\lfloor\dfrac{\lfloor n/x_k\rfloor-x_k}{2}\right\rfloor<\left\lfloor\dfrac{n-x_k^2}{2x_k}\right\rfloor<0,$$" class="latex-display" width="580" height="41">矛盾！从而必有<img src="latex/latex2png-NumberTheory_257399034_-5.gif" alt="$x_k=\lfloor\sqrt{n}\rfloor$" class="latex-inline" style="vertical-align: -5px" width="76" height="18">。
<span class="proof-end">□</span>

</div>


<h3><a name="sec7" id="sec7"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>平方检测</h3>

<p class="first">我们要判断给定的整数<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">是否是一个完全平方数，直接用算法<a class="ref-th" href="NumberTheory.html#al:intsqrt">4</a>计算<img src="latex/latex2png-NumberTheory_135242569_-5.gif" alt="$\lfloor\sqrt{n}\rfloor^2$" class="latex-inline" style="vertical-align: -5px" width="42" height="19">是一个办法，不过我们在这样做之前可以首先排除许多非平方数的情形。以下运用的是简单的事实：如果<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">是一个平方数，那么对任意整数<img src="latex/latex2png-NumberTheory_42300434_0.gif" alt="$k$" class="latex-inline" style="vertical-align: 0px" width="9" height="12">，<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">在<img src="latex/latex2png-NumberTheory_230787247_-5.gif" alt="$\mathbb{Z}/k\mathbb{Z}$" class="latex-inline" style="vertical-align: -5px" width="40" height="18">中都是一个平方数。</p>

<div class="algorithm">
<span class="theorem-header">算法5<a name="al:sqrtest"></a></span><span class="theorem-name">(平方检测)</span>
输入整数<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">，判断其是否为平方数，若是，求之。

<ol>
<li>枚举生成数组<img src="latex/latex2png-NumberTheory_160931078_-4.gif" alt="$q_{64}$" class="latex-inline" style="vertical-align: -4px" width="20" height="12">，满足
<img src="latex/latex2png-NumberTheory_32188038_.gif" alt="
\begin{equation*}
  q_{64}[k]=
  \begin{cases}
    1&\text{若}k\text{为}\mathbb{Z}/64\mathbb{Z}\text{中的平方数}, \\
    0&\text{若}k\text{为}\mathbb{Z}/64\mathbb{Z}\text{中的非平方数}.
  \end{cases}
\end{equation*}" class="latex-display" width="580" height="61">
类似生成另外三个数组<img src="latex/latex2png-NumberTheory_141072657_-4.gif" alt="$q_{63}, q_{65}, q_{11}$" class="latex-inline" style="vertical-align: -4px" width="78" height="12">。</li>
<li>若<img src="latex/latex2png-NumberTheory_67577296_-5.gif" alt="$q_{64}[n\bmod{64}]=0$" class="latex-inline" style="vertical-align: -5px" width="128" height="18">，输出非平方数，算法终止；否则计算<img src="latex/latex2png-NumberTheory_64980969_-5.gif" alt="$r=n\bmod{45045(=63\times65\times11})$" class="latex-inline" style="vertical-align: -5px" width="242" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_67573203_-5.gif" alt="$q_{63}[r\bmod{63}]=0$" class="latex-inline" style="vertical-align: -5px" width="126" height="18">或<img src="latex/latex2png-NumberTheory_67581397_-5.gif" alt="$q_{65}[r\bmod{65}]=0$" class="latex-inline" style="vertical-align: -5px" width="126" height="18">或<img src="latex/latex2png-NumberTheory_67237249_-5.gif" alt="$q_{11}[r\bmod{11}]=0$" class="latex-inline" style="vertical-align: -5px" width="126" height="18">，输出非平方数，算法终止。</li>
<li>用算法<a class="ref-th" href="NumberTheory.html#al:intsqrt">4</a>计算<img src="latex/latex2png-NumberTheory_135242569_-5.gif" alt="$\lfloor\sqrt{n}\rfloor^2$" class="latex-inline" style="vertical-align: -5px" width="42" height="19">，若不等于<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">输出非平方数，否则输出平方根，算法终止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注11<a name=""></a></span><span class="theorem-name"></span>
若<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">非平方数，则算法进行到最后一步的可能性非常小，因为模64，63，65，11的平方数个数分别为12，16，21，6，从而这种情况发生的概率大约仅为为<img src="latex/latex2png-NumberTheory_11609553_.gif" alt="$$\dfrac{12}{64}\cdot\dfrac{16}{63}\cdot\dfrac{21}{65}\cdot\dfrac{6}{11}=\dfrac{6}{715}.$$" class="latex-display" width="580" height="35">我们从上式也可以看出选取四个数64，63，65，11的缘由。


</div>




<h3><a name="sec8" id="sec8"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>素数幂检测</h3>

<p class="first">检测一个整数<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">是否为素数幂<img src="latex/latex2png-NumberTheory_237335572_-4.gif" alt="$p^k$" class="latex-inline" style="vertical-align: -4px" width="16" height="18">有时也会用到。若<img src="latex/latex2png-NumberTheory_31099236_-4.gif" alt="$n=p^k$" class="latex-inline" style="vertical-align: -4px" width="47" height="18">，则由Fermat小定理，对于任意整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">都有<img src="latex/latex2png-NumberTheory_116080045_-5.gif" alt="$p\mid a^p-a$" class="latex-inline" style="vertical-align: -5px" width="68" height="18">，从而<img src="latex/latex2png-NumberTheory_125009330_-5.gif" alt="$p\mid (a^n-a, n)$" class="latex-inline" style="vertical-align: -5px" width="99" height="18">。</p>

<div class="problem">
<span class="proof-header">例1<a name=""></a></span><span class="theorem-name"></span>
取<img src="latex/latex2png-NumberTheory_31099236_-4.gif" alt="$n=p^k$" class="latex-inline" style="vertical-align: -4px" width="47" height="18">，我们计算<img src="latex/latex2png-NumberTheory_49768098_-5.gif" alt="$(a^n-a,n)$" class="latex-inline" style="vertical-align: -5px" width="75" height="18">：

<ol>
<li><img src="latex/latex2png-NumberTheory_152401564_-1.gif" alt="$n=3^3$" class="latex-inline" style="vertical-align: -1px" width="46" height="15">，取<img src="latex/latex2png-NumberTheory_50039788_0.gif" alt="$a=2$" class="latex-inline" style="vertical-align: 0px" width="39" height="11">，则<img src="latex/latex2png-NumberTheory_169287703_-5.gif" alt="$(a^n-a, n)=(2^{27}-2, 27)=(134217726, 27)=3$" class="latex-inline" style="vertical-align: -5px" width="350" height="19">。</li>
<li><img src="latex/latex2png-NumberTheory_185890460_-1.gif" alt="$n=5^2$" class="latex-inline" style="vertical-align: -1px" width="46" height="15">，取<img src="latex/latex2png-NumberTheory_49974252_-1.gif" alt="$a=3$" class="latex-inline" style="vertical-align: -1px" width="39" height="12">，则<img src="latex/latex2png-NumberTheory_8665404_-5.gif" alt="$(a^n-a, n)=(3^{25}-3, 25)=(847288609440, 25)=5$" class="latex-inline" style="vertical-align: -5px" width="375" height="19">。</li>
<li><img src="latex/latex2png-NumberTheory_135820956_0.gif" alt="$n=2^6$" class="latex-inline" style="vertical-align: 0px" width="46" height="14">，取<img src="latex/latex2png-NumberTheory_50039788_0.gif" alt="$a=2$" class="latex-inline" style="vertical-align: 0px" width="39" height="11">，则<img src="latex/latex2png-NumberTheory_57281391_-5.gif" alt="$(a^n-a, n)=(2^{64}-2, 64)=(18446744073709551614, 64)=2$" class="latex-inline" style="vertical-align: -5px" width="441" height="19">。
<span class="example-end">◇</span></li>
</ol>

</div>
但实际上通过试算几个例子可以发现大部分情况下都有<img src="latex/latex2png-NumberTheory_205750301_-5.gif" alt="$(a^n-a, n)=p$" class="latex-inline" style="vertical-align: -5px" width="106" height="18">。这就启发我们得到如下的算法。

<div class="algorithm">
<span class="theorem-header">算法6<a name=""></a></span><span class="theorem-name">(素数幂检测)</span>
输入整数<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">，判断其是否为素数幂，若是，输出素数<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">。

<ol>
<li>取<img src="latex/latex2png-NumberTheory_50039788_0.gif" alt="$a=2$" class="latex-inline" style="vertical-align: 0px" width="39" height="11">。</li>
<li>用算法<a class="ref-th" href="NumberTheory.html#al:monredc">3</a>计算<img src="latex/latex2png-NumberTheory_115569963_0.gif" alt="$b=a^n\bmod{n}$" class="latex-inline" style="vertical-align: 0px" width="98" height="12">并计算<img src="latex/latex2png-NumberTheory_223031582_-5.gif" alt="$p=(b-a, n)$" class="latex-inline" style="vertical-align: -5px" width="97" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_201552916_-4.gif" alt="$p=1$" class="latex-inline" style="vertical-align: -4px" width="38" height="15">，输出非素数幂，算法终止；否则用对<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">进行合性检测（例如Rabin-Miller检测，算法<a class="ref-th-external" href="PrimeTest.html#al:rabin">5</a> ），若<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">为合数，则令<img src="latex/latex2png-NumberTheory_249815515_-2.gif" alt="$a\leftarrow a+1$" class="latex-inline" style="vertical-align: -2px" width="71" height="13">，跳到第二步。</li>
<li>对<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">进行素性检测（例如Lehmer <img src="latex/latex2png-NumberTheory_251431916_0.gif" alt="$N-1$" class="latex-inline" style="vertical-align: 0px" width="42" height="12">检测，定理<a class="ref-th-external" href="PrimeTest.html#th:FermatConverse">1</a>），若<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">不一定为素数，则令<img src="latex/latex2png-NumberTheory_249815515_-2.gif" alt="$a\leftarrow a+1$" class="latex-inline" style="vertical-align: -2px" width="71" height="13">，跳到第二步。</li>
<li><img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">为素数，依次计算<img src="latex/latex2png-NumberTheory_243594377_-4.gif" alt="$p, p^2,\ldots, p^{2^k}$" class="latex-inline" style="vertical-align: -4px" width="90" height="21">直到<img src="latex/latex2png-NumberTheory_196520596_-4.gif" alt="$p^{2^k}>n$" class="latex-inline" style="vertical-align: -4px" width="56" height="21">。

<ul>
<li>若<img src="latex/latex2png-NumberTheory_141128462_-5.gif" alt="$p^{2^{k-1}}\nmid n$" class="latex-inline" style="vertical-align: -5px" width="63" height="22">，输出非素数幂，算法终止；</li>
<li>否则令<img src="latex/latex2png-NumberTheory_61148115_-16.gif" alt="$n\leftarrow\dfrac{n}{p^{2^{k-1}}}$" class="latex-inline" style="vertical-align: -16px" width="76" height="35">，重复第五步，直到<img src="latex/latex2png-NumberTheory_167998484_0.gif" alt="$n=1$" class="latex-inline" style="vertical-align: 0px" width="39" height="11">。</li>
</ul></li>
<li>输出素数<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">，算法终止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注12<a name=""></a></span><span class="theorem-name"></span>
若<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">为素数，第四步的跳转实际上很少发生。


</div>



<h2><a name="sec9" id="sec9"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>最大公因子</h2>



<p>相对于因子分解，求两个整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的最大公因子（Greatest Common Divisor，GCD）<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">要快上许多，甚至往往超出我们的想象。用普通的个人电脑在2秒以内计算两个十万位的整数的最大公因子也不是一件难事。</p>

<p>据<span class="cite"><a class="cite" href="NumberTheory.html#ref-7" name="cite-7">[7]</a></span>的数据，一个典型的代数运算（例如Groebner基）通常要花上一半以上时间用来计算某两个大整数的最大公因子，或许正因为最大公因子在计算机代数系统中的重要性，对它的研究才能如此深入。</p>

<p>为了避免混淆，在本节中始终用<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">代表最大公因子，而出现在算法的描述中的<img src="latex/latex2png-NumberTheory_63675085_-5.gif" alt="$(a, b)$" class="latex-inline" style="vertical-align: -5px" width="34" height="18">则仅仅代表二元有序数对。</p>

<h3><a name="sec10" id="sec10"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>Euclid算法</h3>

<p class="first">最平凡的求整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的GCD的办法是直接将两数分解，但这实在是太慢了，只在<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">都小于100或者已知其中之一为素数的时候才可能有些用处。早在古希腊时代人们就已经知道如何进行更高效的计算了，经典的Euclid算法虽最古老却也是最本质最有效的方法之一。</p>

<div class="algorithm">
<span class="theorem-header">算法7<a name=""></a></span><span class="theorem-name">(Euclid)</span>
输入正整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，计算<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">。

<ol>
<li>若<img src="latex/latex2png-NumberTheory_33393644_-1.gif" alt="$b=0$" class="latex-inline" style="vertical-align: -1px" width="37" height="13">，则输出<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，算法终止。</li>
<li>令<img src="latex/latex2png-NumberTheory_256531822_-5.gif" alt="$(a, b)\leftarrow (b, a\bmod{b})$" class="latex-inline" style="vertical-align: -5px" width="144" height="18">，跳到第一步。</li>
</ol>


</div>

<p>Knuth<span class="cite"><a class="cite" href="NumberTheory.html#ref-3" name="cite-3">[3]</a></span>通过一系列分析给出了Euclid算法终止前除法步数的精确估计。
<div class="theorem">
<span class="theorem-header">定理1<a name="al:euclid"></a></span><span class="theorem-name">(Euclid算法的步数)</span>
设<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">随机分布于<img src="latex/latex2png-NumberTheory_88055285_-5.gif" alt="$[1, N]$" class="latex-inline" style="vertical-align: -5px" width="37" height="18">，则</p>

<ol>
<li>Euclid算法的平均步数为<img src="latex/latex2png-NumberTheory_238757300_-11.gif" alt="$\dfrac{12\ln2}{\pi^2}\ln N+O(1)\approx0.843\ln N+O(1)$" class="latex-inline" style="vertical-align: -11px" width="282" height="34">。</li>
<li>Euclid算法在最坏情况下的步数至多为<img src="latex/latex2png-NumberTheory_125574735_-7.gif" alt="$\lfloor\log_\phi(3-\phi)N\rfloor\approx2.078\ln N+0.6723$" class="latex-inline" style="vertical-align: -7px" width="269" height="20">，其中<img src="latex/latex2png-NumberTheory_69970608_-6.gif" alt="$\phi=\frac{1+\sqrt{5}}{2}$" class="latex-inline" style="vertical-align: -6px" width="69" height="23">。</li>
</ol>


</div>



<h3><a name="sec11" id="sec11"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>Lehmer加速算法</h3>
由定理<a class="ref-th" href="NumberTheory.html#al:euclid">1</a>可见GCD可以在多项式时间内求出，但Euclid算法中每一步的大整数试除还是相当耗费时间，Lehmer针对这一点给出了加速的方法，其基本想法是试除的商<img src="latex/latex2png-NumberTheory_183627189_-11.gif" alt="$\left\lfloor\dfrac{a}{b}\right\rfloor$" class="latex-inline" style="vertical-align: -11px" width="24" height="30">很大程度上只与<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的前若干位有关，从而可以用单精度的运算代替高精度的大整数试除。

<div class="problem">
<span class="proof-header">例2<a name=""></a></span><span class="theorem-name"></span>
我们想要计算<img src="latex/latex2png-NumberTheory_200914007_-5.gif" alt="$\gcd(a, b)=\gcd(27182818, 10000000)$" class="latex-inline" style="vertical-align: -5px" width="259" height="18">，假设计算机的字长为4个十进制数字，令<img src="latex/latex2png-NumberTheory_30678324_-1.gif" alt="$\hat{a}=2718$" class="latex-inline" style="vertical-align: -1px" width="63" height="13">，<img src="latex/latex2png-NumberTheory_118744012_-1.gif" alt="$\hat{b}=1000$" class="latex-inline" style="vertical-align: -1px" width="61" height="17">，对<img src="latex/latex2png-NumberTheory_176402984_-2.gif" alt="$\hat{a}+1$" class="latex-inline" style="vertical-align: -2px" width="36" height="14">，<img src="latex/latex2png-NumberTheory_151382960_0.gif" alt="$\hat{b}$" class="latex-inline" style="vertical-align: 0px" width="7" height="16">进行Euclid算法的试商结果很可能与<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">进行的结果是一致的，如下表。

<table class="muse-table" border="2" cellpadding="5">
  <thead>
    <tr>
      <th><img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8"></th>
      <th><img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12"></th>
      <th><img src="latex/latex2png-NumberTheory_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12"></th>
      <th><img src="latex/latex2png-NumberTheory_176402984_-2.gif" alt="$\hat{a}+1$" class="latex-inline" style="vertical-align: -2px" width="36" height="14"></th>
      <th><img src="latex/latex2png-NumberTheory_151382960_0.gif" alt="$\hat{b}$" class="latex-inline" style="vertical-align: 0px" width="7" height="16"></th>
      <th><img src="latex/latex2png-NumberTheory_135654320_-4.gif" alt="$\hat{q}$" class="latex-inline" style="vertical-align: -4px" width="8" height="16"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>27182818</td>
      <td>10000000</td>
      <td>2</td>
      <td>2719</td>
      <td>1000</td>
      <td>2</td>
    </tr>
    <tr>
      <td>10000000</td>
      <td>7182818</td>
      <td>1</td>
      <td>1000</td>
      <td>719</td>
      <td>1</td>
    </tr>
    <tr>
      <td>7182818</td>
      <td>2817182</td>
      <td>2</td>
      <td>719</td>
      <td>281</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2817182</td>
      <td>1548454</td>
      <td>1</td>
      <td>281</td>
      <td>157</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1548454</td>
      <td>1268728</td>
      <td>1</td>
      <td>157</td>
      <td>124</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1268728</td>
      <td>279726</td>
      <td>1</td>
      <td>124</td>
      <td>33</td>
      <td>3</td>
    </tr>
  </tbody>
</table>


<p>我们看到直到第6步试除，<img src="latex/latex2png-NumberTheory_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">与<img src="latex/latex2png-NumberTheory_135654320_-4.gif" alt="$\hat{q}$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">才不相等，因此可以利用<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">与<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的前若干位来快速求得试除的商。一个存在问题是如何判断试商的正确性？解决方法是可以同时求另一组<img src="latex/latex2png-NumberTheory_210576999_-5.gif" alt="$\gcd(\hat{a}, \hat{b}+1)=\gcd(2718, 1001)$" class="latex-inline" style="vertical-align: -5px" width="221" height="21">的试商。</p>

<table class="muse-table" border="2" cellpadding="5">
  <thead>
    <tr>
      <th><img src="latex/latex2png-NumberTheory_176402984_-2.gif" alt="$\hat{a}+1$" class="latex-inline" style="vertical-align: -2px" width="36" height="14"></th>
      <th><img src="latex/latex2png-NumberTheory_151382960_0.gif" alt="$\hat{b}$" class="latex-inline" style="vertical-align: 0px" width="7" height="16"></th>
      <th><img src="latex/latex2png-NumberTheory_135654320_-4.gif" alt="$\hat{q}$" class="latex-inline" style="vertical-align: -4px" width="8" height="16"></th>
      <th><img src="latex/latex2png-NumberTheory_152431536_0.gif" alt="$\hat{a}$" class="latex-inline" style="vertical-align: 0px" width="8" height="12"></th>
      <th><img src="latex/latex2png-NumberTheory_92032472_-2.gif" alt="$\hat{b}+1$" class="latex-inline" style="vertical-align: -2px" width="34" height="18"></th>
      <th><img src="latex/latex2png-NumberTheory_135654320_-4.gif" alt="$\hat{q}$" class="latex-inline" style="vertical-align: -4px" width="8" height="16"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2719</td>
      <td>1000</td>
      <td>2</td>
      <td>2178</td>
      <td>1001</td>
      <td>2</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>719</td>
      <td>1</td>
      <td>1001</td>
      <td>716</td>
      <td>1</td>
    </tr>
    <tr>
      <td>719</td>
      <td>281</td>
      <td>2</td>
      <td>716</td>
      <td>285</td>
      <td>2</td>
    </tr>
    <tr>
      <td>281</td>
      <td>157</td>
      <td>1</td>
      <td>285</td>
      <td>146</td>
      <td>1</td>
    </tr>
    <tr>
      <td>157</td>
      <td>124</td>
      <td>1</td>
      <td>146</td>
      <td>139</td>
      <td>1</td>
    </tr>
    <tr>
      <td>124</td>
      <td>33</td>
      <td>3</td>
      <td>139</td>
      <td>7</td>
      <td>19</td>
    </tr>
  </tbody>
</table>


<p>显然若两组求得的商相同，即可判定试商是准确无误的。上表也验证了这一点。
<span class="example-end">◇</span></p>

</div>

<div class="algorithm">
<span class="theorem-header">算法8<a name=""></a></span><span class="theorem-name">(Lehmer加速算法)</span>
输入正整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，且<img src="latex/latex2png-NumberTheory_48466924_-1.gif" alt="$a>b$" class="latex-inline" style="vertical-align: -1px" width="38" height="13">，计算<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">。设<img src="latex/latex2png-NumberTheory_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="18" height="12">为单精度整数的上限（例如<img src="latex/latex2png-NumberTheory_108501909_0.gif" alt="$2^{32}$" class="latex-inline" style="vertical-align: 0px" width="21" height="14">），以下<img src="latex/latex2png-NumberTheory_152431536_0.gif" alt="$\hat{a}$" class="latex-inline" style="vertical-align: 0px" width="8" height="12">，<img src="latex/latex2png-NumberTheory_151382960_0.gif" alt="$\hat{b}$" class="latex-inline" style="vertical-align: 0px" width="7" height="16">，<img src="latex/latex2png-NumberTheory_42169362_0.gif" alt="$A$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">，<img src="latex/latex2png-NumberTheory_42234898_0.gif" alt="$B$" class="latex-inline" style="vertical-align: 0px" width="13" height="12">，<img src="latex/latex2png-NumberTheory_139621394_-1.gif" alt="$C $" class="latex-inline" style="vertical-align: -1px" width="12" height="13">，<img src="latex/latex2png-NumberTheory_42365970_0.gif" alt="$D$" class="latex-inline" style="vertical-align: 0px" width="13" height="12">均为单精度整数（即<img src="latex/latex2png-NumberTheory_135230482_-1.gif" alt="$<M$" class="latex-inline" style="vertical-align: -1px" width="35" height="13">）。

<ol>
<li>若<img src="latex/latex2png-NumberTheory_32541676_-1.gif" alt="$b<M$" class="latex-inline" style="vertical-align: -1px" width="47" height="13">，直接用Euclid算法计算输出<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">，算法终止；若<img src="latex/latex2png-NumberTheory_256875538_-3.gif" alt="$b\ge M$" class="latex-inline" style="vertical-align: -3px" width="47" height="15">，记<img src="latex/latex2png-NumberTheory_152431536_0.gif" alt="$\hat{a}$" class="latex-inline" style="vertical-align: 0px" width="8" height="12">，<img src="latex/latex2png-NumberTheory_151382960_0.gif" alt="$\hat{b}$" class="latex-inline" style="vertical-align: 0px" width="7" height="16">为<img src="latex/latex2png-NumberTheory_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="18" height="12">进制下<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的最高位，<img src="latex/latex2png-NumberTheory_13443603_-16.gif" alt="$\displaystyle\left({A \atop B}{C \atop D}\right)\leftarrow\left({1 \atop 0}{0 \atop 1}\right)$" class="latex-inline" style="vertical-align: -16px" width="129" height="40">。</li>
<li>若<img src="latex/latex2png-NumberTheory_135884459_-4.gif" alt="$\hat{b}+C\ne0$" class="latex-inline" style="vertical-align: -4px" width="71" height="20">，<img src="latex/latex2png-NumberTheory_135884460_-4.gif" alt="$\hat{b}+D\ne0$" class="latex-inline" style="vertical-align: -4px" width="72" height="20">，则令<img src="latex/latex2png-NumberTheory_235393995_-16.gif" alt="$q\leftarrow \left\lfloor\dfrac{\hat{a}+A}{\hat{b}+C}\right\rfloor$" class="latex-inline" style="vertical-align: -16px" width="95" height="40">，否则跳到跳到第四步。若还有<img src="latex/latex2png-NumberTheory_228366472_-16.gif" alt="$q=\left\lfloor\dfrac{\hat{a}+B}{\hat{b}+D}\right\rfloor$" class="latex-inline" style="vertical-align: -16px" width="92" height="40">，则跳到第三步，否则跳到第四步。</li>
<li>令<img src="latex/latex2png-NumberTheory_197719150_-16.gif" alt="$\displaystyle\left({A \atop B}{C \atop D}\right)\leftarrow\left({A \atop B}{C \atop D}\right)\left({0 \atop 1}{1 \atop -q}\right)$" class="latex-inline" style="vertical-align: -16px" width="204" height="40">，<img src="latex/latex2png-NumberTheory_102683129_-16.gif" alt="$\displaystyle(\hat{a}, \hat{b})\leftarrow(\hat{a}, \hat{b})\left({0 \atop 1}{1 \atop -q}\right)$" class="latex-inline" style="vertical-align: -16px" width="158" height="40">，跳到第二步。</li>
<li>若<img src="latex/latex2png-NumberTheory_167933594_-4.gif" alt="$B\ne0$" class="latex-inline" style="vertical-align: -4px" width="44" height="16">，令<img src="latex/latex2png-NumberTheory_76184494_-16.gif" alt="$\displaystyle(a, b)\leftarrow(a, b)\left({A \atop B}{C \atop D}\right)$" class="latex-inline" style="vertical-align: -16px" width="157" height="40">，跳到第一步；否则用高精度运算直接求出<img src="latex/latex2png-NumberTheory_181842353_-5.gif" alt="$(a, b)\leftarrow(b, a\bmod{b})$" class="latex-inline" style="vertical-align: -5px" width="144" height="18">，跳到第一步。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注13<a name=""></a></span><span class="theorem-name"></span>
Lehmer的加速算法虽然步数和普通的Euclid算法是一样的，但除了第四步后一种情形外，都只需要单精度运算或单精度与高精度数的乘法，这起到了“加速”的作用。


</div>

<div class="remark">
<span class="proof-header">注14<a name=""></a></span><span class="theorem-name"></span>
注意算法的陈述中忽略了一种特殊情形，即当<img src="latex/latex2png-NumberTheory_205555663_-4.gif" alt="$\hat{a}=M-1, A=1$" class="latex-inline" style="vertical-align: -4px" width="126" height="16">或<img src="latex/latex2png-NumberTheory_138446799_-4.gif" alt="$\hat{b}=M-1, D=1$" class="latex-inline" style="vertical-align: -4px" width="127" height="20">时，计算可能超出单精度的范围，可以将<img src="latex/latex2png-NumberTheory_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="18" height="12">取为略小与单精度整数上限即可。


</div>


<h3><a name="sec12" id="sec12"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>二进方法（Binary GCD）</h3>

<p class="first">另一种被称为二进方法（Binary GCD）方法在实践中也很有用，其主要想法是用减法和一位来代替代价较大的试除。尽管需要的运算步数增多了，但由于减法和位移运算的简单性节省出的是时间还是很可观的。</p>

<p>下面的定理精确的叙述了只用减法的合理性<span class="cite"><a class="cite" href="NumberTheory.html#ref-3" name="cite-3">[3]</a></span>。</p>

<div class="theorem">
<span class="theorem-header">定理2<a name="th:qdist"></a></span><span class="theorem-name"></span>
设<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">固定，<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">随机分布。对<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">施行Euclid算法，其中间步骤试商为<img src="latex/latex2png-NumberTheory_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">的概率记为<img src="latex/latex2png-NumberTheory_213622132_-5.gif" alt="$P_b(q)$" class="latex-inline" style="vertical-align: -5px" width="37" height="18">，则有<img src="latex/latex2png-NumberTheory_230392700_.gif" alt="$$\lim_{b\rightarrow\infty}P_b(q)=\log\frac{(q+1)^2}{(q+1)^2-1}.$$" class="latex-display" width="580" height="42">


</div>

<div class="remark">
<span class="proof-header">注15<a name=""></a></span><span class="theorem-name"></span>
由定理<a class="ref-th" href="NumberTheory.html#th:qdist">2</a>，粗略地估计试商值为1的概率为<img src="latex/latex2png-NumberTheory_101275392_-7.gif" alt="$\log\frac{4}{3}\approx0.415$" class="latex-inline" style="vertical-align: -7px" width="94" height="22">，试商值为2的概率为<img src="latex/latex2png-NumberTheory_57235280_-7.gif" alt="$\log\frac{9}{8}\approx0.170$" class="latex-inline" style="vertical-align: -7px" width="94" height="22">。可见大部分情况下除数和被除数都是比较接近的，可以用减法来替代试除。


</div>

<div class="algorithm">
<span class="theorem-header">算法9<a name=""></a></span><span class="theorem-name">(Binary GCD)</span>
输入正整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，且<img src="latex/latex2png-NumberTheory_48466924_-1.gif" alt="$a>b$" class="latex-inline" style="vertical-align: -1px" width="38" height="13">，计算<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">。

<ol>
<li>用高精度直接计算<img src="latex/latex2png-NumberTheory_256531822_-5.gif" alt="$(a, b)\leftarrow (b, a\bmod{b})$" class="latex-inline" style="vertical-align: -5px" width="144" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_33393644_-1.gif" alt="$b=0$" class="latex-inline" style="vertical-align: -1px" width="37" height="13">，输出<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，算法终止；否则设<img src="latex/latex2png-NumberTheory_27229241_-3.gif" alt="$a=2^m a_0$" class="latex-inline" style="vertical-align: -3px" width="67" height="14">，<img src="latex/latex2png-NumberTheory_4871316_-3.gif" alt="$b=2^nb_0$" class="latex-inline" style="vertical-align: -3px" width="60" height="15">，<img src="latex/latex2png-NumberTheory_14519276_-3.gif" alt="$a_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="11">，<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">为奇数。设<img src="latex/latex2png-NumberTheory_55756783_-5.gif" alt="$k=\min\{m,n\}$" class="latex-inline" style="vertical-align: -5px" width="106" height="18">，通过位操作计算<img src="latex/latex2png-NumberTheory_24988560_-5.gif" alt="$(a, b)\leftarrow(a\cdot2^{-m}, b\cdot2^{-n})$" class="latex-inline" style="vertical-align: -5px" width="179" height="18">。</li>
<li>令<img src="latex/latex2png-NumberTheory_252507355_-1.gif" alt="$t\leftarrow a-b$" class="latex-inline" style="vertical-align: -1px" width="68" height="13">，若<img src="latex/latex2png-NumberTheory_268274668_-1.gif" alt="$t=0$" class="latex-inline" style="vertical-align: -1px" width="36" height="12">，输出<img src="latex/latex2png-NumberTheory_89885923_0.gif" alt="$a\cdot2^k$" class="latex-inline" style="vertical-align: 0px" width="36" height="14">，算法终止。</li>
<li>设<img src="latex/latex2png-NumberTheory_38499477_-3.gif" alt="$t=2^st_0$" class="latex-inline" style="vertical-align: -3px" width="56" height="14">，<img src="latex/latex2png-NumberTheory_232623084_-3.gif" alt="$t_0$" class="latex-inline" style="vertical-align: -3px" width="12" height="14">为奇数，若<img src="latex/latex2png-NumberTheory_68318884_-3.gif" alt="$t_0>0$" class="latex-inline" style="vertical-align: -3px" width="44" height="14">，令<img src="latex/latex2png-NumberTheory_86172123_-3.gif" alt="$a\leftarrow t_0$" class="latex-inline" style="vertical-align: -3px" width="47" height="14">，否则令<img src="latex/latex2png-NumberTheory_182263076_-3.gif" alt="$b\leftarrow-t_0$" class="latex-inline" style="vertical-align: -3px" width="58" height="15">，跳到第三步。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注16<a name=""></a></span><span class="theorem-name"></span>
由于初始的<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">和<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">可能相差很大，不适宜反复做减法，因此还是需要第一步的高精度试除。


</div>

<div class="remark">
<span class="proof-header">注17<a name=""></a></span><span class="theorem-name"></span>
Gosper提出了一个将Binary GCD想法与Lehmer加速算法结合起来的方法，参见<span class="cite"><a class="cite" href="NumberTheory.html#ref-3" name="cite-3">[3]</a></span>。


</div>


<h3><a name="sec13" id="sec13"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>扩展Euclid算法</h3>

<p class="first">在很多问题中（例如求模<img src="latex/latex2png-NumberTheory_43021330_0.gif" alt="$N$" class="latex-inline" style="vertical-align: 0px" width="15" height="12">的逆）不仅需要知道<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">，还要求出Bezout等式中的系数<img src="latex/latex2png-NumberTheory_150107154_0.gif" alt="$u $" class="latex-inline" style="vertical-align: 0px" width="9" height="8">，<img src="latex/latex2png-NumberTheory_151155730_0.gif" alt="$v $" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，使得成立<img src="latex/latex2png-NumberTheory_153583935_.gif" alt="$$ua+vb=d(:=\gcd(a, b)).$$" class="latex-display" width="580" height="18">这样的算法称为扩展Euclid算法。在原始的Euclid算法过程中保留所有的商和余数即可倒推出<img src="latex/latex2png-NumberTheory_150107154_0.gif" alt="$u $" class="latex-inline" style="vertical-align: 0px" width="9" height="8">和<img src="latex/latex2png-NumberTheory_151155730_0.gif" alt="$v $" class="latex-inline" style="vertical-align: 0px" width="8" height="8">来，不过这样做需要较大的空间开销。可以在计算过程中保留类似于Lehmer加速算法中的矩阵<img src="latex/latex2png-NumberTheory_130432757_-16.gif" alt="$\displaystyle\left({A \atop B}{C \atop D}\right)$" class="latex-inline" style="vertical-align: -16px" width="54" height="40">，矩阵的列实际上就是新操作数作为<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">线性组合的系数。</p>

<p>Lehmer加速算法本身就就具有了“扩展”的特性，但Binary GCD的“扩展”能力表面上看来就没有那么直接了。不过仔细追踪算法的行进过程，还是能够求出系数<img src="latex/latex2png-NumberTheory_150107154_0.gif" alt="$u $" class="latex-inline" style="vertical-align: 0px" width="9" height="8">，<img src="latex/latex2png-NumberTheory_151155730_0.gif" alt="$v $" class="latex-inline" style="vertical-align: 0px" width="8" height="8">来的。</p>

<div class="algorithm">
<span class="theorem-header">算法10<a name=""></a></span><span class="theorem-name">(扩展Binary GCD)</span>
输入正整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，且<img src="latex/latex2png-NumberTheory_48466924_-1.gif" alt="$a>b$" class="latex-inline" style="vertical-align: -1px" width="38" height="13">，计算三元组<img src="latex/latex2png-NumberTheory_106459746_-5.gif" alt="$(u, v, d)$" class="latex-inline" style="vertical-align: -5px" width="52" height="18">。

<ol>
<li>用高精度直接计算<img src="latex/latex2png-NumberTheory_256531822_-5.gif" alt="$(a, b)\leftarrow (b, a\bmod{b})$" class="latex-inline" style="vertical-align: -5px" width="144" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_33393644_-1.gif" alt="$b=0$" class="latex-inline" style="vertical-align: -1px" width="37" height="13">，输出<img src="latex/latex2png-NumberTheory_104243781_-5.gif" alt="$(0, 1, b)$" class="latex-inline" style="vertical-align: -5px" width="49" height="18">，算法终止；否则设<img src="latex/latex2png-NumberTheory_27229241_-3.gif" alt="$a=2^m a_0$" class="latex-inline" style="vertical-align: -3px" width="67" height="14">，<img src="latex/latex2png-NumberTheory_4871316_-3.gif" alt="$b=2^nb_0$" class="latex-inline" style="vertical-align: -3px" width="60" height="15">，<img src="latex/latex2png-NumberTheory_14519276_-3.gif" alt="$a_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="11">，<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">为奇数。设<img src="latex/latex2png-NumberTheory_55756783_-5.gif" alt="$k=\min\{m,n\}$" class="latex-inline" style="vertical-align: -5px" width="106" height="18">，通过位操作计算<img src="latex/latex2png-NumberTheory_75451280_-5.gif" alt="$(a, b)\leftarrow(a\cdot2^{-k}, b\cdot2^{-k})$" class="latex-inline" style="vertical-align: -5px" width="173" height="19">。</li>
<li>令<img src="latex/latex2png-NumberTheory_177649620_-5.gif" alt="$(u_1, v_1, d_1)\leftarrow(1, 0 ,a)$" class="latex-inline" style="vertical-align: -5px" width="153" height="18">，<img src="latex/latex2png-NumberTheory_36737379_-5.gif" alt="$(u_2, v_2, d_2)\leftarrow(b, 1-a, b)$" class="latex-inline" style="vertical-align: -5px" width="179" height="18">。若<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">为奇数，令<img src="latex/latex2png-NumberTheory_244222869_-5.gif" alt="$(u_0, v_0, d_0)\leftarrow(0, -1, -b)$" class="latex-inline" style="vertical-align: -5px" width="177" height="18">，跳到第五步；否则令<img src="latex/latex2png-NumberTheory_156845868_-5.gif" alt="$(u_0, v_0, d_0)\leftarrow(1, 0, a)$" class="latex-inline" style="vertical-align: -5px" width="153" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_196368832_-4.gif" alt="$u_0, v_0$" class="latex-inline" style="vertical-align: -4px" width="38" height="12">均为偶数，令<img src="latex/latex2png-NumberTheory_99032905_-5.gif" alt="$(u_0, v_0, d_0)\leftarrow(u_0, v_0, d_0)/2$" class="latex-inline" style="vertical-align: -5px" width="193" height="18">；否则令<img src="latex/latex2png-NumberTheory_163156952_-5.gif" alt="$(u_0, v_0, d_0)\leftarrow(u_0+b, v_0-a, d_0)/2$" class="latex-inline" style="vertical-align: -5px" width="249" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_35812372_-3.gif" alt="$d_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="15">为偶数，跳到第四步。</li>
<li>若<img src="latex/latex2png-NumberTheory_68318868_-3.gif" alt="$d_0>0$" class="latex-inline" style="vertical-align: -3px" width="46" height="15">，令<img src="latex/latex2png-NumberTheory_121289026_-5.gif" alt="$(u_1, v_1, d_1)\leftarrow(u_0, v_0, d_0)$" class="latex-inline" style="vertical-align: -5px" width="176" height="18">；否则令<img src="latex/latex2png-NumberTheory_213430903_-5.gif" alt="$(u_2, v_2, d_2)\leftarrow(b-u_0,-a-v_0,-d_0)$" class="latex-inline" style="vertical-align: -5px" width="258" height="18">。</li>
<li>令<img src="latex/latex2png-NumberTheory_57892930_-5.gif" alt="$(u_0, v_0, d_0)\leftarrow(u_1-u_2,v_1-v_2,d_1-d_2)$" class="latex-inline" style="vertical-align: -5px" width="285" height="18">，若<img src="latex/latex2png-NumberTheory_134547256_-3.gif" alt="$u_0\le0$" class="latex-inline" style="vertical-align: -3px" width="47" height="14">，令<img src="latex/latex2png-NumberTheory_118682901_-5.gif" alt="$(u_0,v_0)\leftarrow(u_0+b,v_0-a)$" class="latex-inline" style="vertical-align: -5px" width="186" height="18">。若<img src="latex/latex2png-NumberTheory_67270292_-3.gif" alt="$d_0=0$" class="latex-inline" style="vertical-align: -3px" width="46" height="15">，输出<img src="latex/latex2png-NumberTheory_150165122_-5.gif" alt="$(u_1,v_1,d_1\cdot2^k)$" class="latex-inline" style="vertical-align: -5px" width="102" height="19">，算法终止；否则跳到第四步。</li>
</ol>


</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法的有效性)</span>
可以仔细验证每一步后都满足<img src="latex/latex2png-NumberTheory_108864727_-4.gif" alt="$0\le u_1,u_2,u_0\le b$" class="latex-inline" style="vertical-align: -4px" width="125" height="16">，<img src="latex/latex2png-NumberTheory_212262605_-4.gif" alt="$-a\le v_1,v_2,v_0\le0$" class="latex-inline" style="vertical-align: -4px" width="134" height="15">，<img src="latex/latex2png-NumberTheory_108762754_-3.gif" alt="$0<d_1\le a$" class="latex-inline" style="vertical-align: -3px" width="77" height="15">，<img src="latex/latex2png-NumberTheory_108828306_-3.gif" alt="$0<d_2\le b$" class="latex-inline" style="vertical-align: -3px" width="76" height="15">，且满足<img src="latex/latex2png-NumberTheory_238697091_-2.gif" alt="$u_i a+v_i b=d_i$" class="latex-inline" style="vertical-align: -2px" width="101" height="14">，对<img src="latex/latex2png-NumberTheory_256215051_-4.gif" alt="$i=1, 2, 3$" class="latex-inline" style="vertical-align: -4px" width="67" height="16">。算法的终止性是明显的。
<span class="proof-end">□</span>

</div>

<div class="remark">
<span class="proof-header">注18<a name=""></a></span><span class="theorem-name"></span>
与原始的Binary GCD有区别的是第四步，这是为了保证系数也能除以二而做的微小改动。


</div>


<h3><a name="sec14" id="sec14"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>dmod与bmod</h3>

<p class="first">首先我们引进某种程度上相当于<img src="latex/latex2png-NumberTheory_162428593_0.gif" alt="$\bmod$" class="latex-inline" style="vertical-align: 0px" width="32" height="12">的运算dmod（digit mod）和bmod（bit mod）。</p>

<div class="definition">
<span class="theorem-header">定义2<a name=""></a></span><span class="theorem-name">(dmod和bmod)</span>
设<img src="latex/latex2png-NumberTheory_33257137_-4.gif" alt="$\beta$" class="latex-inline" style="vertical-align: -4px" width="10" height="16">为一个进制的基，正整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">,<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，满足<img src="latex/latex2png-NumberTheory_48466924_-1.gif" alt="$a>b$" class="latex-inline" style="vertical-align: -1px" width="38" height="13">，<img src="latex/latex2png-NumberTheory_147329632_-5.gif" alt="$\gcd(a,\beta)=1$" class="latex-inline" style="vertical-align: -5px" width="93" height="18">，<img src="latex/latex2png-NumberTheory_148378208_-5.gif" alt="$\gcd(b,\beta)=1$" class="latex-inline" style="vertical-align: -5px" width="92" height="18">，<img src="latex/latex2png-NumberTheory_73429553_-5.gif" alt="$l_\beta(a)$" class="latex-inline" style="vertical-align: -5px" width="34" height="18">表示<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">在<img src="latex/latex2png-NumberTheory_33257137_-4.gif" alt="$\beta$" class="latex-inline" style="vertical-align: -4px" width="10" height="16">-进制表示下的位数，记<img src="latex/latex2png-NumberTheory_198874079_-5.gif" alt="$\delta=l_\beta(a)-l_\beta(b)+1$" class="latex-inline" style="vertical-align: -5px" width="147" height="18">。定义<img src="latex/latex2png-NumberTheory_93895057_.gif" alt="$$a \dmod{\beta} b:=\frac{|a-(ab^{-1}\bmod \beta^\delta)b|}{\beta^\delta}.$$" class="latex-display" width="580" height="42">

<p>当<img src="latex/latex2png-NumberTheory_49867789_-4.gif" alt="$\beta=2$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">时（最常用的情形），简记为<img src="latex/latex2png-NumberTheory_262799847_.gif" alt="$$a \bitmod b:=a \dmod{2}b.$$" class="latex-display" width="580" height="14"></p>


</div>

<div class="remark">
<span class="proof-header">注19<a name=""></a></span><span class="theorem-name"></span>
由于<img src="latex/latex2png-NumberTheory_237858494_-5.gif" alt="$a-(ab^{-1}\bmod\beta^\delta)b\equiv a-a\equiv0\pmod{\beta^\delta}$" class="latex-inline" style="vertical-align: -5px" width="306" height="20">，故dmod和bmod是可以定义好的。


</div>

<div class="problem">
<span class="proof-header">例3<a name=""></a></span><span class="theorem-name"></span>
设<img src="latex/latex2png-NumberTheory_81264426_-5.gif" alt="$a=155=(10011011)_2$" class="latex-inline" style="vertical-align: -5px" width="162" height="18">，<img src="latex/latex2png-NumberTheory_62139092_-5.gif" alt="$b=15=(1111)_2$" class="latex-inline" style="vertical-align: -5px" width="119" height="18">，则<img src="latex/latex2png-NumberTheory_46983587_-5.gif" alt="$l_2(a)=8$" class="latex-inline" style="vertical-align: -5px" width="64" height="18">，<img src="latex/latex2png-NumberTheory_221189725_-5.gif" alt="$l_2(b)=4$" class="latex-inline" style="vertical-align: -5px" width="63" height="18">，<img src="latex/latex2png-NumberTheory_241648765_-1.gif" alt="$2^\delta=2^{l_2(a)-l_2(b)+1}=32$" class="latex-inline" style="vertical-align: -1px" width="167" height="16">，<img src="latex/latex2png-NumberTheory_33531663_-5.gif" alt="$15^{-1}\equiv15\pmod{32}$" class="latex-inline" style="vertical-align: -5px" width="144" height="19">。从而
<img src="latex/latex2png-NumberTheory_144198590_.gif" alt="
\begin{align*}
  155 \bitmod 15 &=\frac{|155-(155\cdot15 \bmod{32})\cdot15|}{32} \\
  &=\frac{|155-21\cdot15|}{32}=5.
\end{align*}
" class="latex-display" width="580" height="78">
恰巧有<img src="latex/latex2png-NumberTheory_139629173_-5.gif" alt="$\gcd(155, 15)=5$" class="latex-inline" style="vertical-align: -5px" width="117" height="18">。
<span class="example-end">◇</span>

</div>

<p>可以直接验证<img src="latex/latex2png-NumberTheory_31620214_-5.gif" alt="$\gcd(a \dmod{\beta} b, b)=\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="209" height="18">，而且<img src="latex/latex2png-NumberTheory_21982060_-5.gif" alt="$a \dmod{\beta} b<b$" class="latex-inline" style="vertical-align: -5px" width="104" height="17">，因此新定义的运算的确在某种程度上相当于mod。而且我们可以避免试除，只用减法和位操作来计算出<img src="latex/latex2png-NumberTheory_161241630_0.gif" alt="$a \bitmod b$" class="latex-inline" style="vertical-align: 0px" width="66" height="12">。最关键的是如何快速计算<img src="latex/latex2png-NumberTheory_220125358_0.gif" alt="$m=ab^{-1}\bmod2^\delta$" class="latex-inline" style="vertical-align: 0px" width="126" height="15">，接下来的算法只用减法和位操作解决了这个问题，想法类似于待定系数法求解<img src="latex/latex2png-NumberTheory_157660862_-5.gif" alt="$am\equiv b
\pmod{2^\delta}$" class="latex-inline" style="vertical-align: -5px" width="124" height="20">，从低到高将<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">的二进表达依次求出。</p>

<div class="algorithm">
<span class="theorem-header">算法11<a name="al:abinv"></a></span><span class="theorem-name">(计算<img src="latex/latex2png-NumberTheory_220135703_0.gif" alt="$ab^{-1}\bmod2^\delta$" class="latex-inline" style="vertical-align: 0px" width="89" height="15">)</span>
输入正奇数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，计算<img src="latex/latex2png-NumberTheory_220135703_0.gif" alt="$ab^{-1}\bmod2^\delta$" class="latex-inline" style="vertical-align: 0px" width="89" height="15">。

<ol>
<li>令<img src="latex/latex2png-NumberTheory_156136578_-1.gif" alt="$d\leftarrow a$" class="latex-inline" style="vertical-align: -1px" width="42" height="13">，<img src="latex/latex2png-NumberTheory_56384487_-1.gif" alt="$m\leftarrow0$" class="latex-inline" style="vertical-align: -1px" width="48" height="12">。</li>
<li>重复以下步骤（<img src="latex/latex2png-NumberTheory_163020157_-4.gif" alt="$i=0, 1, \ldots\delta-1$" class="latex-inline" style="vertical-align: -4px" width="117" height="16">）：若<img src="latex/latex2png-NumberTheory_35998782_-5.gif" alt="$2^{i+1}\nmid d$" class="latex-inline" style="vertical-align: -5px" width="53" height="19">，则令<img src="latex/latex2png-NumberTheory_20582249_-1.gif" alt="$d\leftarrow d-2^i\cdot b$" class="latex-inline" style="vertical-align: -1px" width="96" height="15">，<img src="latex/latex2png-NumberTheory_144522604_-2.gif" alt="$m\leftarrow m+2^i$" class="latex-inline" style="vertical-align: -2px" width="88" height="16">。</li>
<li>输出<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">，算法终止。</li>
</ol>


</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法的有效性)</span>
每次第二步的操作后均有<img src="latex/latex2png-NumberTheory_2087275_-5.gif" alt="$d=a-mb\equiv0\pmod{2^{i+1}}$" class="latex-inline" style="vertical-align: -5px" width="199" height="19">，可知算法的有效性。
<span class="proof-end">□</span>

</div>

<div class="remark">
<span class="proof-header">注20<a name=""></a></span><span class="theorem-name"></span>
Weber<span class="cite"><a class="cite" href="NumberTheory.html#ref-8" name="cite-8">[8]</a></span>仅仅采用bmod代替Euclid算法中的mod操作，修改得到的算法比Binary GCD还要快一些。


</div>

<div class="remark">
<span class="proof-header">注21<a name=""></a></span><span class="theorem-name"></span>
设<img src="latex/latex2png-NumberTheory_137459363_0.gif" alt="$M=2^w$" class="latex-inline" style="vertical-align: 0px" width="58" height="12">为单精度整数的上界，当<img src="latex/latex2png-NumberTheory_247686142_-2.gif" alt="$a\gg b$" class="latex-inline" style="vertical-align: -2px" width="42" height="14">，<img src="latex/latex2png-NumberTheory_128323900_-5.gif" alt="$l_2(a)-l_2(b)+1\gg w$" class="latex-inline" style="vertical-align: -5px" width="153" height="18">时，可以将bmod操作限制在<img src="latex/latex2png-NumberTheory_42955794_0.gif" alt="$M$" class="latex-inline" style="vertical-align: 0px" width="18" height="12">下以提高速度，即取<img src="latex/latex2png-NumberTheory_45386710_0.gif" alt="$\delta=w$" class="latex-inline" style="vertical-align: 0px" width="42" height="12">，降低<img src="latex/latex2png-NumberTheory_196844724_-5.gif" alt="$l_2(a)$" class="latex-inline" style="vertical-align: -5px" width="32" height="18">若干次直到<img src="latex/latex2png-NumberTheory_106557125_-5.gif" alt="$l_2(a)-l_2(b)+1\le w$" class="latex-inline" style="vertical-align: -5px" width="150" height="18">。


</div>



<h3><a name="sec15" id="sec15"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>Jebelean-Weber-Sorenson加速算法</h3>

<p class="first">Jebelean-Weber-Sorenson算法的基本想法来自Sorenson<span class="cite"><a class="cite" href="NumberTheory.html#ref-9" name="cite-9">[9]</a></span>。设<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">与<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">互素，如果存在<img src="latex/latex2png-NumberTheory_150107154_0.gif" alt="$u $" class="latex-inline" style="vertical-align: 0px" width="9" height="8">，<img src="latex/latex2png-NumberTheory_151155730_0.gif" alt="$v $" class="latex-inline" style="vertical-align: 0px" width="8" height="8">满足<img src="latex/latex2png-NumberTheory_191043170_-5.gif" alt="$|u|,|v|<\sqrt{n}$" class="latex-inline" style="vertical-align: -5px" width="89" height="18">使得<img src="latex/latex2png-NumberTheory_231186117_-5.gif" alt="$ua\equiv vb\pmod{n}$" class="latex-inline" style="vertical-align: -5px" width="122" height="18">，为求<img src="latex/latex2png-NumberTheory_231629518_-5.gif" alt="$\gcd(a, b)$" class="latex-inline" style="vertical-align: -5px" width="60" height="18">，考虑新的问题<img src="latex/latex2png-NumberTheory_105049913_-6.gif" alt="$\gcd(\frac{ua-vb}{n}, b)$" class="latex-inline" style="vertical-align: -6px" width="93" height="21">可以将<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">缩小大约<img src="latex/latex2png-NumberTheory_136215567_-4.gif" alt="$\sqrt{n}$" class="latex-inline" style="vertical-align: -4px" width="23" height="17">倍（这类似于Binary GCD中除以2的过程，被称为<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">-约化）。这样的<img src="latex/latex2png-NumberTheory_150107154_0.gif" alt="$u $" class="latex-inline" style="vertical-align: 0px" width="9" height="8">，<img src="latex/latex2png-NumberTheory_151155730_0.gif" alt="$v $" class="latex-inline" style="vertical-align: 0px" width="8" height="8">很可能是存在的，例如考虑满足<img src="latex/latex2png-NumberTheory_5893918_-5.gif" alt="$|u_0|,|v_0|<\sqrt{n}/2$" class="latex-inline" style="vertical-align: -5px" width="119" height="18">二元组<img src="latex/latex2png-NumberTheory_150902339_-5.gif" alt="$(u_0 ,v_0)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">，这样的二元组共有<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">个，计算<img src="latex/latex2png-NumberTheory_80713684_-3.gif" alt="$u_0a-v_0b$" class="latex-inline" style="vertical-align: -3px" width="69" height="15">其中必有两组模<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">同余，将其相减即得满足条件的<img src="latex/latex2png-NumberTheory_250897695_-5.gif" alt="$(u ,v)$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">。下面的算法严格的构造出了<img src="latex/latex2png-NumberTheory_84646625_-5.gif" alt="$(u, v)$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">。</p>

<div class="algorithm">
<span class="theorem-header">算法12<a name="al:uv"></a></span><span class="theorem-name"></span>
输入正整数<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">，满足<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">与<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">互素，计算<img src="latex/latex2png-NumberTheory_84646625_-5.gif" alt="$(u, v)$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">满足<img src="latex/latex2png-NumberTheory_190891250_-5.gif" alt="$0<u,|v|<\sqrt{n}$" class="latex-inline" style="vertical-align: -5px" width="111" height="18">且<img src="latex/latex2png-NumberTheory_231186117_-5.gif" alt="$ua\equiv vb\pmod{n}$" class="latex-inline" style="vertical-align: -5px" width="122" height="18">。

<ol>
<li>计算<img src="latex/latex2png-NumberTheory_132894896_-5.gif" alt="$c\leftarrow ab^{-1}\pmod{n}$" class="latex-inline" style="vertical-align: -5px" width="133" height="19">（当<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">为2的幂时可使用算法<a class="ref-th" href="NumberTheory.html#al:abinv">11</a>）。</li>
<li>令<img src="latex/latex2png-NumberTheory_170680787_-5.gif" alt="$(u_1, v_1)\leftarrow(n, 0)$" class="latex-inline" style="vertical-align: -5px" width="114" height="18">，<img src="latex/latex2png-NumberTheory_172778184_-5.gif" alt="$(u_2, v_2)\leftarrow(c, 1)$" class="latex-inline" style="vertical-align: -5px" width="112" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_135615197_-4.gif" alt="$u_2\ge\sqrt{n}$" class="latex-inline" style="vertical-align: -4px" width="63" height="17">，则令<img src="latex/latex2png-NumberTheory_247649471_-16.gif" alt="$(u_1, v_1)\leftarrow(u_1, v_1)- \left\lfloor\dfrac{u_1}{u_2} \right\rfloor(u_2, v_2)$" class="latex-inline" style="vertical-align: -16px" width="245" height="40">，交换<img src="latex/latex2png-NumberTheory_151951351_-5.gif" alt="$(u_1, v_1)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">与<img src="latex/latex2png-NumberTheory_153000183_-5.gif" alt="$(u_2, v_2)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">，跳到第三步。</li>
<li>输出<img src="latex/latex2png-NumberTheory_153000183_-5.gif" alt="$(u_2, v_2)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">，算法终止。</li>
</ol>


</div>

<div class="proof">
<span class="proof-header">证明</span><span class="">(算法的有效性)</span>
算法本质上就是一个Euclid算法。由于正数<img src="latex/latex2png-NumberTheory_215780332_-2.gif" alt="$u_1$" class="latex-inline" style="vertical-align: -2px" width="16" height="10">的严格递降，算法必在有限步后终止。终止时有<img src="latex/latex2png-NumberTheory_138066543_-4.gif" alt="$u_2<\sqrt{n}\le u_1$" class="latex-inline" style="vertical-align: -4px" width="101" height="17">，而算法过程中始终保持<img src="latex/latex2png-NumberTheory_191988094_-5.gif" alt="$u_1|v_2|+u_2|v_1|=n$" class="latex-inline" style="vertical-align: -5px" width="136" height="18">，可知<img src="latex/latex2png-NumberTheory_20634964_-5.gif" alt="$u_1|v_2|<n$" class="latex-inline" style="vertical-align: -5px" width="74" height="18">，从而<img src="latex/latex2png-NumberTheory_12997243_-5.gif" alt="$|v_2|<\sqrt{n}$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">。
<span class="proof-end">□</span>

</div>

<div class="remark">
<span class="proof-header">注22<a name=""></a></span><span class="theorem-name"></span>
算法<a class="ref-th" href="NumberTheory.html#al:uv">12</a>的第三步还可以用减法和位操作来避免试除，当<img src="latex/latex2png-NumberTheory_150107154_0.gif" alt="$u $" class="latex-inline" style="vertical-align: 0px" width="9" height="8">，<img src="latex/latex2png-NumberTheory_151155730_0.gif" alt="$v $" class="latex-inline" style="vertical-align: 0px" width="8" height="8">相差不大时更加高效。


</div>

<p>现在我们可以高效的计算<img src="latex/latex2png-NumberTheory_105049913_-6.gif" alt="$\gcd(\frac{ua-vb}{n}, b)$" class="latex-inline" style="vertical-align: -6px" width="93" height="21">了，不过还有一个问题，一般来说<img src="latex/latex2png-NumberTheory_30999285_-6.gif" alt="$\gcd(a, b)\mid\gcd(\frac{ua-vb}{n}, b)$" class="latex-inline" style="vertical-align: -6px" width="168" height="21">，但两者未必相等。如果直接计算前者，可能结果会包含“假因子”。通常情况下可以在最后一步处理假因子，因为根据Dirichlet的优美定理<span class="cite"><a class="cite" href="NumberTheory.html#ref-3" name="cite-3">[3]</a></span>，通常求出的最大公因子都会很小（<img src="latex/latex2png-NumberTheory_134575164_-3.gif" alt="$\le3$" class="latex-inline" style="vertical-align: -3px" width="25" height="14">的比例为82.7%），最后一步的处理只花很少时间。</p>

<div class="theorem">
<span class="theorem-header">定理3<a name=""></a></span><span class="theorem-name">(Dirichlet，最大公因子的分布)</span>
设<img src="latex/latex2png-NumberTheory_199990533_-5.gif" alt="$q_n(d)$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">表示在<img src="latex/latex2png-NumberTheory_24871038_-4.gif" alt="$1\le a, b\le n$" class="latex-inline" style="vertical-align: -4px" width="85" height="16">范围内使<img src="latex/latex2png-NumberTheory_184504625_-5.gif" alt="$\gcd(a, b)\le d$" class="latex-inline" style="vertical-align: -5px" width="92" height="18">的有序数对<img src="latex/latex2png-NumberTheory_63675085_-5.gif" alt="$(a, b)$" class="latex-inline" style="vertical-align: -5px" width="34" height="18">的个数，则有<img src="latex/latex2png-NumberTheory_262488039_.gif" alt="$$\lim_{n\rightarrow\infty}\frac{q_n(d)}{n^2}=\frac{6}{\pi^2}\sum_{k=1}^d\frac{1}{k^2}.$$" class="latex-display" width="580" height="48">


</div>

<div class="algorithm">
<span class="theorem-header">算法13<a name="al:jws"></a></span><span class="theorem-name">(Jebelean-Weber-Sorenson加速算法)</span>
设正整数<img src="latex/latex2png-NumberTheory_14519276_-3.gif" alt="$a_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="11">，<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">满足<img src="latex/latex2png-NumberTheory_2421558_-3.gif" alt="$a_0>b_0$" class="latex-inline" style="vertical-align: -3px" width="51" height="15">且<img src="latex/latex2png-NumberTheory_33257137_-4.gif" alt="$\beta$" class="latex-inline" style="vertical-align: -4px" width="10" height="16">互素，依据<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">的长度选取<img src="latex/latex2png-NumberTheory_70552518_-5.gif" alt="$s(b)$" class="latex-inline" style="vertical-align: -5px" width="25" height="18">与<img src="latex/latex2png-NumberTheory_197882938_-5.gif" alt="$t(b)$" class="latex-inline" style="vertical-align: -5px" width="24" height="18">（例如当<img src="latex/latex2png-NumberTheory_49867789_-4.gif" alt="$\beta=2$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">可固定为10与32）。

<ol>
<li>令<img src="latex/latex2png-NumberTheory_232594981_-3.gif" alt="$a\leftarrow a_0$" class="latex-inline" style="vertical-align: -3px" width="50" height="12">，<img src="latex/latex2png-NumberTheory_215817509_-3.gif" alt="$b\leftarrow b_0$" class="latex-inline" style="vertical-align: -3px" width="46" height="15">。</li>
<li>若<img src="latex/latex2png-NumberTheory_33393644_-1.gif" alt="$b=0$" class="latex-inline" style="vertical-align: -1px" width="37" height="13">，跳到第五步。</li>
<li>若<img src="latex/latex2png-NumberTheory_36194644_-5.gif" alt="$l_\beta(a)-l_\beta(b)>s(b)$" class="latex-inline" style="vertical-align: -5px" width="138" height="18">，则令<img src="latex/latex2png-NumberTheory_18196423_-5.gif" alt="$a\leftarrow a \dmod{\beta} b$" class="latex-inline" style="vertical-align: -5px" width="110" height="17">，跳到第三步；否则根据算法<a class="ref-th" href="NumberTheory.html#al:uv">12</a>求得<img src="latex/latex2png-NumberTheory_84646625_-5.gif" alt="$(u, v)$" class="latex-inline" style="vertical-align: -5px" width="36" height="18">使<img src="latex/latex2png-NumberTheory_112293364_-5.gif" alt="$ua\equiv vb\pmod{\beta^{2t(b)}}$" class="latex-inline" style="vertical-align: -5px" width="151" height="20">，令<img src="latex/latex2png-NumberTheory_19736037_-16.gif" alt="$a\leftarrow\dfrac{|ua-vb|}{\beta^{2t(b)}}$" class="latex-inline" style="vertical-align: -16px" width="101" height="40">。</li>
<li>将<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">中的<img src="latex/latex2png-NumberTheory_33257137_-4.gif" alt="$\beta$" class="latex-inline" style="vertical-align: -4px" width="10" height="16">因子去除（当<img src="latex/latex2png-NumberTheory_49867789_-4.gif" alt="$\beta=2$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">时移位即可），并交换<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">与<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">，跳到第二步。</li>
<li>计算<img src="latex/latex2png-NumberTheory_174283668_-5.gif" alt="$x=\gcd(a, b_0 \dmod{\beta} a)$" class="latex-inline" style="vertical-align: -5px" width="167" height="18">，计算输出<img src="latex/latex2png-NumberTheory_101491531_-5.gif" alt="$\gcd(x, a_0 \dmod{\beta} x)$" class="latex-inline" style="vertical-align: -5px" width="138" height="18">，算法终止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注23<a name=""></a></span><span class="theorem-name"></span>
第五步相当于用dmod运算快速求得了<img src="latex/latex2png-NumberTheory_70463200_-5.gif" alt="$\gcd(\gcd(a, b_0), a_0)$" class="latex-inline" style="vertical-align: -5px" width="129" height="18">。


</div>

<div class="remark">
<span class="proof-header">注24<a name=""></a></span><span class="theorem-name"></span>
根据Weber<span class="cite"><a class="cite" href="NumberTheory.html#ref-8" name="cite-8">[8]</a></span>的实验结果，在8个单精度整数长度时（大约77个十进制位），Jebelean-Weber-Sorenson加速算法开始超过Binary GCD。


</div>

<p>尽管一般来说“假因子”都很小，但也有例外的时候，Sedjelmaci<span class="cite"><a class="cite" href="NumberTheory.html#ref-10" name="cite-10">[10]</a></span>以相邻的Fibonacci数<img src="latex/latex2png-NumberTheory_123756383_-5.gif" alt="$(F_N, F_{N+1})$" class="latex-inline" style="vertical-align: -5px" width="81" height="18">为例，当<img src="latex/latex2png-NumberTheory_103970468_-1.gif" alt="$N=300$" class="latex-inline" style="vertical-align: -1px" width="61" height="13">时，假因子为5，<img src="latex/latex2png-NumberTheory_214786766_-1.gif" alt="$N=2000$" class="latex-inline" style="vertical-align: -1px" width="69" height="13">时，假因子为122542875，而当<img src="latex/latex2png-NumberTheory_53648690_-1.gif" alt="$N=3000$" class="latex-inline" style="vertical-align: -1px" width="69" height="13">时，假因子已高达<img src="latex/latex2png-NumberTheory_212691958_-1.gif" alt="$1.02\times10^{15}$" class="latex-inline" style="vertical-align: -1px" width="78" height="15">，而实际上相邻的Fibonacci数总是互素的。</p>

<p>不过Sedjelmaci给出了一个改进来避免假因子的影响，这依赖于以下他证明的命题。</p>

<div class="proposition">
<span class="theorem-header">命题2<a name=""></a></span><span class="theorem-name">(Sedjelmaci)</span>
设算法<a class="ref-th" href="NumberTheory.html#al:uv">12</a>终止时得到了<img src="latex/latex2png-NumberTheory_151951351_-5.gif" alt="$(u_1, v_1)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">，<img src="latex/latex2png-NumberTheory_153000183_-5.gif" alt="$(u_2, v_2)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">，若有<img src="latex/latex2png-NumberTheory_170298747_-11.gif" alt="$\dfrac{a}{b}<\sqrt{n}$" class="latex-inline" style="vertical-align: -11px" width="57" height="30">，则满足<img src="latex/latex2png-NumberTheory_216441798_.gif" alt="$$\gcd(a, b)=\gcd\left(\dfrac{|u_1a-v_1b|}{n}, \dfrac{|u_2a-v_2b|}{n}\right).$$" class="latex-display" width="580" height="40">


</div>

<p>因此可以的到改进版的Jebelean-Weber-Sorenson加速算法：</p>

<div class="algorithm">
<span class="theorem-header">算法14<a name=""></a></span><span class="theorem-name">(Sedjelmaci改进算法)</span>
设正整数<img src="latex/latex2png-NumberTheory_14519276_-3.gif" alt="$a_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="11">，<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">满足<img src="latex/latex2png-NumberTheory_2421558_-3.gif" alt="$a_0>b_0$" class="latex-inline" style="vertical-align: -3px" width="51" height="15">且<img src="latex/latex2png-NumberTheory_33257137_-4.gif" alt="$\beta$" class="latex-inline" style="vertical-align: -4px" width="10" height="16">互素，依据<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">的长度选取与<img src="latex/latex2png-NumberTheory_197882938_-5.gif" alt="$t(b)$" class="latex-inline" style="vertical-align: -5px" width="24" height="18">（例如当<img src="latex/latex2png-NumberTheory_49867789_-4.gif" alt="$\beta=2$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">可固定为32）。

<ol>
<li>令<img src="latex/latex2png-NumberTheory_232594981_-3.gif" alt="$a\leftarrow a_0$" class="latex-inline" style="vertical-align: -3px" width="50" height="12">，<img src="latex/latex2png-NumberTheory_215817509_-3.gif" alt="$b\leftarrow b_0$" class="latex-inline" style="vertical-align: -3px" width="46" height="15">。</li>
<li>若<img src="latex/latex2png-NumberTheory_235041849_-1.gif" alt="$ab=0$" class="latex-inline" style="vertical-align: -1px" width="46" height="13">，跳到第五步；否则令<img src="latex/latex2png-NumberTheory_7600652_-5.gif" alt="$(a, b)\leftarrow(\max\{a, b\},\min\{a, b\})$" class="latex-inline" style="vertical-align: -5px" width="218" height="18">。</li>
<li>若<img src="latex/latex2png-NumberTheory_91878605_-11.gif" alt="$\dfrac{a}{b}\ge\beta^{t(b)}$" class="latex-inline" style="vertical-align: -11px" width="63" height="30">，则令<img src="latex/latex2png-NumberTheory_211864849_-5.gif" alt="$(a, b)\leftarrow(b, a\dmod{\beta}b)$" class="latex-inline" style="vertical-align: -5px" width="162" height="18">；否则根据算法<a class="ref-th" href="NumberTheory.html#al:uv">12</a>求得<img src="latex/latex2png-NumberTheory_151951351_-5.gif" alt="$(u_1, v_1)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">，<img src="latex/latex2png-NumberTheory_153000183_-5.gif" alt="$(u_2, v_2)$" class="latex-inline" style="vertical-align: -5px" width="50" height="18">，使<img src="latex/latex2png-NumberTheory_73475708_-5.gif" alt="$u_2a\equiv v_2b\pmod{\beta^{2t(b)}}$" class="latex-inline" style="vertical-align: -5px" width="166" height="20">，令<img src="latex/latex2png-NumberTheory_141523989_-16.gif" alt="$(a, b)\leftarrow\left(\dfrac{|u_1a-v_1b|}{n}, \dfrac{|u_2a-v_2b|}{n}\right)$" class="latex-inline" style="vertical-align: -16px" width="253" height="40">。</li>
<li>将<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">中的<img src="latex/latex2png-NumberTheory_33257137_-4.gif" alt="$\beta$" class="latex-inline" style="vertical-align: -4px" width="10" height="16">因子去除（当<img src="latex/latex2png-NumberTheory_49867789_-4.gif" alt="$\beta=2$" class="latex-inline" style="vertical-align: -4px" width="40" height="16">时移位即可），跳到第二步。</li>
<li>输出<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">中不为零的数，算法终止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注25<a name=""></a></span><span class="theorem-name"></span>
在算法的第三步可能牺牲了一些时间，但保证了最终得到的最大公因子是不掺“假”的。


</div>




<h2><a name="sec16" id="sec16"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>Legendre-Jacobi-Kronecker符号</h2>

<p class="first">Legendre符号不仅本身很重要，而且在素性检测、因子分解等等领域中也到处出现。</p>

<div class="definition">
<span class="theorem-header">定义3<a name=""></a></span><span class="theorem-name">(Legendre符号)</span>
设<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">为奇素数，<img src="latex/latex2png-NumberTheory_184517568_-1.gif" alt="$a\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -1px" width="40" height="13">，Legendre符号定义为
<img src="latex/latex2png-NumberTheory_30851493_.gif" alt="
\begin{equation*}
  \legendre{a}{p}:=
  \begin{cases}
    1&a\text{为模}p\text{的二次剩余}, \\
    -1&a\text{为模}p\text{的二次非剩余}, \\
    0&p\mid a.
  \end{cases}
\end{equation*}
" class="latex-display" width="580" height="90">


</div>

<p>下面的性质是我们在初等数论教程中熟知的。</p>

<div class="proposition">
<span class="theorem-header">命题3<a name="pr:legpr"></a></span><span class="theorem-name">(Legendre符号的基本性质)</span>
Legendre符号满足：

<ol>
<li>（积性）<img src="latex/latex2png-NumberTheory_166155333_.gif" alt="$$\legendre{a}{p}\legendre{b}{p}=\legendre{ab}{p}.$$" class="latex-display" width="580" height="40"></li>
<li>若<img src="latex/latex2png-NumberTheory_90799474_-5.gif" alt="$a\equiv b\pmod{p}$" class="latex-inline" style="vertical-align: -5px" width="102" height="18">，则<img src="latex/latex2png-NumberTheory_107195195_.gif" alt="$$\legendre{a}{p}=\legendre{b}{p}.$$" class="latex-display" width="580" height="40"></li>
<li>（Euler准则）<img src="latex/latex2png-NumberTheory_229592270_.gif" alt="$$\legendre{a}{p}\equiv a^{(p-1)/2}\pmod{p}.$$" class="latex-display" width="580" height="40"></li>
</ol>


</div>

<p>利用命题<a class="ref-th" href="NumberTheory.html#pr:legpr">3</a>中的第三条便可以通过模幂运算用来计算Legendre符号，时间复杂度为<img src="latex/latex2png-NumberTheory_109838181_-5.gif" alt="$O(\log^3 p)$" class="latex-inline" style="vertical-align: -5px" width="63" height="20">。对此方法本质上的改进依赖于著名的二次互反律。</p>

<div class="theorem">
<span class="theorem-header">定理4<a name=""></a></span><span class="theorem-name">(二次互反律)</span>

<ol>
<li>若<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">，<img src="latex/latex2png-NumberTheory_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">为不相等的素数，则<img src="latex/latex2png-NumberTheory_132008981_.gif" alt="$$\legendre{p}{q}\legendre{q}{p}=(-1)^{\frac{(p-1)(q-1)}{4}}.$$" class="latex-display" width="580" height="40"></li>
<li>（二次互反律的补充）<img src="latex/latex2png-NumberTheory_71716682_.gif" alt="$$\legendre{-1}{p}=(-1)^{\frac{p-1}{2}},\quad \legendre{2}{p}=(-1)^{\frac{p^2-1}{8}}.$$" class="latex-display" width="580" height="40"></li>
</ol>


</div>

<p>利用命题<a class="ref-th" href="NumberTheory.html#pr:legpr">3</a>中的第一、二条及二次互反律可以得到一个直接的计算<img src="latex/latex2png-NumberTheory_109381887_-9.gif" alt="$\legendre{a}{p}$" class="latex-inline" style="vertical-align: -9px" width="18" height="23">的方法（这也是我们在初等数论课程中掌握的）。不过此方法依赖于<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">以及某些中间结果的因子分解，而分解往往不是一件易事。但幸运的是我们还有更好的方法，可以将时间复杂度降到<img src="latex/latex2png-NumberTheory_158597275_-5.gif" alt="$O(\log^2 p)$" class="latex-inline" style="vertical-align: -5px" width="63" height="20">，这依赖于Legendre符号的推广——Kronecker-Jacobi符号。</p>

<div class="definition">
<span class="theorem-header">定义4<a name=""></a></span><span class="theorem-name">(Kronecker-Jacobi符号)</span>
设<img src="latex/latex2png-NumberTheory_142854064_-4.gif" alt="$a, b\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -4px" width="55" height="16">，定义Kronecker-Jacobi符号：

<ol>
<li>若<img src="latex/latex2png-NumberTheory_226361_0.gif" alt="$b=-1$" class="latex-inline" style="vertical-align: 0px" width="49" height="12">，
<img src="latex/latex2png-NumberTheory_82127179_.gif" alt="
\begin{equation*}
\jacobi{a}{-1}:=
\begin{cases}
  1&a\ge0, \\
  -1&a<0.
\end{cases}
\end{equation*}" class="latex-display" width="580" height="61"></li>
<li>若<img src="latex/latex2png-NumberTheory_33262572_0.gif" alt="$b=2$" class="latex-inline" style="vertical-align: 0px" width="37" height="12">，
<img src="latex/latex2png-NumberTheory_224154530_.gif" alt="
\begin{equation*}
\jacobi{a}{2}:=
\begin{cases}
  0&2\mid a, \\
  (-1)^{\frac{a^2-1}{8}}&2\nmid a.
\end{cases}
\end{equation*}" class="latex-display" width="580" height="61"></li>
<li>若<img src="latex/latex2png-NumberTheory_33328108_0.gif" alt="$b=1$" class="latex-inline" style="vertical-align: 0px" width="36" height="12">，<img src="latex/latex2png-NumberTheory_185161136_.gif" alt="$$\jacobi{a}{1}:=1.$$" class="latex-display" width="580" height="40"></li>
<li>若<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">为奇素数，<img src="latex/latex2png-NumberTheory_202108295_-16.gif" alt="$\displaystyle\jacobi{a}{b}$" class="latex-inline" style="vertical-align: -16px" width="27" height="40">定义为Legendre符号。</li>
<li>设<img src="latex/latex2png-NumberTheory_263160403_-15.gif" alt="$b=\varepsilon\cdot\prod\limits_{i=1}^mp_i^{e_i}$" class="latex-inline" style="vertical-align: -15px" width="90" height="36">，其中<img src="latex/latex2png-NumberTheory_161681811_-1.gif" alt="$\varepsilon=\pm1$" class="latex-inline" style="vertical-align: -1px" width="50" height="12">，<img src="latex/latex2png-NumberTheory_238253076_-4.gif" alt="$p_i$" class="latex-inline" style="vertical-align: -4px" width="14" height="12">为素数，根据前四条定义<img src="latex/latex2png-NumberTheory_115459709_.gif" alt="$$\jacobi{a}{b}:=\jacobi{a}{\varepsilon}\prod_{i=1}^m\jacobi{a}{p_i}^{e_i}.$$" class="latex-display" width="580" height="45"></li>
<li>约定当<img src="latex/latex2png-NumberTheory_33393644_-1.gif" alt="$b=0$" class="latex-inline" style="vertical-align: -1px" width="37" height="13">时，
<img src="latex/latex2png-NumberTheory_201341822_.gif" alt="
\begin{equation*}
\jacobi{a}{0}:=
\begin{cases}
  1&a=\pm1, \\
  0&a\ne\pm1.
\end{cases}
\end{equation*}" class="latex-display" width="580" height="61"></li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注26<a name=""></a></span><span class="theorem-name"></span>
设<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">为奇数，和Legendre符号一致，若<img src="latex/latex2png-NumberTheory_23829423_-6.gif" alt="$\jacobi{a}{b}=-1$" class="latex-inline" style="vertical-align: -6px" width="63" height="20">则<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">必为模<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的二次非剩余。但需要注意的是，<img src="latex/latex2png-NumberTheory_202603755_-6.gif" alt="$\jacobi{a}{b}=1$" class="latex-inline" style="vertical-align: -6px" width="50" height="20">并不意味着<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">为模<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的二次剩余。


</div>


<p>Kronecker-Jacobi符号将Legendre符号推广到了所有整数的情形，并且成立以下良好的性质。
<div class="theorem">
<span class="theorem-header">定理5<a name="th:ljk"></a></span><span class="theorem-name">(Kronecker-Jacobi符号的基本性质)</span></p>

<ol>
<li><img src="latex/latex2png-NumberTheory_202669291_-6.gif" alt="$\jacobi{a}{b}=0$" class="latex-inline" style="vertical-align: -6px" width="51" height="20">当且仅当<img src="latex/latex2png-NumberTheory_255895583_-5.gif" alt="$(a, b)\ne1$" class="latex-inline" style="vertical-align: -5px" width="64" height="18">。</li>
<li>对任意<img src="latex/latex2png-NumberTheory_214091640_-4.gif" alt="$a, b, c\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -4px" width="69" height="16">，有<img src="latex/latex2png-NumberTheory_8695325_.gif" alt="$$\jacobi{ab}{c}=\jacobi{a}{c}\jacobi{b}{c}.$$" class="latex-display" width="580" height="40">若还有<img src="latex/latex2png-NumberTheory_178430587_-4.gif" alt="$b\ne0, c\ne0$" class="latex-inline" style="vertical-align: -4px" width="82" height="16">，则<img src="latex/latex2png-NumberTheory_36707613_.gif" alt="$$\jacobi{a}{bc}=\jacobi{a}{b}\jacobi{a}{c}.$$" class="latex-display" width="580" height="40"></li>
<li>设<img src="latex/latex2png-NumberTheory_32345068_-1.gif" alt="$b>0$" class="latex-inline" style="vertical-align: -1px" width="37" height="13">，<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">为任意整数。若<img src="latex/latex2png-NumberTheory_224108787_-5.gif" alt="$b\not\equiv2\pmod{4}$" class="latex-inline" style="vertical-align: -5px" width="102" height="18">，则<img src="latex/latex2png-NumberTheory_187478686_.gif" alt="$$\jacobi{x+b}{b}=\jacobi{x}{b},$$" class="latex-display" width="580" height="40">若<img src="latex/latex2png-NumberTheory_215449803_-5.gif" alt="$b\equiv2\pmod{4}$" class="latex-inline" style="vertical-align: -5px" width="102" height="18">，则<img src="latex/latex2png-NumberTheory_179854949_.gif" alt="$$\jacobi{x+4b}{b}=\jacobi{x}{b}.$$" class="latex-display" width="580" height="40"></li>
<li>设<img src="latex/latex2png-NumberTheory_167933585_-4.gif" alt="$a\ne0$" class="latex-inline" style="vertical-align: -4px" width="39" height="16">，<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">为任意整数。若<img src="latex/latex2png-NumberTheory_63988240_-5.gif" alt="$a\equiv0, 1\pmod{4}$" class="latex-inline" style="vertical-align: -5px" width="119" height="18">，则<img src="latex/latex2png-NumberTheory_25880510_.gif" alt="$$\jacobi{a}{x+|a|}=\jacobi{a}{x},$$" class="latex-display" width="580" height="41">若<img src="latex/latex2png-NumberTheory_64119312_-5.gif" alt="$a\equiv2, 3\pmod{4}$" class="latex-inline" style="vertical-align: -5px" width="119" height="18">，则<img src="latex/latex2png-NumberTheory_41313713_.gif" alt="$$\jacobi{a}{x+4|a|}=\jacobi{a}{x}.$$" class="latex-display" width="580" height="41"></li>
<li>设<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">为正奇数，则有二次互反律：<img src="latex/latex2png-NumberTheory_168723206_.gif" alt="$$\jacobi{a}{b}\jacobi{b}{a}=(-1)^{\frac{(a-1)(b-1)}{4}},$$" class="latex-display" width="580" height="40">且<img src="latex/latex2png-NumberTheory_263973972_.gif" alt="$$\jacobi{-1}{b}=(-1)^{\frac{n-1}{2}},\quad \jacobi{2}{b}=(-1)^{\frac{n^2-1}{8}}.$$" class="latex-display" width="580" height="40"></li>
</ol>


</div>

<p>有了如上更一般的二次互反律，我们可以得到计算Legendre-Jacobi-Kronecker符号的算法了。</p>

<div class="algorithm">
<span class="theorem-header">算法15<a name="al:ljk"></a></span><span class="theorem-name">(Legendre-Jacobi-Kronecker符号)</span>
输入<img src="latex/latex2png-NumberTheory_142854064_-4.gif" alt="$a, b\in\mathbb{Z}$" class="latex-inline" style="vertical-align: -4px" width="55" height="16">，计算<img src="latex/latex2png-NumberTheory_66215201_-6.gif" alt="$\jacobi{a}{b}$" class="latex-inline" style="vertical-align: -6px" width="18" height="20">。

<ol>
<li>若<img src="latex/latex2png-NumberTheory_33393644_-1.gif" alt="$b=0$" class="latex-inline" style="vertical-align: -1px" width="37" height="13">，输出1，算法终止；若<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">均为偶数，输出0，算法终止。</li>
<li>设<img src="latex/latex2png-NumberTheory_2057624_-3.gif" alt="$b=\varepsilon\cdot2^d\cdot b_0$" class="latex-inline" style="vertical-align: -3px" width="90" height="17">，使<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">为正奇数。由定义直接计算<img src="latex/latex2png-NumberTheory_263548629_-7.gif" alt="$m=\jacobi{a}{\varepsilon}\jacobi{a}{2}^d$" class="latex-inline" style="vertical-align: -7px" width="89" height="25">。</li>
<li>若<img src="latex/latex2png-NumberTheory_50170860_-1.gif" alt="$a=0$" class="latex-inline" style="vertical-align: -1px" width="39" height="12">，由定义直接计算<img src="latex/latex2png-NumberTheory_23767179_-7.gif" alt="$m\leftarrow\jacobi{0}{b_0}\cdot m$" class="latex-inline" style="vertical-align: -7px" width="94" height="22">，输出<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">，算法终止；若<img src="latex/latex2png-NumberTheory_167933585_-4.gif" alt="$a\ne0$" class="latex-inline" style="vertical-align: -4px" width="39" height="16">，设<img src="latex/latex2png-NumberTheory_13620324_-3.gif" alt="$a=\epsilon\cdot2^ea_0$" class="latex-inline" style="vertical-align: -3px" width="80" height="14">，<img src="latex/latex2png-NumberTheory_14519276_-3.gif" alt="$a_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="11">为正奇数，计算<img src="latex/latex2png-NumberTheory_197388796_-7.gif" alt="$m\leftarrow\jacobi{\epsilon}{b_0}\jacobi{2}{b_0}^e\cdot m$" class="latex-inline" style="vertical-align: -7px" width="129" height="22">。</li>
<li>运用二次互反律递归地求<img src="latex/latex2png-NumberTheory_57889231_.gif" alt="$$\jacobi{a_0}{b_0}=\jacobi{b_0 \bmod{a_0}}{a_0}(-1)^{\frac{(a_0-1)(b_0-1)}{4}}.$$" class="latex-display" width="580" height="40">计算<img src="latex/latex2png-NumberTheory_157208787_-7.gif" alt="$m\leftarrow\jacobi{a_0}{b_0}\cdot m$" class="latex-inline" style="vertical-align: -7px" width="95" height="21">，输出<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">，算法终止。</li>
</ol>


</div>

<div class="remark">
<span class="proof-header">注27<a name=""></a></span><span class="theorem-name"></span>
在算法的第四步，我们保证了<img src="latex/latex2png-NumberTheory_14519276_-3.gif" alt="$a_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="11">为奇数，从而可以使用定理<a class="ref-th" href="NumberTheory.html#th:ljk">5</a>的第三条。


</div>

<div class="remark">
<span class="proof-header">注28<a name=""></a></span><span class="theorem-name"></span>
<img src="latex/latex2png-NumberTheory_185766491_-5.gif" alt="$(-1)^{\frac{a-1}{2}}$" class="latex-inline" style="vertical-align: -5px" width="57" height="22">，<img src="latex/latex2png-NumberTheory_204345847_-5.gif" alt="$(-1)^{\frac{a^2-1}{8}}$" class="latex-inline" style="vertical-align: -5px" width="63" height="26">和<img src="latex/latex2png-NumberTheory_29833393_-5.gif" alt="$(-1)^{\frac{(a-1)(b-1)}{4}}$" class="latex-inline" style="vertical-align: -5px" width="94" height="24">均可通过位操作和查表获得，例如
<img src="latex/latex2png-NumberTheory_223559393_.gif" alt="
\begin{equation*}
  (-1)^{\frac{(a-1)(b-1)}{4}}=
  \begin{cases}
    -1 & \text{若}\ \mathtt{a \& b \& 2}, \\
    1 & \text{否则}.
  \end{cases}
\end{equation*}
" class="latex-display" width="580" height="61">


</div>

<div class="remark">
<span class="proof-header">注29<a name=""></a></span><span class="theorem-name"></span>
可以看出算法<a class="ref-th" href="NumberTheory.html#al:ljk">15</a>与Euclid算法的复杂度相同，为<img src="latex/latex2png-NumberTheory_160694427_-5.gif" alt="$O(\log^2 n)$" class="latex-inline" style="vertical-align: -5px" width="65" height="20">，其中<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">为<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">，<img src="latex/latex2png-NumberTheory_41710610_0.gif" alt="$b$" class="latex-inline" style="vertical-align: 0px" width="7" height="12">的一个上界，比直接用Legendre符号计算要高效一些。


</div>

<div class="remark">
<span class="proof-header">注30<a name=""></a></span><span class="theorem-name"></span>
算法<a class="ref-th" href="NumberTheory.html#al:ljk">15</a>中第四步也可以用类似于Binary GCD的方法，不用Euclid算法计算<img src="latex/latex2png-NumberTheory_237188622_-16.gif" alt="$\displaystyle\jacobi{b_0\bmod{a_0}}{a_0}$" class="latex-inline" style="vertical-align: -16px" width="90" height="40">，而转而计算<img src="latex/latex2png-NumberTheory_40056865_-16.gif" alt="$\displaystyle\jacobi{b_0-a_0}{a_0}$" class="latex-inline" style="vertical-align: -16px" width="69" height="40">，分离<img src="latex/latex2png-NumberTheory_254080053_-3.gif" alt="$b_0-a_0$" class="latex-inline" style="vertical-align: -3px" width="50" height="15">中2的幂，再用二次互反律。当<img src="latex/latex2png-NumberTheory_14519276_-3.gif" alt="$a_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="11">，<img src="latex/latex2png-NumberTheory_2257940_-3.gif" alt="$b_0$" class="latex-inline" style="vertical-align: -3px" width="13" height="15">较大时，也可采用bmod操作。


</div>


<h2><a name="sec17" id="sec17"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>中国剩余定理</h2>

<p class="first">中国剩余定理是为数不多以“中国”命名的重要定理——关于交换幺环结构的经典结果。为了完整性，我们以常用的<img src="latex/latex2png-NumberTheory_50353232_0.gif" alt="$\mathbb{Z}$" class="latex-inline" style="vertical-align: 0px" width="11" height="12">上的语言叙述如下。</p>

<div class="algorithm">
<span class="theorem-header">算法16<a name="th:crt"></a></span><span class="theorem-name">(中国剩余定理)</span>
设整数<img src="latex/latex2png-NumberTheory_187921428_-2.gif" alt="$m_i$" class="latex-inline" style="vertical-align: -2px" width="20" height="10">（<img src="latex/latex2png-NumberTheory_56025821_-4.gif" alt="$i=1, \ldots, n$" class="latex-inline" style="vertical-align: -4px" width="83" height="16">）两两互素，则对任意的<img src="latex/latex2png-NumberTheory_164400108_-2.gif" alt="$x_i$" class="latex-inline" style="vertical-align: -2px" width="14" height="10">（<img src="latex/latex2png-NumberTheory_56025821_-4.gif" alt="$i=1, \ldots, n$" class="latex-inline" style="vertical-align: -4px" width="83" height="16">），存在唯一的整数<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">（在模<img src="latex/latex2png-NumberTheory_196999948_-15.gif" alt="$M=\prod\limits_{i=1}^nm_i$" class="latex-inline" style="vertical-align: -15px" width="84" height="36">的意义下），满足<img src="latex/latex2png-NumberTheory_206926357_-5.gif" alt="$x\equiv x_i\pmod{m_i}$" class="latex-inline" style="vertical-align: -5px" width="123" height="18">（<img src="latex/latex2png-NumberTheory_56025821_-4.gif" alt="$i=1, \ldots, n$" class="latex-inline" style="vertical-align: -4px" width="83" height="16">）。


</div>

<div class="proof">
<span class="proof-header">证明</span>
记<img src="latex/latex2png-NumberTheory_37312206_-5.gif" alt="$M_i=M/m_i$" class="latex-inline" style="vertical-align: -5px" width="89" height="18">，则对于任意<img src="latex/latex2png-NumberTheory_137524242_0.gif" alt="$i $" class="latex-inline" style="vertical-align: 0px" width="5" height="12">，存在<img src="latex/latex2png-NumberTheory_13405164_-2.gif" alt="$a_i$" class="latex-inline" style="vertical-align: -2px" width="14" height="10">，满足<img src="latex/latex2png-NumberTheory_35214219_-5.gif" alt="$a_iM_i\equiv1\pmod{m_i}$" class="latex-inline" style="vertical-align: -5px" width="143" height="18">，从而<img src="latex/latex2png-NumberTheory_167923944_-15.gif" alt="$x=\sum\limits_{i=1}^na_iM_ix_i$" class="latex-inline" style="vertical-align: -15px" width="106" height="36">即满足条件。唯一性是显然的。
<span class="proof-end">□</span>

</div>

<p>这个构造性的证明可以得到一个直接的中国剩余定理算法，不过如果<img src="latex/latex2png-NumberTheory_214731756_-2.gif" alt="$M_i$" class="latex-inline" style="vertical-align: -2px" width="21" height="14">很大的话，直接求逆或许不那么划算，我们可以稍作改进。</p>

<div class="algorithm">
<span class="theorem-header">算法17<a name=""></a></span><span class="theorem-name"></span>
记号如定理<a class="ref-th" href="NumberTheory.html#th:crt">16</a>。

<ol>
<li>设<img src="latex/latex2png-NumberTheory_74099464_-4.gif" alt="$p_i=m_1\cdots m_{i-1}\bmod m_i$" class="latex-inline" style="vertical-align: -4px" width="182" height="16">（<img src="latex/latex2png-NumberTheory_27626682_-4.gif" alt="$i=2,\cdots,n$" class="latex-inline" style="vertical-align: -4px" width="86" height="16">)，用扩展Euclid算法计算<img src="latex/latex2png-NumberTheory_214797253_-2.gif" alt="$u_i $" class="latex-inline" style="vertical-align: -2px" width="15" height="10">，<img src="latex/latex2png-NumberTheory_197954540_-2.gif" alt="$v_i$" class="latex-inline" style="vertical-align: -2px" width="13" height="10">使得<img src="latex/latex2png-NumberTheory_129611101_-4.gif" alt="$u_ip_i+v_im_i=1$" class="latex-inline" style="vertical-align: -4px" width="112" height="15">。</li>
<li>顺次计算
<img src="latex/latex2png-NumberTheory_9824432_.gif" alt="
\begin{align*}
  y_1&=x_1 \bmod m_1, \\
  y_2&=(x_2 -y_1)u_2 \bmod m_2, \\
  &\vdots \\
  y_i&=(x_i-(y_1+m_1(y_2+m_2(y_2+\cdots m_{i-2}y_{i-1})\cdots)))u_i\bmod m_i.
\end{align*}
" class="latex-display" width="580" height="118"></li>
<li>输出<img src="latex/latex2png-NumberTheory_198290079_-5.gif" alt="$x=y_1+m_1(y_2+m_2(y_3+\cdots m_{n-1}y_n)\cdots)$" class="latex-inline" style="vertical-align: -5px" width="313" height="18">。</li>
</ol>


</div>

<p>算法本质上是求出<img src="latex/latex2png-NumberTheory_140882559_-15.gif" alt="$x=\sum\limits_{i=1}^ny_ip_i$" class="latex-inline" style="vertical-align: -15px" width="83" height="36">中的系数<img src="latex/latex2png-NumberTheory_147622892_-4.gif" alt="$y_i$" class="latex-inline" style="vertical-align: -4px" width="13" height="12">，用<img src="latex/latex2png-NumberTheory_238253076_-4.gif" alt="$p_i$" class="latex-inline" style="vertical-align: -4px" width="14" height="12">代替原来的<img src="latex/latex2png-NumberTheory_214731756_-2.gif" alt="$M_i$" class="latex-inline" style="vertical-align: -2px" width="21" height="14">减小了求逆的复杂度。但由于需要第一步较复杂的预处理，因此更适合在<img src="latex/latex2png-NumberTheory_187921428_-2.gif" alt="$m_i$" class="latex-inline" style="vertical-align: -2px" width="20" height="10">给定的情况下进行多次求解的问题。如果<img src="latex/latex2png-NumberTheory_187921428_-2.gif" alt="$m_i$" class="latex-inline" style="vertical-align: -2px" width="20" height="10">总是变化的话，将<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">个方程的方程组化为<img src="latex/latex2png-NumberTheory_151221268_0.gif" alt="$n-1$" class="latex-inline" style="vertical-align: 0px" width="37" height="11">组两个方程的方程组更适合一些，也就是说先求出满足<img src="latex/latex2png-NumberTheory_206926357_-5.gif" alt="$x\equiv x_i\pmod{m_i}$" class="latex-inline" style="vertical-align: -5px" width="123" height="18">（<img src="latex/latex2png-NumberTheory_66352791_-4.gif" alt="$i=1,2$" class="latex-inline" style="vertical-align: -4px" width="52" height="16">）的解<img src="latex/latex2png-NumberTheory_74947958_-2.gif" alt="$x_{12}$" class="latex-inline" style="vertical-align: -2px" width="22" height="10">，再求出满足
<img src="latex/latex2png-NumberTheory_73803770_.gif" alt="
\begin{equation*}
  \left\{
  \begin{aligned}
    x&\equiv x_{12}\pmod{m_1m_2}, \\
    x&\equiv x_3\pmod{m_3}.
  \end{aligned}\right.
\end{equation*}" class="latex-display" width="580" height="61">
的解<img src="latex/latex2png-NumberTheory_92932696_-3.gif" alt="$x_{123}$" class="latex-inline" style="vertical-align: -3px" width="29" height="11">等等，如此递推即可。</p>


<h2><a name="sec18" id="sec18"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>连分数展式</h2>

<p class="first">任实数的（简单）连分数展式可以按照定义逐项计算（倒数、取整）。我们熟知数论中一个优美的结论：一个数的连分数展式为循环的当且仅当其为二次无理数（二次整系数方程的根）。代数系统中尤其关心的也是二次无理数的展式可否有高效稳定的算法（例如应用在因子分解的CFRAC方法，Pell方程的求解）。<span class="nocite"><a class="cite" href="NumberTheory.html#ref-11" name="cite-11">[11]</a></span></p>

<p>不失一般性，设<img src="latex/latex2png-NumberTheory_141197778_-15.gif" alt="$b_0=\dfrac{\sqrt{d}+p_0}{q_0}$" class="latex-inline" style="vertical-align: -15px" width="98" height="41">为二次无理数，假设<img src="latex/latex2png-NumberTheory_258294358_-5.gif" alt="$q_0\mid d-p_0^2$" class="latex-inline" style="vertical-align: -5px" width="72" height="19">（否则考虑<img src="latex/latex2png-NumberTheory_1472419_-16.gif" alt="$\dfrac{\sqrt{dq_0^2}+p_0|q_0|}{q_0|q_0|}$" class="latex-inline" style="vertical-align: -16px" width="101" height="43">）且有连分数展式<img src="latex/latex2png-NumberTheory_163366640_.gif" alt="$$b_0=a_0+\dfrac{1}{b_1}=a_0+\cfrac{1}{a_1+\cfrac{1}{b_2}}=\cdots =a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{a_3 + \cfrac{1}{\ddots\,}}}},$$" class="latex-display" width="580" height="138">则由定义得到<img src="latex/latex2png-NumberTheory_9582663_.gif" alt="$$b_i=a_i+\frac{1}{b_{i+1}}.$$" class="latex-display" width="580" height="38">设<img src="latex/latex2png-NumberTheory_161845038_-15.gif" alt="$b_i=\dfrac{\sqrt{d}+p_i}{q_i}$" class="latex-inline" style="vertical-align: -15px" width="94" height="41">，则有<img src="latex/latex2png-NumberTheory_265138073_.gif" alt="$$\frac{\sqrt{d}+p_i}{q_i}=a_i+\frac{q_{i+1}}{\sqrt{d}+p_{i+1}}.$$" class="latex-display" width="580" height="45">比较有理部分和无理部分可知
<img src="latex/latex2png-NumberTheory_106222073_.gif" alt="
\begin{equation*}
  \left\{
    \begin{aligned}
      d+p_ip_{i+1}&=a_iq_iq_{i+1}+q_iq_{i+1}, \\
      p_i+p_{i+1}&=a_iq_i.
    \end{aligned}\right.\tag{1}
\end{equation*}" class="latex-display" name="eqref-1" width="580" height="61">
将式<a class="ref-eq" href="NumberTheory.html#eqref-1"  title="公式(1)">(1)</a>的第二式乘以<img src="latex/latex2png-NumberTheory_26607015_-4.gif" alt="$p_{i+1}$" class="latex-inline" style="vertical-align: -4px" width="30" height="12">减去第一式得到
<img src="latex/latex2png-NumberTheory_71730628_.gif" alt="
\begin{equation*}
  \tag{2}
  d-p_{i+1}^2=q_iq_{i+1}.
\end{equation*}" class="latex-display" name="eqref-2" width="580" height="21">
在式<a class="ref-eq" href="NumberTheory.html#eqref-2"  title="公式(2)">(2)</a>中以<img src="latex/latex2png-NumberTheory_137524242_0.gif" alt="$i $" class="latex-inline" style="vertical-align: 0px" width="5" height="12">代<img src="latex/latex2png-NumberTheory_65238036_-2.gif" alt="$i+1$" class="latex-inline" style="vertical-align: -2px" width="33" height="14">并作差得到<img src="latex/latex2png-NumberTheory_218821815_.gif" alt="$$p_i^2-p_{i+1}^2=q_i(q_{i+1}-q_{i-1}).$$" class="latex-display" width="580" height="21">再由<a class="ref-eq" href="NumberTheory.html#eqref-1"  title="公式(1)">(1)</a>中第二式可知<img src="latex/latex2png-NumberTheory_149114020_.gif" alt="$$a_i(p_i-p_{i+1})=q_{i+1}-q_{i-1}.$$" class="latex-display" width="580" height="18">最终得到
<img src="latex/latex2png-NumberTheory_211669058_.gif" alt="
\begin{equation*}
  \left\{
      \begin{aligned}
        a_{i}&=
        \left\lfloor
          \frac{\sqrt{d}+p_i}{q_i}
        \right\rfloor,\\
        p_{i+1}&=a_iq_i-p_i, \\
        q_{i+1}&=a_i(p_i-p_{i+1})+q_{i-1}.
      \end{aligned}\right.
\end{equation*}" class="latex-display" width="580" height="112">
其中约定<img src="latex/latex2png-NumberTheory_957762_-15.gif" alt="$q_{-1}=\dfrac{d-p_0^2}{q_0}$" class="latex-inline" style="vertical-align: -15px" width="94" height="40">（利用<img src="latex/latex2png-NumberTheory_257205165_-15.gif" alt="$\dfrac{d-p_0^2}{q_0}$" class="latex-inline" style="vertical-align: -15px" width="45" height="40">为整数）。</p>

<div class="remark">
<span class="proof-header">注31<a name=""></a></span><span class="theorem-name"></span>
若<img src="latex/latex2png-NumberTheory_184322399_-4.gif" alt="$q_i=1$" class="latex-inline" style="vertical-align: -4px" width="42" height="15">，则<img src="latex/latex2png-NumberTheory_52183536_-5.gif" alt="$a_i=\lfloor\sqrt{d}\rfloor+p_i$" class="latex-inline" style="vertical-align: -5px" width="107" height="20">，而若<img src="latex/latex2png-NumberTheory_183273823_-4.gif" alt="$q_i>1$" class="latex-inline" style="vertical-align: -4px" width="42" height="15">，不难验证<img src="latex/latex2png-NumberTheory_103621838_-21.gif" alt="$a_i=\left\lfloor\dfrac{\lfloor\sqrt{d}\rfloor+p_i}{q_i}\right\rfloor$" class="latex-inline" style="vertical-align: -21px" width="128" height="50">，利用整数开方算法<a class="ref-th" href="NumberTheory.html#al:intsqrt">4</a>可以只动用整数运算来递推计算展式中的<img src="latex/latex2png-NumberTheory_124221073_-2.gif" alt="$a_{i}$" class="latex-inline" style="vertical-align: -2px" width="14" height="10">。


</div>





<h2><a name="sec19" id="sec19"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>素数计数函数<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18"></h2>

<p class="first">很早人们就考虑计算小于等于<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">的素数个数<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">的问题，并且数论中的一个基本问题便是研究<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">的性质（例如著名的素数定理）。古希腊人有一个直接的方法：用Eratosthenes筛将所有<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">以下的素数给找出来，最后统计一下总数。根据Mertens第二定理<span class="cite"><a class="cite" href="NumberTheory.html#ref-12" name="cite-12">[12]</a></span>，<img src="latex/latex2png-NumberTheory_115485793_.gif" alt="$$\sum_{p\le x}\frac{1}{p}=\ln\ln x+a+O\left(\frac{1}{\ln x}\right),$$" class="latex-display" width="580" height="48">其中<img src="latex/latex2png-NumberTheory_41645074_0.gif" alt="$a$" class="latex-inline" style="vertical-align: 0px" width="8" height="8">为常数，求和针对素数<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">。因此这种完全筛法需要的操作次数为<img src="latex/latex2png-NumberTheory_127070773_.gif" alt="$$\sum_{p\le \sqrt{x}}\frac{x}{p}=x\ln\ln \sqrt{x}+ax+O\left(\frac{x}{\ln \sqrt{x}}\right)=O(x\ln\ln x).$$" class="latex-display" width="580" height="50"></p>

<p>除了直接把所有素数求出还有没有其他办法呢？可以使用组合的工具。设<img src="latex/latex2png-NumberTheory_238253076_-4.gif" alt="$p_i$" class="latex-inline" style="vertical-align: -4px" width="14" height="12">代表第<img src="latex/latex2png-NumberTheory_42169362_0.gif" alt="$i$" class="latex-inline" style="vertical-align: 0px" width="12" height="12">个素数，根据容斥原理计算<img src="latex/latex2png-NumberTheory_43152402_0.gif" alt="$x$" class="latex-inline" style="vertical-align: 0px" width="9" height="8">以下的合数个数可以得到
<img src="latex/latex2png-NumberTheory_255637674_.gif" alt="
\begin{equation*}
\begin{split}
  1+\pi(x)-\pi(\sqrt{x})=\lfloor x\rfloor-\sum_{p_i\le\sqrt{x}}\left\lfloor \frac{x}{p_i}\right\rfloor+\sum_{p_i<p_j\le\sqrt{x}}\left\lfloor \frac{x}{p_ip_j}\right\rfloor\\-  \sum_{p_i<p_j<p_k\le\sqrt{x}}\left\lfloor \frac{x}{p_ip_jp_k}\right\rfloor+\cdots.
\end{split}
\end{equation*}
" class="latex-display" width="580" height="107">
等式右端称为Legendre和。然而Lengendre和中的非零项非常多（大约有<img src="latex/latex2png-NumberTheory_127462994_-11.gif" alt="$\dfrac{6}{\pi}(1-\ln2)x$" class="latex-inline" style="vertical-align: -11px" width="87" height="33">项<span class="cite"><a class="cite" href="NumberTheory.html#ref-13" name="cite-13">[13]</a></span>），并不适合直接应用于<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">的计算。为了减少Legendre和中的项数，19世纪德国天文学家Meissel提出了部分筛法并正确求得了<img src="latex/latex2png-NumberTheory_72103878_-5.gif" alt="$\pi(10^8)$" class="latex-inline" style="vertical-align: -5px" width="46" height="19">。1959年，Lehmer改进了Meissel的方法，并用计算机求得了<img src="latex/latex2png-NumberTheory_239682958_-5.gif" alt="$\pi(10^{10})$" class="latex-inline" style="vertical-align: -5px" width="52" height="19">。1985年，Lagarias，Miller，Odlyzko<span class="cite"><a class="cite" href="NumberTheory.html#ref-13" name="cite-13">[13]</a></span>用更精细的Meissel-Lehmer方法求得了<img src="latex/latex2png-NumberTheory_90010715_-5.gif" alt="$\pi(4\times10^{16})$" class="latex-inline" style="vertical-align: -5px" width="81" height="19">，1996年，Del&eacute;glise和Rivat<span class="cite"><a class="cite" href="NumberTheory.html#ref-14" name="cite-14">[14]</a></span>证明了可以在<img src="latex/latex2png-NumberTheory_19970869_-16.gif" alt="$O\left(\dfrac{x^{2/3}}{\ln^2x}\right)$" class="latex-inline" style="vertical-align: -16px" width="74" height="42">时间和<img src="latex/latex2png-NumberTheory_31313418_-5.gif" alt="$O(x^{1/3}\ln^3x\ln\ln x)$" class="latex-inline" style="vertical-align: -5px" width="135" height="20">空间内计算<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">，并将计算记录提高到了<img src="latex/latex2png-NumberTheory_105465230_-5.gif" alt="$\pi(10^{18})$" class="latex-inline" style="vertical-align: -5px" width="52" height="19">。目前的世界纪录为分布式计算项目<a href="http://numbers.computation.free.fr/Constants/Primes/Pix/pixproject.html" class="external">pi(x)</a>保持的<img src="latex/latex2png-NumberTheory_245533605_-5.gif" alt="$\pi(4\times10^{22})$" class="latex-inline" style="vertical-align: -5px" width="81" height="19">。</p>

<h3><a name="sec20" id="sec20"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>部分筛函数</h3>

<p class="first">部分筛函数定义为<img src="latex/latex2png-NumberTheory_83845483_.gif" alt="$$\phi(x,a):=\#\{\text{正整数}~n\le x\mid n~\text{的所有素因子}>p_a\},$$" class="latex-display" width="580" height="19">再设<img src="latex/latex2png-NumberTheory_115774995_.gif" alt="$$P_k(x,a):=\#\{\text{正整数}~n\le x\mid n~\text{恰有}~k~\text{个素因子且所有素因子}>p_a\}.$$" class="latex-display" width="580" height="19">约定<img src="latex/latex2png-NumberTheory_69617424_-5.gif" alt="$P_0(x,a):=1$" class="latex-inline" style="vertical-align: -5px" width="90" height="18">，根据定义可以得到<img src="latex/latex2png-NumberTheory_8050882_.gif" alt="$$\phi(x,a)=\sum_{k=0}^\infty P_k(x,a),$$" class="latex-display" width="580" height="46">其中的求和实际上是有限和，因为当<img src="latex/latex2png-NumberTheory_13610605_-7.gif" alt="$k\ge\log_{p_a}x$" class="latex-inline" style="vertical-align: -7px" width="79" height="19">时<img src="latex/latex2png-NumberTheory_266655599_-5.gif" alt="$P_k(x,a)$" class="latex-inline" style="vertical-align: -5px" width="56" height="18">恒为零。为了减少求和的项数，我们取<img src="latex/latex2png-NumberTheory_43217938_-4.gif" alt="$y$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">满足<img src="latex/latex2png-NumberTheory_175871885_-4.gif" alt="$x^{1/3}\le y\le x^{1/2}$" class="latex-inline" style="vertical-align: -4px" width="112" height="19">，<img src="latex/latex2png-NumberTheory_43825378_-5.gif" alt="$a=\pi(y)$" class="latex-inline" style="vertical-align: -5px" width="61" height="18">，则求和只有三项非零：
<img src="latex/latex2png-NumberTheory_227849_.gif" alt="
\begin{align*}
  \phi(x,a)&=P_0(x,a)+P_1(x,a)+P_2(x,a) \\
  &=1+(\pi(x)-a)+P_2(x,a).
\end{align*}
" class="latex-display" width="580" height="49">
从而<img src="latex/latex2png-NumberTheory_150233753_.gif" alt="$$\pi(x)=\phi(x,a)+P_2(x,a)+a-1,$$" class="latex-display" width="580" height="18">我们只需要高效地求出<img src="latex/latex2png-NumberTheory_228837297_-5.gif" alt="$\phi(x,a)$" class="latex-inline" style="vertical-align: -5px" width="47" height="18">与<img src="latex/latex2png-NumberTheory_266655327_-5.gif" alt="$P_2(x,a)$" class="latex-inline" style="vertical-align: -5px" width="55" height="18">即可。</p>


<h3><a name="sec21" id="sec21"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_266655327_-5.gif" alt="$P_2(x,a)$" class="latex-inline" style="vertical-align: -5px" width="55" height="18"></h3>

<p class="first">由定义（总假定<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">为正整数），<img src="latex/latex2png-NumberTheory_92129272_.gif" alt="$$P_k(x,a)=\#\{n\le x\mid n=pq,\text{素数}~p,q>p_a\},$$" class="latex-display" width="580" height="19">故有
<img src="latex/latex2png-NumberTheory_207762327_.gif" alt="
\begin{align*}
  P_k(x,a)&=\sum_{y<p\le\sqrt{x}}\#\{\text{素数}~q\mid p\le q\le\frac{x}{p}\} \\
  &=\sum_{y<p\le\sqrt{x}}\pi\left(\frac{x}{p}\right)-\pi(p)+1.
\end{align*}
" class="latex-display" width="580" height="101">
由于<img src="latex/latex2png-NumberTheory_1164488_-15.gif" alt="$\dfrac{x}{p}\le x^{2/3}$" class="latex-inline" style="vertical-align: -15px" width="63" height="34">，<img src="latex/latex2png-NumberTheory_49728113_-4.gif" alt="$p\le x^{1/2}$" class="latex-inline" style="vertical-align: -4px" width="60" height="19">，因此可用直接用<img src="latex/latex2png-NumberTheory_211081121_-5.gif" alt="$[1, x^{2/3}]$" class="latex-inline" style="vertical-align: -5px" width="53" height="20">上的完全筛法在<img src="latex/latex2png-NumberTheory_54357351_-5.gif" alt="$O(x^{2/3+\varepsilon})$" class="latex-inline" style="vertical-align: -5px" width="70" height="20">时间内求得<img src="latex/latex2png-NumberTheory_266655327_-5.gif" alt="$P_2(x,a)$" class="latex-inline" style="vertical-align: -5px" width="55" height="18">。</p>


<h3><a name="sec22" id="sec22"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_228837297_-5.gif" alt="$\phi(x,a)$" class="latex-inline" style="vertical-align: -5px" width="47" height="18"></h3>

<p class="first">部分筛函数最重要的组合性质之一是如下的等式<img src="latex/latex2png-NumberTheory_119365275_.gif" alt="$$\phi(x,a-1)=\phi(x,a)+\phi(\frac{x}{p_a},a-1),$$" class="latex-display" width="580" height="35">右边第一项的组合意义为<img src="latex/latex2png-NumberTheory_16757060_-5.gif" alt="$\phi(x,a-1)$" class="latex-inline" style="vertical-align: -5px" width="75" height="18">对应的数中不含有因子<img src="latex/latex2png-NumberTheory_237728788_-4.gif" alt="$p_a$" class="latex-inline" style="vertical-align: -4px" width="16" height="12">的那部分，而第二项则表示含有因子<img src="latex/latex2png-NumberTheory_237728788_-4.gif" alt="$p_a$" class="latex-inline" style="vertical-align: -4px" width="16" height="12">的那部分。从而可得递推关系
<img src="latex/latex2png-NumberTheory_71282935_.gif" alt="
\begin{equation*}
  \left\{
    \begin{aligned}
      \phi(x,a)&=\phi(x,a-1)-\phi(\frac{x}{p_a},a-1), \\
      \phi(x,0)&=\lfloor x\rfloor.
    \end{aligned}\right.
\end{equation*}
" class="latex-display" width="580" height="63">
由此可画出<img src="latex/latex2png-NumberTheory_228837297_-5.gif" alt="$\phi(x,a)$" class="latex-inline" style="vertical-align: -5px" width="47" height="18">的二叉树（仅画出前三层），<table class="image" width="100%">
  <tr><td align="center"><img src="images/btree.png" alt="计算$\phi(x,a)$的二叉树"></td></tr>
  <tr><td align="center" class="image-caption">计算$\phi(x,a)$的二叉树</td></tr>
</table>
递归到二叉树的叶结点最终得到
<img src="latex/latex2png-NumberTheory_222097870_.gif" alt="
\begin{equation*}
  \tag{3}
\phi(x,a)=\sum_{n\le x\atop P^+(n)\le y}\mu(n)\left\lfloor\frac{x}{n}\right\rfloor,
\end{equation*}
" class="latex-display" name="eqref-3" width="580" height="52">
其中<img src="latex/latex2png-NumberTheory_57958885_-5.gif" alt="$\mu(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">为M&ouml;bius函数，<img src="latex/latex2png-NumberTheory_57959054_-5.gif" alt="$P^+(n)$" class="latex-inline" style="vertical-align: -5px" width="45" height="19">表示<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的最大素因子。</p>

<p>但<a class="ref-eq" href="NumberTheory.html#eqref-3"  title="公式(3)">(3)</a>中的求和项仍然太多，例如有三个素因子均<img src="latex/latex2png-NumberTheory_11307342_-4.gif" alt="$\le y$" class="latex-inline" style="vertical-align: -4px" width="25" height="15">的数的个数为<img src="latex/latex2png-NumberTheory_114012220_-5.gif" alt="$O((x^{1/3}/\ln x^{1/3})^3)=O(x/\ln^3 x)$" class="latex-inline" style="vertical-align: -5px" width="234" height="20">。因此我们需要对二叉树进行剪枝，例如可以采取如下的剪枝规则：</p>

<ol>
<li><img src="latex/latex2png-NumberTheory_50170860_-1.gif" alt="$a=0$" class="latex-inline" style="vertical-align: -1px" width="39" height="12">且<img src="latex/latex2png-NumberTheory_11297582_-4.gif" alt="$n\le y$" class="latex-inline" style="vertical-align: -4px" width="40" height="15">；（叶结点）</li>
<li><img src="latex/latex2png-NumberTheory_171144212_-4.gif" alt="$n>y$" class="latex-inline" style="vertical-align: -4px" width="40" height="13">。（层数过深）</li>
</ol>

<p>由如上的剪枝规则可得<img src="latex/latex2png-NumberTheory_3658239_-5.gif" alt="$\phi(x,a)=S_0+S$" class="latex-inline" style="vertical-align: -5px" width="120" height="18">，其中<img src="latex/latex2png-NumberTheory_165417943_.gif" alt="$$S_0=\sum_{n\le y}\mu(n)\left\lfloor\frac{x}{n}\right\rfloor,$$" class="latex-display" width="580" height="43">
<img src="latex/latex2png-NumberTheory_190293174_.gif" alt="
\begin{equation*}
  \tag{4}
S=\sum_{n/P^-(n)\le y<n}\mu(n)\phi\left(\frac{x}{n},\pi(P^-(n))-1\right),
\end{equation*}
" class="latex-display" name="eqref-4" width="580" height="44">
<img src="latex/latex2png-NumberTheory_210635297_-5.gif" alt="$P^- (n)$" class="latex-inline" style="vertical-align: -5px" width="45" height="18">表示<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">的最小素因子。</p>

<p>由于<img src="latex/latex2png-NumberTheory_49728113_-4.gif" alt="$n\le x^{1/2}$" class="latex-inline" style="vertical-align: -4px" width="60" height="19">，<img src="latex/latex2png-NumberTheory_1164486_-11.gif" alt="$\dfrac{x}{n}\le x^{2/3}$" class="latex-inline" style="vertical-align: -11px" width="63" height="30">，可以在<img src="latex/latex2png-NumberTheory_241641609_-5.gif" alt="$O(x^{2/3})$" class="latex-inline" style="vertical-align: -5px" width="54" height="20">的时间内计算<img src="latex/latex2png-NumberTheory_115182572_-3.gif" alt="$S_0$" class="latex-inline" style="vertical-align: -3px" width="15" height="15">。</p>


<h3><a name="sec23" id="sec23"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13"></h3>

<p class="first">设<img src="latex/latex2png-NumberTheory_55298446_-5.gif" alt="$p=P^-(n)$" class="latex-inline" style="vertical-align: -5px" width="77" height="18">，<img src="latex/latex2png-NumberTheory_26899514_-4.gif" alt="$n=mp$" class="latex-inline" style="vertical-align: -4px" width="55" height="12">，则<img src="latex/latex2png-NumberTheory_116874971_-5.gif" alt="$\mu(n)=-\mu(m)$" class="latex-inline" style="vertical-align: -5px" width="104" height="18">且<img src="latex/latex2png-NumberTheory_44837618_-5.gif" alt="$P^-(m)>p$" class="latex-inline" style="vertical-align: -5px" width="82" height="18">，式<a class="ref-eq" href="NumberTheory.html#eqref-4"  title="公式(4)">(4)</a>变为<img src="latex/latex2png-NumberTheory_28470598_.gif" alt="$$S=-\sum_{p\le y}\sum_{P^-(m)>p\atop m\le y<mp}\mu(m)\phi\left(\frac{x}{mp},\pi(p)-1\right).$$" class="latex-display" width="580" height="57">可将<img src="latex/latex2png-NumberTheory_43349010_-1.gif" alt="$S$" class="latex-inline" style="vertical-align: -1px" width="10" height="13">的外层求和拆为三项<img src="latex/latex2png-NumberTheory_38370617_-3.gif" alt="$S_1+S_2+S_3$" class="latex-inline" style="vertical-align: -3px" width="91" height="15">，求和分别对<img src="latex/latex2png-NumberTheory_58469973_-4.gif" alt="$x^{1/3}<p\le y$" class="latex-inline" style="vertical-align: -4px" width="91" height="19">，<img src="latex/latex2png-NumberTheory_107672578_-4.gif" alt="$x^{1/4}<p\le x^{1/3}$" class="latex-inline" style="vertical-align: -4px" width="112" height="19">及<img src="latex/latex2png-NumberTheory_51825265_-4.gif" alt="$p\le x^{1/4}$" class="latex-inline" style="vertical-align: -4px" width="60" height="19">。注意到当<img src="latex/latex2png-NumberTheory_86223432_-4.gif" alt="$p>x^{1/4}$" class="latex-inline" style="vertical-align: -4px" width="60" height="19">时，若<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">非素数，由<img src="latex/latex2png-NumberTheory_44837618_-5.gif" alt="$P^-(m)>p$" class="latex-inline" style="vertical-align: -5px" width="82" height="18">可知<img src="latex/latex2png-NumberTheory_79004379_-4.gif" alt="$m>p^2>x^{1/2}\ge y$" class="latex-inline" style="vertical-align: -4px" width="135" height="19">，从而内层的求和为零，因此对<img src="latex/latex2png-NumberTheory_115117036_-2.gif" alt="$S_1$" class="latex-inline" style="vertical-align: -2px" width="15" height="14">和<img src="latex/latex2png-NumberTheory_115051500_-2.gif" alt="$S_2$" class="latex-inline" style="vertical-align: -2px" width="15" height="14">可以考虑<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">为素数<img src="latex/latex2png-NumberTheory_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">的情形，且此时<img src="latex/latex2png-NumberTheory_224128039_-5.gif" alt="$\mu(m)=-1$" class="latex-inline" style="vertical-align: -5px" width="80" height="18">。</p>



<h3><a name="sec24" id="sec24"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_115117036_-2.gif" alt="$S_1$" class="latex-inline" style="vertical-align: -2px" width="15" height="14"></h3>

<p class="first">我们需要计算<img src="latex/latex2png-NumberTheory_129317080_.gif" alt="$$S_1=\sum_{x^{1/3}<p\le y}\,\sum_{p<q\le y}\phi\left(\frac{x}{pq},\pi(p)-1\right).$$" class="latex-display" width="580" height="50">注意到当<img src="latex/latex2png-NumberTheory_263432778_-4.gif" alt="$q>p>x^{1/3}$" class="latex-inline" style="vertical-align: -4px" width="90" height="19">时，<img src="latex/latex2png-NumberTheory_254518484_-15.gif" alt="$\dfrac{x}{pq}<x^{1/3}<p$" class="latex-inline" style="vertical-align: -15px" width="102" height="34">，故<img src="latex/latex2png-NumberTheory_160621567_-16.gif" alt="$\phi\left(\dfrac{x}{pq},\pi(p)-1\right)=1$" class="latex-inline" style="vertical-align: -16px" width="154" height="40">。由<img src="latex/latex2png-NumberTheory_135108710_-4.gif" alt="$x^{1/3}<p<q\le y$" class="latex-inline" style="vertical-align: -4px" width="121" height="19">可知<img src="latex/latex2png-NumberTheory_11270895_.gif" alt="$$S_1={\pi(y)-\pi(x^{1/3})\choose 2},$$" class="latex-display" width="580" height="42">可直接计算。</p>


<h3><a name="sec25" id="sec25"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_114985964_-3.gif" alt="$S_3$" class="latex-inline" style="vertical-align: -3px" width="15" height="15"></h3>

<p class="first">我们需要计算<img src="latex/latex2png-NumberTheory_36972343_.gif" alt="$$S_3=-\sum_{p\le x^{1/4}}\sum_{P^-(m)>p\atop m\le y<mp}\mu(m)\phi\left(\frac{x}{mp},\pi(p)-1\right).$$" class="latex-display" width="580" height="57">可以如下进行：首先用<img src="latex/latex2png-NumberTheory_43649608_0.gif" alt="$x^{1/4}$" class="latex-inline" style="vertical-align: 0px" width="29" height="15">以下的素数对<img src="latex/latex2png-NumberTheory_160373422_-9.gif" alt="$[1,\frac{x}{y}]$" class="latex-inline" style="vertical-align: -9px" width="34" height="22">进行一次筛法，每次用一个素数<img src="latex/latex2png-NumberTheory_238384148_-4.gif" alt="$p_k$" class="latex-inline" style="vertical-align: -4px" width="16" height="12">筛选过后，对所有<img src="latex/latex2png-NumberTheory_25526382_-9.gif" alt="$[\frac{y}{p},y]$" class="latex-inline" style="vertical-align: -9px" width="34" height="22">中的无平方因子且还没有被之前素数筛出的的<img src="latex/latex2png-NumberTheory_42431506_0.gif" alt="$m$" class="latex-inline" style="vertical-align: 0px" width="14" height="8">累加<img src="latex/latex2png-NumberTheory_224763961_-11.gif" alt="$\mu(m)\phi\left(\frac{x}{mp},\pi(p)-1\right)$" class="latex-inline" style="vertical-align: -11px" width="157" height="30">（这些值可在前面量的计算过程中进行保存）。由于<img src="latex/latex2png-NumberTheory_11297598_-4.gif" alt="$m\le y$" class="latex-inline" style="vertical-align: -4px" width="45" height="15">，<img src="latex/latex2png-NumberTheory_51825265_-4.gif" alt="$p\le x^{1/4}$" class="latex-inline" style="vertical-align: -4px" width="60" height="19">，计数过程的时间复杂度为<img src="latex/latex2png-NumberTheory_78522504_-5.gif" alt="$O(yx^{1/4})$" class="latex-inline" style="vertical-align: -5px" width="63" height="20">。</p>


<h3><a name="sec26" id="sec26"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_115051500_-2.gif" alt="$S_2$" class="latex-inline" style="vertical-align: -2px" width="15" height="14"></h3>

<p class="first">我们需要计算<img src="latex/latex2png-NumberTheory_72238027_.gif" alt="$$S_2=\sum_{x^{1/4}<p\le x^{1/3}}\,\sum_{p<q\le y}\phi\left(\frac{x}{pq},\pi(p)-1\right).$$" class="latex-display" width="580" height="50">注意到当<img src="latex/latex2png-NumberTheory_259050938_-15.gif" alt="$q>\dfrac{x}{p^2}$" class="latex-inline" style="vertical-align: -15px" width="48" height="34">时，有<img src="latex/latex2png-NumberTheory_102067857_-15.gif" alt="$\dfrac{x}{pq}<p$" class="latex-inline" style="vertical-align: -15px" width="49" height="34">，从而<img src="latex/latex2png-NumberTheory_103338079_-9.gif" alt="$\phi(\frac{x}{pq},\pi(p)-1)$" class="latex-inline" style="vertical-align: -9px" width="106" height="22">恒为1。从而可将内层的求和分为<img src="latex/latex2png-NumberTheory_259050938_-15.gif" alt="$q>\dfrac{x}{p^2}$" class="latex-inline" style="vertical-align: -15px" width="48" height="34">与<img src="latex/latex2png-NumberTheory_130515782_-15.gif" alt="$q\le\dfrac{x}{p^2}$" class="latex-inline" style="vertical-align: -15px" width="48" height="34">两段，记为<img src="latex/latex2png-NumberTheory_134942008_-2.gif" alt="$S_2=U+V$" class="latex-inline" style="vertical-align: -2px" width="85" height="14">。立即可知
<img src="latex/latex2png-NumberTheory_162462022_.gif" alt="
\begin{align*}
  U&=\sum_{x^{1/4}<p\le x^{1/3}}\#\{\text{素数}~q\mid \frac{x}{p^2}<q\le y\} \\
  &=\sum_{x^{1/4}<p\le x^{1/3}}\pi(y)-\pi(\frac{x}{p^2}).
\end{align*}
" class="latex-display" width="580" height="95">
由于<img src="latex/latex2png-NumberTheory_56326269_-15.gif" alt="$\dfrac{x}{p^2},y\le\sqrt{x}$" class="latex-inline" style="vertical-align: -15px" width="81" height="34">，因此可以通过完全筛法在<img src="latex/latex2png-NumberTheory_54423143_-5.gif" alt="$O(x^{1/2+\varepsilon})$" class="latex-inline" style="vertical-align: -5px" width="70" height="20">时间内求得<img src="latex/latex2png-NumberTheory_43480082_-1.gif" alt="$U$" class="latex-inline" style="vertical-align: -1px" width="12" height="13">。</p>


<h3><a name="sec27" id="sec27"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_43545618_-1.gif" alt="$V$" class="latex-inline" style="vertical-align: -1px" width="13" height="13"></h3>

<p class="first">此时有<img src="latex/latex2png-NumberTheory_28315716_-15.gif" alt="$q\le \dfrac{x}{p^2}$" class="latex-inline" style="vertical-align: -15px" width="48" height="34">，即<img src="latex/latex2png-NumberTheory_187352865_-15.gif" alt="$p\le\dfrac{x}{pq}<x^{1/2}<p^2$" class="latex-inline" style="vertical-align: -15px" width="140" height="34">，从而
<img src="latex/latex2png-NumberTheory_117851798_.gif" alt="
\begin{align*}
  \phi\left(\frac{x}{pq},\pi(p)-1\right)&=P_0\left(\frac{x}{pq},\pi(p)-1\right)+P_1\left(\frac{x}{pq},\pi(p)-1\right) \\
  &=1+\pi\left(\frac{x}{pq}\right)-(\pi(p)-1) \\
  &=2-\pi(p)+\pi\left(\frac{x}{pq}\right).
\end{align*}
" class="latex-display" width="580" height="133">
因此有
<img src="latex/latex2png-NumberTheory_12080318_.gif" alt="
\begin{align*}
  V&=\sum_{x^{1/4}<p\le x^{1/3}}\sum_{p<q\le y\atop q\le x/p^2}(2-\pi(p))+\sum_{x^{1/4}<p\le x^{1/3}}\sum_{p<q\le y\atop  q\le x/p^2}\pi\left(\frac{x}{pq}\right) \\
  &=:V_1+V_2.
\end{align*}
" class="latex-display" width="580" height="85">
由于<img src="latex/latex2png-NumberTheory_50776689_-4.gif" alt="$p\le x^{1/3}$" class="latex-inline" style="vertical-align: -4px" width="60" height="19">，<img src="latex/latex2png-NumberTheory_64785388_-2.gif" alt="$V_1$" class="latex-inline" style="vertical-align: -2px" width="16" height="14">可以通过之前的筛法结果直接求得。</p>


<h3><a name="sec28" id="sec28"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>计算<img src="latex/latex2png-NumberTheory_64719852_-2.gif" alt="$V_2$" class="latex-inline" style="vertical-align: -2px" width="16" height="14"></h3>


<p>我们需要计算<img src="latex/latex2png-NumberTheory_141581097_.gif" alt="$$V_2=\sum_{x^{1/4}<p\le x^{1/3}}\sum_{p<q\le y\atop  q\le x/p^2}\pi\left(\frac{x}{pq}\right).$$" class="latex-display" width="580" height="55">这里求和的项数非常之多，因此也是算法中最复杂的部分。首先简化关于<img src="latex/latex2png-NumberTheory_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">的两个限制，改写为<img src="latex/latex2png-NumberTheory_133015963_.gif" alt="$$V_2=\sum_{x^{1/4}<p<\sqrt{\frac{x}{y}}}\,\sum_{p<q\le y}\pi\left(\frac{x}{pq}\right)+\sum_{\sqrt{\frac{x}{y}}<p<x^{1/3}}\,\sum_{p<q\le y}\pi\left(\frac{x}{pq}\right).$$" class="latex-display" width="580" height="53">将内外层求和分为五段，分别记为（省去求和项）
<img src="latex/latex2png-NumberTheory_129988487_.gif" alt="
\begin{align*}
  W_1&=\sum_{x^{1/4}<p\le\frac{x}{y^2}}\ \sum_{p<q\le y}, \\
  W_2&=\sum_{\frac{x}{y^2}<p\le\sqrt{\frac{x}{y}}}\ \sum_{p<q\le\sqrt{\frac{x}{p}}}, \\
  W_3&=\sum_{\frac{x}{y^2}<p\le\sqrt{\frac{x}{y}}}\ \sum_{\sqrt{\frac{x}{p}}<q\le y}, \\
  W_4&=\sum_{\frac{x}{y^2}<p\le x^{1/3}}\ \sum_{p<q\le\sqrt{\frac{x}{p}}}, \\
  W_5&=\sum_{\frac{x}{y^2}<p\le x^{1/3}}\ \sum_{\sqrt{\frac{x}{p}}<q\le \frac{x}{p^2}}.
\end{align*}
" class="latex-display" width="580" height="271"></p>

<p><img src="latex/latex2png-NumberTheory_48008172_-2.gif" alt="$W_1$" class="latex-inline" style="vertical-align: -2px" width="22" height="14">，<img src="latex/latex2png-NumberTheory_47942636_-2.gif" alt="$W_2$" class="latex-inline" style="vertical-align: -2px" width="22" height="14">中的求和项满足<img src="latex/latex2png-NumberTheory_37600244_-9.gif" alt="$y<\frac{x}{pq}<x^{1/2}$" class="latex-inline" style="vertical-align: -9px" width="99" height="24">，可以通过的筛法结果进行计算，而<img src="latex/latex2png-NumberTheory_47877100_-3.gif" alt="$W_3$" class="latex-inline" style="vertical-align: -3px" width="22" height="15">，<img src="latex/latex2png-NumberTheory_47811564_-2.gif" alt="$W_4$" class="latex-inline" style="vertical-align: -2px" width="22" height="14">，<img src="latex/latex2png-NumberTheory_47746028_-3.gif" alt="$W_5$" class="latex-inline" style="vertical-align: -3px" width="22" height="15">只能“老老实实”地通过求和进行计算了。由于<img src="latex/latex2png-NumberTheory_47877100_-3.gif" alt="$W_3$" class="latex-inline" style="vertical-align: -3px" width="22" height="15">与<img src="latex/latex2png-NumberTheory_47746028_-3.gif" alt="$W_5$" class="latex-inline" style="vertical-align: -3px" width="22" height="15">中当固定<img src="latex/latex2png-NumberTheory_42628114_-4.gif" alt="$p$" class="latex-inline" style="vertical-align: -4px" width="9" height="12">遍历时<img src="latex/latex2png-NumberTheory_156792533_-11.gif" alt="$\pi\left(\frac{x}{pq}\right)$" class="latex-inline" style="vertical-align: -11px" width="47" height="30">变化不大，因此可以做一个略微的改进：通过查表来确定下一个<img src="latex/latex2png-NumberTheory_156792533_-11.gif" alt="$\pi\left(\frac{x}{pq}\right)$" class="latex-inline" style="vertical-align: -11px" width="47" height="30">值改变的<img src="latex/latex2png-NumberTheory_42693650_-4.gif" alt="$q$" class="latex-inline" style="vertical-align: -4px" width="8" height="12">，从而减小计算量。至此我们已经得到了计算<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">的完整算法。</p>

<div class="remark">
<span class="proof-header">注32<a name=""></a></span><span class="theorem-name"></span>
1987年Lagarias和Odlyzko<span class="cite"><a class="cite" href="NumberTheory.html#ref-15" name="cite-15">[15]</a></span>提出了完全不同的分析方法来计算<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">，方法基于对Riemann <img src="latex/latex2png-NumberTheory_33257139_-4.gif" alt="$\zeta$" class="latex-inline" style="vertical-align: -4px" width="8" height="16">函数的积分变换的数值积分，其中一个版本的算法需要<img src="latex/latex2png-NumberTheory_54291303_-5.gif" alt="$O(x^{3/5+\varepsilon})$" class="latex-inline" style="vertical-align: -5px" width="70" height="20">时间与<img src="latex/latex2png-NumberTheory_41592572_-5.gif" alt="$O(x^{\varepsilon})$" class="latex-inline" style="vertical-align: -5px" width="40" height="18">空间，另一个版本的算法需要<img src="latex/latex2png-NumberTheory_54423143_-5.gif" alt="$O(x^{1/2+\varepsilon})$" class="latex-inline" style="vertical-align: -5px" width="70" height="20">时间与<img src="latex/latex2png-NumberTheory_54422631_-5.gif" alt="$O(x^{1/4+\varepsilon})$" class="latex-inline" style="vertical-align: -5px" width="70" height="20">空间。但目前为止还没有被真正实现，并且估计在<img src="latex/latex2png-NumberTheory_80341109_-1.gif" alt="$10^{17}$" class="latex-inline" style="vertical-align: -1px" width="28" height="15">以下还是要比Lagarias-Miller-Odlyzko方法慢。


</div>

<div class="remark">
<span class="proof-header">注33<a name=""></a></span><span class="theorem-name"></span>
Gourdon<span class="cite"><a class="cite" href="NumberTheory.html#ref-16" name="cite-16">[16]</a></span>在2001年提出了一个新的改进方法（主要是针对<img src="latex/latex2png-NumberTheory_64719852_-2.gif" alt="$V_2$" class="latex-inline" style="vertical-align: -2px" width="16" height="14">的计算），并给出了可行的并行化算法。


</div>




<h2><a name="sec29" id="sec29"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>第<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">个素数<img src="latex/latex2png-NumberTheory_238580756_-4.gif" alt="$p_n$" class="latex-inline" style="vertical-align: -4px" width="17" height="12"></h2>

<p class="first">相对对给定的数进行素性判定来说，给出第<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">个素数是更为困难的事情，对于很大的<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">来说，纯粹使用素性检测挨个找素数，或者利用筛法找出所有素数，都不切实际。不过我们已经知道<img src="latex/latex2png-NumberTheory_57958882_-5.gif" alt="$\pi(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">如何计算，而<img src="latex/latex2png-NumberTheory_238580756_-4.gif" alt="$p_n$" class="latex-inline" style="vertical-align: -4px" width="17" height="12">在某种意义上是<img src="latex/latex2png-NumberTheory_57958882_-5.gif" alt="$\pi(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">的“反函数”（<img src="latex/latex2png-NumberTheory_148590347_-5.gif" alt="$\pi(p_n)=n$" class="latex-inline" style="vertical-align: -5px" width="73" height="18">，<img src="latex/latex2png-NumberTheory_229193731_-6.gif" alt="$p_{\pi(n)}=n$" class="latex-inline" style="vertical-align: -6px" width="69" height="14">），我们利用这一点可以反过来计算<img src="latex/latex2png-NumberTheory_238580756_-4.gif" alt="$p_n$" class="latex-inline" style="vertical-align: -4px" width="17" height="12">。</p>

<p>Lehmer<span class="cite"><a class="cite" href="NumberTheory.html#ref-17" name="cite-17">[17]</a></span>提出了一个一般的求此类“逆函数”的算法，他考虑迭代<img src="latex/latex2png-NumberTheory_210955260_.gif" alt="$$S_k=S_{k-1}+n-\pi(S_{k-1}),$$" class="latex-display" width="580" height="18">取适当的初值<img src="latex/latex2png-NumberTheory_102610462_-5.gif" alt="$S_0<\pi(n)$" class="latex-inline" style="vertical-align: -5px" width="70" height="18">，容易看出<img src="latex/latex2png-NumberTheory_113937388_-2.gif" alt="$S_k$" class="latex-inline" style="vertical-align: -2px" width="16" height="14">严格单调递增，直到<img src="latex/latex2png-NumberTheory_102688542_-5.gif" alt="$S_k=\pi(n)$" class="latex-inline" style="vertical-align: -5px" width="71" height="18">后恒为常数。然而此迭代过程收敛过慢，例如求<img src="latex/latex2png-NumberTheory_53648562_-1.gif" alt="$n=1000$" class="latex-inline" style="vertical-align: -1px" width="64" height="12">时的<img src="latex/latex2png-NumberTheory_208951218_-4.gif" alt="$p_n=7919$" class="latex-inline" style="vertical-align: -4px" width="73" height="16">，取<img src="latex/latex2png-NumberTheory_56362578_-3.gif" alt="$S_0=7000$" class="latex-inline" style="vertical-align: -3px" width="71" height="15">仍需要49步迭代。</p>

<p>我们可以考虑二分搜索的办法，估计一个区间范围<img src="latex/latex2png-NumberTheory_35152_-5.gif" alt="$[a,b]$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">使得<img src="latex/latex2png-NumberTheory_238580756_-4.gif" alt="$p_n$" class="latex-inline" style="vertical-align: -4px" width="17" height="12">落在其中，（可通过计算<img src="latex/latex2png-NumberTheory_54020528_-5.gif" alt="$\pi(a)\le n\le\pi(b)$" class="latex-inline" style="vertical-align: -5px" width="114" height="18">来确证）。然后二分区间<img src="latex/latex2png-NumberTheory_35152_-5.gif" alt="$[a,b]$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">为<img src="latex/latex2png-NumberTheory_126465812_-6.gif" alt="$[a,\lfloor\frac{a+b}{2}\rfloor]$" class="latex-inline" style="vertical-align: -6px" width="64" height="21">，<img src="latex/latex2png-NumberTheory_70790570_-6.gif" alt="$[\lfloor\frac{a+b}{2}\rfloor,b]$" class="latex-inline" style="vertical-align: -6px" width="63" height="21">，并计算<img src="latex/latex2png-NumberTheory_127289752_-6.gif" alt="$\pi(\lfloor\frac{a+b}{2}\rfloor)$" class="latex-inline" style="vertical-align: -6px" width="63" height="21">判断<img src="latex/latex2png-NumberTheory_238580756_-4.gif" alt="$p_n$" class="latex-inline" style="vertical-align: -4px" width="17" height="12">落在哪一个自区间中，如此续行，最终搜索出<img src="latex/latex2png-NumberTheory_238580756_-4.gif" alt="$p_n$" class="latex-inline" style="vertical-align: -4px" width="17" height="12">的位置。</p>


<h2><a name="sec30" id="sec30"></a>
<a href="NumberTheory.html#top" class="toplink"><img src="../images/top.gif" border="0" alt="回到顶部" width="40" height="15"></a>M&ouml;bius函数<img src="latex/latex2png-NumberTheory_57958885_-5.gif" alt="$\mu(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">和Euler函数<img src="latex/latex2png-NumberTheory_110973654_-5.gif" alt="$\varphi(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18"></h2>

<p class="first">M&ouml;bius函数<img src="latex/latex2png-NumberTheory_57958885_-5.gif" alt="$\mu(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">和Euler函数<img src="latex/latex2png-NumberTheory_110973654_-5.gif" alt="$\varphi(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">均为重要的数论函数。M&ouml;bius函数定义为
<img src="latex/latex2png-NumberTheory_61266492_.gif" alt="
\begin{equation*}
  \mu(n)=
  \begin{cases}
    0 & \text{若}~n~\text{有平方因子}, \\
    1 & \text{若}~n=1, \\
    (-1)^k & \text{若}~n~\text{为}~k~\text{个不同素因子的乘积}.
  \end{cases}
\end{equation*}
" class="latex-display" width="580" height="90">
Euler函数定义为<img src="latex/latex2png-NumberTheory_134282866_.gif" alt="$$\varphi(n)=n\prod_{p\mid n}(1-\frac{1}{p}).$$" class="latex-display" width="580" height="45"></p>

<p>可以用类似于计算<img src="latex/latex2png-NumberTheory_47473122_-5.gif" alt="$\pi(x)$" class="latex-inline" style="vertical-align: -5px" width="30" height="18">的方法计算<img src="latex/latex2png-NumberTheory_7480304_-15.gif" alt="$M(n)=\sum\limits_{k=1}^n\mu(k)$" class="latex-inline" style="vertical-align: -15px" width="120" height="36">，从而反求出<img src="latex/latex2png-NumberTheory_57958885_-5.gif" alt="$\mu(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18"><span class="cite"><a class="cite" href="NumberTheory.html#ref-18" name="cite-18">[18]</a></span>。这种组合方法的时间复杂度为<img src="latex/latex2png-NumberTheory_54357351_-5.gif" alt="$O(x^{2/3+\varepsilon})$" class="latex-inline" style="vertical-align: -5px" width="70" height="20">，但实践中未必比直接对<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">分解根据定义计算更优，因为就算<img src="latex/latex2png-NumberTheory_42497042_0.gif" alt="$n$" class="latex-inline" style="vertical-align: 0px" width="10" height="8">很大（例如<img src="latex/latex2png-NumberTheory_92244085_-1.gif" alt="$>10^{20}$" class="latex-inline" style="vertical-align: -1px" width="46" height="15">），往往也有机会可以快速地分解，然而组合方法则由于规模太大而无法使用。</p>

<p>对于Euler函数，我们熟知理论上重要的反演公式<img src="latex/latex2png-NumberTheory_14543002_.gif" alt="$$\varphi(n)=\sum_{d\mid n}\mu(d)\cdot\frac{n}{d},$$" class="latex-display" width="580" height="42">但同样无法直接用于<img src="latex/latex2png-NumberTheory_110973654_-5.gif" alt="$\varphi(n)$" class="latex-inline" style="vertical-align: -5px" width="31" height="18">的计算。实践中宜直接采取分解并根据定义计算的方法。</p>



<h4 class="ref">参考文献</h4><p class="ref"><a class="ref" href="NumberTheory.html#cite-1" name="ref-1">[1]</a><span class="ref-author">Henri Cohen, </span><span class="ref-title">A Course in Computational Algebraic Number Theory, </span><span class="ref-publisher">Springer Verlag, </span><span class="ref-year">1993. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-2" name="ref-2">[2]</a><span class="ref-author">Daniel M. Gordon, </span><span class="ref-title">A survey of fast exponentiation methods, </span><span class="ref-journal">Journal of Algorithms </span><span class="ref-volume">27 </span><span class="ref-year">(1998), </span><span class="ref-number">no.1, </span><span class="ref-pages">129 - 146. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-3" name="ref-3">[3]</a><span class="ref-author">Donald E. Knuth, </span><span class="ref-title">The art of computer programming, volume 2 (3rd ed.): seminumerical algorithms, </span><span class="ref-publisher">Addison-Wesley Longman Publishing Co., Inc., </span><span class="ref-address">Boston, MA, USA, </span><span class="ref-year">1997. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-4" name="ref-4">[4]</a><span class="ref-author">Jurjen Bos and Matthijs Coster, </span><span class="ref-title">Addition chain heuristics, </span><span class="ref-booktitle">Advances in Cryptology - Proceedings of Crypto '89, </span><span class="ref-volume">435 </span><span class="ref-publisher">Springer-Verlag, </span><span class="ref-year">1990, </span><span class="ref-pages">400 - 407. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-5" name="ref-5">[5]</a><span class="ref-author">Peter L. Montgomery, </span><span class="ref-title">Modular Multiplication Without Trial Division, </span><span class="ref-journal">Mathematics of Computation </span><span class="ref-volume">44 </span><span class="ref-year">(1985), </span><span class="ref-number">no.170, </span><span class="ref-pages">519-521. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-6" name="ref-6">[6]</a><span class="ref-author">Seong-min Hong and Sang-yeop Oh and Hyunsoo Yoon, </span><span class="ref-title">New modular multiplication algorithms for fast modular exponentiation, </span><span class="ref-booktitle">Advances in Cryptology—Proceedings of Eurocrypt '96, </span><span class="ref-series">Lecture Notes in Computer Science, </span><span class="ref-volume">1070 </span><span class="ref-publisher">Springer Berlin / Heidelberg, </span><span class="ref-year">1996, </span><span class="ref-pages">166 - 177. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-7" name="ref-7">[7]</a><span class="ref-author">T. Jebelean, </span><span class="ref-title">A generalization of the binary GCD algorithm, </span><span class="ref-journal">Proceedings of the 1993 international symposium on Symbolic and algebraic computation  </span><span class="ref-year">(1993), </span><span class="ref-pages">111-116. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-8" name="ref-8">[8]</a><span class="ref-author">Kenneth Weber, </span><span class="ref-title">The accelerated integer GCD algorithm, </span><span class="ref-journal">ACM Transactions on Mathematical Software </span><span class="ref-volume">21 </span><span class="ref-year">(1995), </span><span class="ref-number">no.1, </span><span class="ref-pages">111-122. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-9" name="ref-9">[9]</a><span class="ref-author">Jonathan Sorenson, </span><span class="ref-title">Two fast GCD algorithms, </span><span class="ref-journal">Journal of Algorithms </span><span class="ref-volume">16 </span><span class="ref-year">(1994), </span><span class="ref-number">no.1, </span><span class="ref-pages">110-144. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-10" name="ref-10">[10]</a><span class="ref-author">Sidi Mohamed Sedjelmaci, </span><span class="ref-title">Jebelean--Weber's algorithm without spurious factors, </span><span class="ref-journal">Information Processing Letters </span><span class="ref-volume">102 </span><span class="ref-year">(2007), </span><span class="ref-number">no.6, </span><span class="ref-pages">247-252. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-11" name="ref-11">[11]</a><span class="ref-author">Evelyn Frank, </span><span class="ref-title">On continued fraction expansions for binomial quadratic surds. III, </span><span class="ref-journal">Numerische Mathematik </span><span class="ref-volume">5 </span><span class="ref-year">(1963), </span><span class="ref-number">no.1, </span><span class="ref-pages">113-117. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-12" name="ref-12">[12]</a><span class="ref-author">Mend&egrave;s France M. and  Tenenbaum G.著 姚家燕 译, </span><span class="ref-title-chs">素数论, </span><span class="ref-publisher">清华大学出版社, </span><span class="ref-address">北京, </span><span class="ref-year">2007. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-13" name="ref-13">[13]</a><span class="ref-author">J.C. Lagaria and V.S. Miller and A.M. Odlyzko, </span><span class="ref-title">Computing $\pi(x)$: The Meissel-Lehmer Method, </span><span class="ref-journal">Mathematics of Computation </span><span class="ref-volume">44 </span><span class="ref-year">(1985), </span><span class="ref-number">no.170, </span><span class="ref-pages">537-560. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-14" name="ref-14">[14]</a><span class="ref-author">M. Deleglise and J. Rivat, </span><span class="ref-title">Computing $\pi(x)$: The Meissel, Lehmer, Lagarias, Miller, Odlyzko Method, </span><span class="ref-journal">Mathematics of Computation </span><span class="ref-volume">65 </span><span class="ref-year">(1996), </span><span class="ref-number">no.213, </span><span class="ref-pages">235-245. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-15" name="ref-15">[15]</a><span class="ref-author">J.C. Lagarias and A.M. Odlyzko, </span><span class="ref-title">Computing $\pi(x)$: An Analytic Method, </span><span class="ref-journal">Journal of Algorithms </span><span class="ref-volume">8 </span><span class="ref-year">(1987), </span><span class="ref-number">no.2, </span><span class="ref-pages">173-191. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-16" name="ref-16">[16]</a><span class="ref-author">X. Gourdon, </span><span class="ref-title">Computation of $\ pi(x)$ : improvements to the Meissel, Lehmer, Lagarias, Miller, Odlyzko, Deleglise and Rivat method, </span><span class="ref-journal">http://numbers.computation.free.fr/Constants/Primes/Pix/piNalgorithm.ps </span><span class="ref-year">(2001). </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-17" name="ref-17">[17]</a><span class="ref-author">D. H. Lehmer, </span><span class="ref-title">An inversive algorithm, </span><span class="ref-journal">Bulletin of the American Mathematical Society </span><span class="ref-volume">38 </span><span class="ref-year">(1932), </span><span class="ref-number">no.10, </span><span class="ref-pages">693-694. </span></p>
<p class="ref"><a class="ref" href="NumberTheory.html#cite-18" name="ref-18">[18]</a><span class="ref-author">M. Del&eacute;glise and J. Rivat, </span><span class="ref-title">Computing the summation of the M&ouml;bius function, </span><span class="ref-journal">Experimental Mathematics </span><span class="ref-volume">5 </span><span class="ref-year">(1996), </span><span class="ref-number">no.4, </span><span class="ref-pages">291-295. </span></p>
<!-- Page published by Emacs Muse ends here -->
      </div><!-- page -->
    </div><!-- left -->
    <div id="bottomshadow"></div><!-- bottom -->
  </div><!-- body -->
  <div id="links">
    <h4>文档列表</h4>
<a href="Arithmetic.html">高精度运算</a>
<a href="PrimeTest.html">素数判定</a>
<a href="IntegerFactorization.html">整数因子分解</a>
<a href="NumberTheory.html">基础数论算法</a>
<a href="Constant.html">数学常数</a>
<a href="ElementaryFunction.html">初等函数</a>
<a href="BasicConceptsNLA.html">数值线性代数基础</a>
<a href="MatrixMultiplication.html">矩阵乘法</a>
<a href="GaussElimination.html">线性方程组与Gauss消元法</a>
<a href="SpecialLinearEquation.html">特殊线形方程组</a>
<a href="QRLS.html">正交化与最小二乘法</a>
<a href="EigenvalueProblem.html">非对称特征值问题</a>
<a href="SymmetricEigenvalueProblem.html">对称特征值问题</a>
<a href="MatrixFunction.html">矩阵函数</a>
<a href="IterationMethods.html">稀疏矩阵中的迭代法</a>
<a href="ExactLinearAlgebra.html">精确线性代数</a>
<a href="PolyEval.html">一元多项式求值和插值</a>
<a href="PolyGCD.html">一元多项式的最大公因子</a>
<a href="PolyFacZp.html">多项式因子分解(有限域)</a>
<a href="PolyFacZ.html">多项式因子分解(Z[x])</a>
<a href="MultiPoly.html">多元多项式最大公因子及因子分解</a>
<a href="FindRoot.html">一元代数方程求解</a>
<a href="EqSolving.html">代数方程组求解</a>
<a href="Summation.html">符号求和</a>
<a href="Integration.html">符号积分</a>
<a href="DifferentialEquation.html">微分方程符号解</a>
  </div><!-- links -->
    <div class="navfoot">
      <hr>
      <table width="100%" border="0" summary="Footer navigation">
	<tr>
	  <td width="33%" align="left">
	    <span class="footdate">最后更新：
			2009年03月18日 16:51:08
		</span>
	  </td>
	  <td width="34%" align="center">
	    <span class="foothome">
	      <a href="../index.html">返回主页</a> / <a href="../RecentChanges.html">更新记录</a> /  <a href="http://cn.creativecommons.org/index.php/licenses/licenses_exp">许可协议</a>
	    </span>
	  </td>
	  <td width="33%" align="right">
	    <span class="footcopy">Copyright &copy; 2007,2008 <a href="../JoinUs.html#contact">maTH&mu; Project Group</a></span>
	  </td>
	</tr>
      </table>
  </div><!-- nav -->
</div><!-- container -->
<p align="center">
<script language="javascript" type="text/javascript" src="http://js.users.51.la/2320853.js"></script></p>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-6285506-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
  </body>
</html>