<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>14.4. Buses, Devices, and Drivers</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-14-sect-4"></a>
<H3 class="docSection1Title">14.4. Buses, Devices, and Drivers</H3>

<p class="docText">So far, we have seen a great deal of low-level infrastructures and a
relative shortage of examples. We try to make up for that in the rest
of this chapter as we get into the higher levels of the Linux device
model. To that end, we introduce a new virtual bus, which we call
<span class="docEmphasis">lddbus</span>,<sup class="docFootnote"><a class="docLink" href="chp-14-sect-4.shtml#chp-14-FNOTE-1">[1]</a></sup> and modify the
<span class="docEmphasis">scullp</span> driver to
"connect" to that bus.</p><blockquote><p class="docFootnote"><sup><a name="chp-14-FNOTE-1">[1]</a></sup> The logical name for
this bus, of course, would have been
"sbus," but that name was already
taken by a real, physical bus.</p></blockquote>

<p class="docText">Once again, much of the material covered here will never be needed by
many driver authors. Details at this level are generally handled at
the bus level, and few authors need to add a new bus type. This
information is useful, however, for anybody wondering what is
happening inside the PCI, USB, etc. layers or who needs to make
changes at that level.</p>

<a name="chp-14-sect-4.1"></a>
<h4 class="docSection2Title">14.4.1. Buses</H4>

<p class="docText">A bus is a channel <a name="chp-14-ITERM-6705"></a> <a name="chp-14-ITERM-6706"></a>
<a name="chp-14-ITERM-6707"></a> <a name="chp-14-ITERM-6708"></a>
<a name="chp-14-ITERM-6709"></a>between the processor and one or
more devices. For the purposes of the device model, all devices are
connected via a bus, even if it is an internal, virtual,
"platform" bus. Buses can plug into
each other—a USB controller is usually a PCI device, for
example. The device model represents the actual connections between
buses and the devices they control.</p>

<p class="docText">In the Linux device model, a bus is represented by the
<tt>bus_type</tt><a name="chp-14-ITERM-6710"></a>
<a name="chp-14-ITERM-6711"></a>
structure, defined in <i>&lt;linux/device.h&gt;</I>.
This structure looks like:</p>

<pre>struct bus_type {
    char *name;
    struct subsystem subsys;
    struct kset drivers;
    struct kset devices;
    int (*match)(struct device *dev, struct device_driver *drv);
    struct device *(*add)(struct device * parent, char * bus_id);
    int (*hotplug) (struct device *dev, char **envp, 
                    int num_envp, char *buffer, int buffer_size);
    /* Some fields omitted */
};</pre><br>


<p class="docText">The <tt>name</tt><a name="chp-14-ITERM-6712"></a> field is the name of the bus, something
such as <tt>pci</tt>. You can see from the structure that
each bus is its own subsystem; these subsystems do not live at the
top level in sysfs, however. Instead, they are found underneath the
<tt>bus</tt> subsystem. A bus contains two ksets,
representing the known drivers for that bus and all devices plugged
into the bus. Then, there is a set of methods that we will get to
shortly.</P>

<a name="chp-14-sect-4.1.1"></a>
<h5 class="docSection3Title">14.4.1.1 Bus registration</H5>

<p class="docText">As we mentioned,
the<a name="chp-14-ITERM-6713"></a>
<a name="chp-14-ITERM-6714"></a>
example source includes a virtual bus implementation called
<span class="docEmphasis">lddbus</span>. This bus sets up its
<tt>bus_type</tt> structure as follows:</p>

<pre>struct bus_type ldd_bus_type = {
    .name = "ldd",
    .match = ldd_match,
    .hotplug  = ldd_hotplug,
};</pre><br>


<p class="docText">Note that very few of the <tt>bus_type</tt> fields require
initialization; most of that is handled by the device model core. We
do have to specify the name of the bus, however, and any methods that
go along with it.</p>

<p class="docText">Inevitably, a new bus must be registered with the system via a call
to <span class="docEmphasis">bus_register</span><a name="chp-14-ITERM-6715"></a>
<a name="chp-14-ITERM-6716"></a>.
The <span class="docEmphasis">lddbus</span> code does so in this way:</p>

<pre>ret = bus_register(&amp;ldd_bus_type);
if (ret)
    return ret;</pre><br>


<p class="docText">This call can fail, of course, so the return value must always be
checked. If it succeeds, the new bus subsystem has been added to the
system; it is visible in sysfs under <i>/sys/bus</i>,
and it is possible to start adding devices.</p>

<p class="docText">Should it be necessary to remove a bus from the system (when the
associated module is removed, for example),
<span class="docEmphasis">bus_unregister</span> should be called:</p>

<pre>void bus_unregister(struct bus_type *bus);</pre><br>




<a name="chp-14-sect-4.1.2"></a>
<h5 class="docSection3Title">14.4.1.2 Bus methods</h5>

<p class="docText">There are several methods
<a name="chp-14-ITERM-6717"></a>
<a name="chp-14-ITERM-6718"></a>
<a name="chp-14-ITERM-6719"></a>defined
for the <tt>bus_type</tt> structure; they allow the bus
code to serve as an intermediary between the device core and
individual drivers. The methods defined in the 2.6.10 kernel are:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*match)(struct device *device, struct device_driver *driver);</span></span></span></dt></P>
<dd>
<p class="docList">This method is called, perhaps multiple times, whenever a new device
or driver is added for this bus. It should return a nonzero value if
the given <tt>device</tt> can be handled by the given
<tt>driver</tt>. (We get to the details of the
<tt>device</tt> and <tt>device_driver</tt>
structures shortly). This function must be handled at the bus level,
because that is where the proper logic exists; the core kernel cannot
know how to match devices and drivers for every possible bus type.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*hotplug) (struct device *device, char **envp, int num_envp, char</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">*buffer, int buffer_size);</span></span></span></dt></P>
<dd>
<p class="docList">This method allows the bus to add variables to the environment prior
to the generation of a hotplug event in user space. The parameters
are the same as for the kset <span class="docEmphasis">hotplug</span> method
(described in the earlier <a class="docLink" href="chp-14-sect-3.shtml#chp-14-sect-3">Section 14.3</a>).</P>
</dd>
</dl>

<p class="docText">The<a name="chp-14-ITERM-6720"></a>
<a name="chp-14-ITERM-6721"></a>
<span class="docEmphasis">lddbus</span> driver has a very simple
<span class="docEmphasis">match</span><a name="chp-14-ITERM-6722"></a>
<a name="chp-14-ITERM-6723"></a>
<a name="chp-14-ITERM-6724"></a> function, which simply compares the
driver and device names:</P>

<pre>static int ldd_match(struct device *dev, struct device_driver *driver)
{
    return !strncmp(dev-&gt;bus_id, driver-&gt;name, strlen(driver-&gt;name));
}</pre><br>


<p class="docText">When real hardware is involved, the <span class="docEmphasis">match</span>
function usually makes some sort of comparison between the hardware
ID provided by the device itself and the IDs supported by the driver.</p>

<p class="docText">The <span class="docEmphasis">lddbus</span> <span class="docEmphasis">hotplug</span> method
looks like this:</p>

<pre>static int ldd_hotplug(struct device *dev, char **envp, int num_envp,
        char *buffer, int buffer_size)
{
    envp[0] = buffer;
    if (snprintf(buffer, buffer_size, "LDDBUS_VERSION=%s",
                Version) &gt;= buffer_size)
        return -ENOMEM;
    envp[1] = NULL;
    return 0;
}</pre><br>


<p class="docText">Here, we add in the current revision number of the
<span class="docEmphasis">lddbus</span> source, just in case anybody is curious.</P>



<a name="chp-14-sect-4.1.3"></a>
<H5 class="docSection3Title">14.4.1.3 Iterating over devices and drivers</H5>

<p class="docText">If you are writing bus-level code, <a name="chp-14-ITERM-6725"></a>
<a name="chp-14-ITERM-6726"></a>
<a name="chp-14-ITERM-6727"></a>
<a name="chp-14-ITERM-6728"></a>you
may find yourself having to perform some operation on all devices or
drivers that have been registered with your bus. It may be tempting
to dig directly into the structures in the
<tt>bus_type</tt> structure, but it is better to use the
helper functions that have been provided.</p>

<p class="docText">To operate on every device known to the bus, use:</P>

<pre>int bus_for_each_dev(struct bus_type *bus, struct device *start, 
                     void *data, int (*fn)(struct device *, void *));</pre><BR>


<p class="docText">This function iterates over every device on <tt>bus</tt>,
passing the associated <tt>device</tt> structure to
<tt>fn</tt>, along with the value passed in as
<tt>data</tt>. If <tt>start</tt> is
<tt>NULL</tt>, the iteration begins with the first device
on the bus; otherwise iteration starts with the first device after
<tt>start</tt>. If <tt>fn</tt> returns a nonzero
value, iteration stops and that value is returned from
<span class="docEmphasis">bus_for_each_dev</span><a name="chp-14-ITERM-6729"></a>
<a name="chp-14-ITERM-6730"></a>.</p>

<p class="docText">There is a similar function for iterating over drivers:</p>

<pre>int bus_for_each_drv(struct bus_type *bus, struct device_driver *start, 
                     void *data, int (*fn)(struct device_driver *, void *));</pre><br>


<p class="docText">This function works just like <span class="docEmphasis">bus_for_each_dev</span>,
except, of course, that it works with drivers instead.</p>

<p class="docText">It should be noted that both of these functions hold the bus
subsystem's reader/writer semaphore for the duration
of the work. So an attempt to use the two of them together will
deadlock—each will be trying to obtain the same semaphore.
Operations that modify the bus (such as unregistering devices) will
also lock up. So, use the <span class="docEmphasis">bus_for_each</span> functions
with some care.</P>



<a name="chp-14-sect-4.1.4"></a>
<h5 class="docSection3Title">14.4.1.4 Bus attributes</h5>

<p class="docText">Almost every layer in the Linux
<a name="chp-14-ITERM-6731"></a>
<a name="chp-14-ITERM-6732"></a>device
model provides an interface for the addition of attributes, and the
bus layer is no exception. The
<tt>bus_attribute</tt><a name="chp-14-ITERM-6733"></a>
<a name="chp-14-ITERM-6734"></a>
type is defined in <I>&lt;linux/device.h&gt;</i> as
follows:</p>

<pre>struct bus_attribute {
    struct attribute attr;
    ssize_t (*show)(struct bus_type *bus, char *buf);
    ssize_t (*store)(struct bus_type *bus, const char *buf, 
                     size_t count);
};</pre><BR>


<p class="docText">We have already seen <tt>struct</tt>
<tt>attribute</tt> in <a class="docLink" href="chp-14-sect-2.shtml#chp-14-sect-2.1">Section 14.2.1</a>. The <tt>bus_attribute</tt>
type also includes two methods for displaying and setting the value
of the attribute. Most device model layers above the kobject level
work this way.</p>

<p class="docText">A convenience macro has been provided for the compile-time creation
and initialization of <tt>bus_attribute</tt> structures:</P>

<a name="chp-14-ITERM-6735"></a><a name="chp-14-ITERM-6736"></a><pre>BUS_ATTR(name, mode, show, store);</pre><br>


<p class="docText">This macro declares a structure, generating its name by prepending
the string <tt>bus_attr_</tt> to the given
<tt>name</tt>.</p>

<p class="docText">Any attributes belonging to a bus should be created explicitly with
<span class="docEmphasis">bus_create_file</span>:</p>

<pre>int bus_create_file(struct bus_type *bus, struct bus_attribute *attr);</pre><br>


<p class="docText">Attributes can also
be<a name="chp-14-ITERM-6737"></a>
<a name="chp-14-ITERM-6738"></a>
removed with:</p>

<pre>void bus_remove_file(struct bus_type *bus, struct bus_attribute *attr);</pre><br>


<p class="docText">The <span class="docEmphasis">lddbus</span> driver creates a simple attribute
file containing, once again, the source version number. The
<span class="docEmphasis">show</span> method and <tt>bus_attribute</tt>
structure are set up as follows:</p>

<pre>static ssize_t show_bus_version(struct bus_type *bus, char *buf)
{
    return snprintf(buf, PAGE_SIZE, "%s\n", Version);
}

static BUS_ATTR(version, S_IRUGO, show_bus_version, NULL);</pre><br>


<p class="docText">Creating the attribute file is done at module load time:</p>

<pre>if (bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version))
    printk(KERN_NOTICE "Unable to create version attribute\n");</pre><br>


<p class="docText">This call creates an<a name="chp-14-ITERM-6739"></a> <a name="chp-14-ITERM-6740"></a> <a name="chp-14-ITERM-6741"></a> <a name="chp-14-ITERM-6742"></a> <a name="chp-14-ITERM-6743"></a> attribute file
(<i>/sys/bus/ldd/version</i>) containing the revision
number for the <span class="docEmphasis">lddbus</span> code.</p>



<a name="chp-14-sect-4.2"></a>
<H4 class="docSection2Title">14.4.2. Devices</h4>

<p class="docText">At the lowest level, every device<a name="chp-14-ITERM-6744"></a> <a name="chp-14-ITERM-6745"></a> <a name="chp-14-ITERM-6746"></a>
<a name="chp-14-ITERM-6747"></a> in a
Linux system is represented by an instance of <tt>struct
device</tt>:</P>

<pre>struct device {
    struct device *parent;
    struct kobject kobj;
    char bus_id[BUS_ID_SIZE];
    struct bus_type *bus;
    struct device_driver *driver;
    void *driver_data;
    void (*release)(struct device *dev);
    /* Several fields omitted */
};</pre><BR>


<p class="docText">There are many other <tt>struct
device</tt><a name="chp-14-ITERM-6748"></a> fields that are of interest only to the
device core code. These fields, however, are worth knowing about:</p>

<a name="chp-14-ITERM-6749"></a><a name="chp-14-ITERM-6750"></a><a name="chp-14-ITERM-6751"></a><a name="chp-14-ITERM-6752"></a><a name="chp-14-ITERM-6753"></a><a name="chp-14-ITERM-6754"></a><a name="chp-14-ITERM-6755"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct device *parent</span></span><a name="chp-14-ITERM-6749"></a></span></dt></P>
<dd>
<p class="docList">The device's
"parent" device—the device to
which it is attached. In most cases, a parent device is some sort of
bus or host controller. If <tt>parent</tt> is
<tt>NULL</tt>, the device is a top-level device, which is
not usually what you want.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct kobject kobj;</span></span><a name="chp-14-ITERM-6750"></a></span></dt></P>
<dd>
<p class="docList">The kobject that represents this device and links it into the
hierarchy. Note that, as a general rule,
<tt>device-&gt;kobj-&gt;parent</tt> is equal to
<tt>&amp;device-&gt;parent-&gt;kobj</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">char bus_id[BUS_ID_SIZE];</span></span><a name="chp-14-ITERM-6751"></a></span></dt></p>
<dd>
<p class="docList">A string that uniquely identifies this device on the bus. PCI
devices, for example, use the standard PCI ID format containing the
domain, bus, device, and function numbers.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct bus_type *bus;</span></span><a name="chp-14-ITERM-6752"></a></span></dt></p>
<dd>
<p class="docList">Identifies which kind of bus the device sits on.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct device_driver *driver;</span></span><a name="chp-14-ITERM-6753"></a></span></dt></p>
<dd>
<p class="docList">The driver that manages this device; we examine
<tt>struct</tt> <tt>device_driver</tt> in the
next section.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void *driver_data;</span></span><a name="chp-14-ITERM-6754"></a></span></dt></p>
<dd>
<p class="docList">A private data field that may be used by the device driver.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void (*release)(struct device *dev);</span></span><a name="chp-14-ITERM-6755"></a></span></dt></p>
<dd>
<p class="docList">The method is called when the last reference to the device is
removed; it is called from the embedded kobject's
<span class="docEmphasis">release</span> method. All <tt>device</tt>
structures registered with the core must have a
<span class="docEmphasis">release</span> method, or the kernel prints out scary
complaints.</P>
</dd>
</dl>

<p class="docText">At a minimum, the <tt>parent</tt>,
<tt>bus_id</tt>, <tt>bus</tt>, and
<tt>release</tt> fields must be set before the device
structure can be registered.</p>

<a name="chp-14-sect-4.2.1"></a>
<H5 class="docSection3Title">14.4.2.1 Device registration</h5>

<p class="docText">The usual set of
registration<a name="chp-14-ITERM-6756"></a>
<a name="chp-14-ITERM-6757"></a>
and unregistration functions exists:</p>

<pre>int device_register(struct device *dev);
void device_unregister(struct device *dev);</pre><br>


<p class="docText">We have seen how the <span class="docEmphasis">lddbus</span> code registers its
bus type. However, an actual bus is a device and must be registered
separately. For simplicity, the <span class="docEmphasis">lddbus</span> module
supports only a single virtual bus, so the driver sets up its device
at compile time:</p>

<pre>static void ldd_bus_release(struct device *dev)
{
    printk(KERN_DEBUG "lddbus release\n");
}
    
struct device ldd_bus = {
    .bus_id   = "ldd0",
    .release  = ldd_bus_release
};</pre><br>


<p class="docText">This is a top-level bus, so the <tt>parent</tt> and
<tt>bus</tt> fields are left <tt>NULL</tt>. We
have a simple, no-op <span class="docEmphasis">release</span> method, and, as the
first (and only) bus, its name is <tt>ldd0</tt>. This bus
device is registered with:</p>

<pre>ret = device_register(&amp;ldd_bus);
if (ret)
    printk(KERN_NOTICE "Unable to register ldd0\n");</pre><br>


<p class="docText">Once that call is complete, the new bus can be seen under
<i>/sys/devices</i> in sysfs. Any devices added to this
bus then shows up under <i>/sys/devices/ldd0/</i>.</p>



<a name="chp-14-sect-4.2.2"></a>
<h5 class="docSection3Title">14.4.2.2 Device attributes</H5>

<p class="docText">Device entries
<a name="chp-14-ITERM-6758"></a>
<a name="chp-14-ITERM-6759"></a>in
sysfs can have attributes. The relevant structure is:</p>

<pre>struct device_attribute {
    struct attribute attr;
    ssize_t (*show)(struct device *dev, char *buf);
    ssize_t (*store)(struct device *dev, const char *buf, 
                     size_t count);
};</pre><BR>


<p class="docText">These attribute structures can be set up at compile time with this
macro:</P>

<pre>DEVICE_ATTR(name, mode, show, store);</pre><br>


<p class="docText">The resulting structure is named by prepending
<tt>dev_attr_</tt> to the given <tt>name</tt>.
The actual management of attribute files is handled with the usual
pair of functions:</p>

<pre>int device_create_file(struct device *device, 
                       struct device_attribute *entry);
void device_remove_file(struct device *dev, 
                        struct device_attribute *attr);</pre><br>


<p class="docText">The <tt>dev_attrs</tt> field of <tt>struct
bus_type</tt> points to a list of default attributes created for
every device added to that bus.</P>



<a name="chp-14-sect-4.2.3"></a>
<h5 class="docSection3Title">14.4.2.3 Device structure embedding</H5>

<p class="docText">The <tt>device</tt> structure
<a name="chp-14-ITERM-6760"></a>
<a name="chp-14-ITERM-6761"></a>
<a name="chp-14-ITERM-6762"></a>contains the information that the
device model core needs to model the system. Most subsystems,
however, track additional information about the devices they host. As
a result, it is rare for devices to be represented by bare
<tt>device</tt> structures; instead, that structure, like
kobject structures, is usually embedded within a higher-level
representation of the device. If you look at the definitions of
<tt>struct</tt> <tt>pci_dev</tt> or
<tt>struct</tt> <tt>usb_device</tt>, you will
find a <tt>struct</tt> <tt>device</tt> buried
inside. Usually, low-level drivers are not even aware of that
<tt>struct</tt> <tt>device</tt>, but there can be
exceptions.</P>

<p class="docText">The <span class="docEmphasis">lddbus</span> driver creates its own device type
(<tt>struct</tt> <tt>ldd_device</tt>) and expects
individual device drivers to register their devices using that type.
It is a simple structure:</P>

<pre>struct ldd_device {
    char *name;
    struct ldd_driver *driver;
    struct device dev;
};

#define to_ldd_device(dev) container_of(dev, struct ldd_device, dev);</pre><br>


<p class="docText">This structure allows the driver to provide an actual name for the
device (which can be distinct from its bus ID, stored in the
<tt>device</tt> structure) and a pointer to driver
information. Structures for real devices usually also contain
information about the vendor, device model, device configuration,
resources used, and so on. Good examples can be found in
<tt>struct</tt> <tt>pci_dev</tt>
(<i>&lt;linux/pci.h&gt;</i>) or
<tt>struct</tt> <tt>usb_device</tt>
(<i>&lt;linux/usb.h&gt;</I>). A convenience macro
(<span class="docEmphasis">to_ldd_device</span>) is also defined for
<tt>struct</tt> <tt>ldd_device</tt> to make it
easy to turn pointers to the embedded <tt>device</tt>
structure into <tt>ldd_device</tt> pointers.</P>

<p class="docText">The registration interface exported by <span class="docEmphasis">lddbus</span>
looks like this:</P>

<pre>int register_ldd_device(struct ldd_device *ldddev)
{
    ldddev-&gt;dev.bus = &amp;ldd_bus_type;
    ldddev-&gt;dev.parent = &amp;ldd_bus;
    ldddev-&gt;dev.release = ldd_dev_release;
    strncpy(ldddev-&gt;dev.bus_id, ldddev-&gt;name, BUS_ID_SIZE);
    return device_register(&amp;ldddev-&gt;dev);
}
EXPORT_SYMBOL(register_ldd_device);</pre><br>


<p class="docText">Here, we simply fill in some of the embedded
<tt>device</tt> structure fields (which individual drivers
should not need to know about), and register the device with the
driver core. If we wanted to add bus-specific attributes to the
device, we could do so here.</P>

<p class="docText">To show how this interface is used, let us introduce another sample
driver, which we have called <span class="docEmphasis">sculld</span>. It is yet
another variant on the <span class="docEmphasis">scullp</span> driver first
introduced in <a class="docLink" href="chp-8.shtml#chp-8">Chapter 8</a>. It
implements the usual memory area device, but
<span class="docEmphasis">sculld</span> also works with the Linux device model by
way of the <span class="docEmphasis">lddbus</span> interface.</P>

<p class="docText">The <span class="docEmphasis">sculld</span> driver adds an attribute of its own
to its device entry; this attribute, called <tt>dev</tt>,
simply contains the associated device number. This attribute could be
used by a module loading the script or the hotplug subsystem to
automatically create device nodes when the device is added to the
system. The setup for this attribute follows the usual patterns:</p>

<pre>static ssize_t sculld_show_dev(struct device *ddev, char *buf)
{
    struct sculld_dev *dev = ddev-&gt;driver_data;

    return print_dev_t(buf, dev-&gt;cdev.dev);
}

static DEVICE_ATTR(dev, S_IRUGO, sculld_show_dev, NULL);</pre><br>


<p class="docText">Then, at initialization time, the device is registered, and the
<tt>dev</tt> attribute is created through the following
function:</p>

<pre>static void sculld_register_dev(struct sculld_dev *dev, int index)
{
    sprintf(dev-&gt;devname, "sculld%d", index);
    dev-&gt;ldev.name = dev-&gt;devname;
    dev-&gt;ldev.driver = &amp;sculld_driver;
    dev-&gt;ldev.dev.driver_data = dev;
    register_ldd_device(&amp;dev-&gt;ldev);
    device_create_file(&amp;dev-&gt;ldev.dev, &amp;dev_attr_dev);
}</pre><br>


<p class="docText">Note that we make use of the <tt>driver_data</tt> field to
store the pointer to our own, internal device structure.</P>



<a name="chp-14-sect-4.3"></a>
<h4 class="docSection2Title">14.4.3. Device Drivers</h4>

<p class="docText">The device model
<a name="chp-14-ITERM-6763"></a>
<a name="chp-14-ITERM-6764"></a>tracks
all of the drivers known to the system. The main reason for this
tracking is to enable the driver core to match up drivers with new
devices. Once drivers are known objects within the system, however, a
number of other things become possible. Device drivers can export
information and configuration variables that are independent of any
specific device, for example.</P>

<p class="docText">Drivers are defined by the following structure:</p>

<a name="chp-14-ITERM-6765"></a><a name="chp-14-ITERM-6766"></a><pre>struct device_driver {
    char *name;
    struct bus_type *bus;
    struct kobject kobj;
    struct list_head devices;
    int (*probe)(struct device *dev);
    int (*remove)(struct device *dev);
    void (*shutdown) (struct device *dev);
};</pre><br>


<p class="docText">Once again, several of the structure's fields have
been omitted (see <I>&lt;linux/device.h&gt;</i> for the
full story). Here, <tt>name</tt> is the name of the driver
(it shows up in sysfs), <tt>bus</tt> is the type of bus
this driver works with, <tt>kobj</tt> is the inevitable
kobject, <tt>devices</tt> is a list of all devices
currently bound to this driver, <span class="docEmphasis">probe</span> is a
function called to query the existence of a specific device (and
whether this driver can work with it), <tt>remove</tt> is
called when the device is removed from the system, and
<tt>shutdown</tt> is called at shutdown time to quiesce the
device.</P>

<p class="docText">The form of the functions for working with
<tt>device_driver</tt> structures should be looking
familiar by now (so we cover them very quickly). The registration
functions are:</p>

<pre>int driver_register(struct device_driver *drv);
void driver_unregister(struct device_driver *drv);</pre><br>


<p class="docText">The usual attribute structure exists:</p>

<pre>struct driver_attribute {
    struct attribute attr;
    ssize_t (*show)(struct device_driver *drv, char *buf);
    ssize_t (*store)(struct device_driver *drv, const char *buf, 
                     size_t count);
};
DRIVER_ATTR(name, mode, show, store);</pre><br>


<p class="docText">And attribute files are created in the usual way:</p>

<pre>int driver_create_file(struct device_driver *drv, 
                       struct driver_attribute *attr);
void driver_remove_file(struct device_driver *drv, 
                        struct driver_attribute *attr);</pre><br>


<p class="docText">The <tt>bus_type</tt> structure contains a field
(<tt>drv_attrs</tt>) that points to a set of default
attributes, which are created for all drivers associated with that
bus.</p>

<a name="chp-14-sect-4.3.1"></a>
<h5 class="docSection3Title">14.4.3.1 Driver structure embedding</h5>

<p class="docText">As is the case with
mos<a name="chp-14-ITERM-6767"></a>
<a name="chp-14-ITERM-6768"></a>
<a name="chp-14-ITERM-6769"></a>t driver core structures, the
<tt>device_driver</tt> structure is usually found embedded
within a higher-level, bus-specific structure. The
<span class="docEmphasis">lddbus</span> subsystem would never go against such a
trend, so it has defined its own
<tt>ldd_driver</tt><a name="chp-14-ITERM-6770"></a>
<a name="chp-14-ITERM-6771"></a>
structure:</p>

<pre>struct ldd_driver {
    char *version;
    struct module *module;
    struct device_driver driver;
    struct driver_attribute version_attr;
};

#define to_ldd_driver(drv) container_of(drv, struct ldd_driver, driver);</pre><br>


<p class="docText">Here, we require each driver to provide its current software version,
and <span class="docEmphasis">lddbus</span> exports that version string for every
driver it knows about. The bus-specific driver registration function
is:</p>

<pre>int register_ldd_driver(struct ldd_driver *driver)
{
    int ret;
    
    driver-&gt;driver.bus = &amp;ldd_bus_type;
    ret = driver_register(&amp;driver-&gt;driver);
    if (ret)
        return ret;
    driver-&gt;version_attr.attr.name = "version";
    driver-&gt;version_attr.attr.owner = driver-&gt;module;
    driver-&gt;version_attr.attr.mode = S_IRUGO;
    driver-&gt;version_attr.show = show_version;
    driver-&gt;version_attr.store = NULL;
    return driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);
}</pre><br>


<p class="docText">The first half of the function simply registers the low-level
<tt>device_driver</tt> structure with the core; the rest
sets up the <tt>version</tt> attribute. Since this
attribute is created at runtime, we can't use the
<tt>DRIVER_ATTR</tt><a name="chp-14-ITERM-6772"></a>
<a name="chp-14-ITERM-6773"></a>
<a name="chp-14-ITERM-6774"></a>
<a name="chp-14-ITERM-6775"></a>
macro; instead, the <tt>driver_attribute</tt> structure
must be filled in by hand. Note that we set the owner of the
attribute to the driver module, rather than the
<span class="docEmphasis">lddbus</span> module; the reason for this can be seen
in the implementation of the
<span class="docEmphasis">show</span><a name="chp-14-ITERM-6776"></a>
<a name="chp-14-ITERM-6777"></a>
function for this attribute:</P>

<pre>static ssize_t show_version(struct device_driver *driver, char *buf)
{
    struct ldd_driver *ldriver = to_ldd_driver(driver);

    sprintf(buf, "%s\n", ldriver-&gt;version);
    return strlen(buf);
}</pre><br>


<p class="docText">One might think that the attribute owner should be the
<span class="docEmphasis">lddbus</span> module, since the function that
implements the attribute is defined there. This function, however, is
working with the <tt>ldd_driver</tt> structure created (and
owned) by the driver itself. If that structure were to go away while
a user-space process tried to read the version number, things could
get messy. Designating the driver module as the owner of the
attribute prevents the module from being unloaded, while user-space
holds the attribute file open. Since each driver module creates a
reference to the <span class="docEmphasis">lddbus</span> module, we can be sure
that <span class="docEmphasis">lddbus</span> will not be unloaded at an
inopportune time.</P>

<p class="docText">For completeness, <span class="docEmphasis">sculld</span> creates its
<tt>ldd_driver</tt> structure as follows:</P>

<pre>static struct ldd_driver sculld_driver = {
    .version = "$Revision: 1.1 $",
    .module = THIS_MODULE,
    .driver = {
        .name = "sculld",
    },
};</pre><br>


<p class="docText">A simple call to <span class="docEmphasis">register_ldd_driver</span> adds it to
the system. Once initialization is complete, the driver information
can be <a name="chp-14-ITERM-6778"></a>
<a name="chp-14-ITERM-6779"></a>
<a name="chp-14-ITERM-6780"></a>
<a name="chp-14-ITERM-6781"></a>seen in
sysfs:</p>

<pre>$ <b>tree /sys/bus/ldd/drivers</b>
/sys/bus/ldd/drivers
`-- sculld
    |-- sculld0 -&gt; ../../../../devices/ldd0/sculld0
    |-- sculld1 -&gt; ../../../../devices/ldd0/sculld1
    |-- sculld2 -&gt; ../../../../devices/ldd0/sculld2
    |-- sculld3 -&gt; ../../../../devices/ldd0/sculld3
    `-- version</pre><BR>





<ul></UL></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-14-sect-3.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-14-sect-5.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
