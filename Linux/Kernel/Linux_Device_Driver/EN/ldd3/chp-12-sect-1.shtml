<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>12.1. The PCI Interface</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-12.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-12-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="chp-12-sect-1"></a>
<h3 class="docSection1Title">12.1. The PCI Interface</h3>

<p class="docText">Although many computer<a name="chp-12-ITERM-6286"></a>
<a name="chp-12-ITERM-6287"></a>
<a name="chp-12-ITERM-6288"></a>
users think of PCI as a way of laying out electrical wires, it is
actually a complete set of specifications defining how different
parts of a computer should interact.</p>

<p class="docText">The PCI specification covers most issues related to computer
interfaces. We are not going to cover it all here; in this section,
we are mainly concerned with how a PCI driver can find its hardware
and gain access to it. The probing techniques discussed in 
<a class="docLink" href="chp-12.shtml#chp-12">Chapter 12</a> and <a class="docLink" href="chp-10.shtml#chp-10">Chapter 10</a>
can be used with PCI
devices, but the specification offers an alternative that is
preferable to probing.</p>

<p class="docText">The PCI architecture was designed as a replacement for the ISA
standard, with three main goals: to get better performance when
transferring data between the computer and its peripherals, to be as
platform independent as possible, and to simplify adding and removing
peripherals to the system.</P>

<p class="docText">The PCI bus achieves better performance by using a higher clock rate
than ISA; its clock runs at 25 or 33 MHz (its actual rate being a
factor of the system clock), and 66-MHz and even 133-MHz
implementations have recently been deployed as well. Moreover, it is
equipped with a 32-bit data bus, and a 64-bit extension has been
included in the specification. Platform independence is often a goal
in the design of a computer bus, and it's an
especially important feature of PCI, because the PC world has always
been dominated by processor-specific interface standards. PCI is
currently used extensively on IA-32, Alpha, PowerPC, SPARC64, and
IA-64 systems, and some other platforms as well.</P>

<p class="docText">What is most relevant to the driver writer, however, is
PCI's support for autodetection of interface boards.
PCI devices are jumperless (unlike most older peripherals) and are
automatically configured at boot time. Then, the device driver must
be able to access configuration information in the device in order to
complete initialization. This happens without the need to perform any
probing.</P>

<a name="chp-12-sect-1.1"></a>
<h4 class="docSection2Title">12.1.1. PCI Addressing</H4>

<p class="docText">Each PCI peripheral
<a name="chp-12-ITERM-6289"></a>is
identified by a <I>bus</i> number, a
<i>device</i> number, and a
<i>function</I> number. The PCI specification permits
a single system to host up to 256 buses, but because 256 buses are
not sufficient for many large systems, Linux now supports PCI
<i>domains</i>. Each PCI domain can host up to 256
buses. Each bus hosts up to 32 devices, and each device can be a
multifunction board (such as an audio device with an accompanying
CD-ROM drive) with a maximum of eight functions. Therefore, each
function can be identified at hardware level by a 16-bit address, or
key. Device drivers written for Linux, though, don't
need to deal with those binary addresses, because they use a specific
data structure, called <tt>pci_dev</tt>, to act on the
devices.</P>

<p class="docText">Most recent workstations feature at
least<a name="chp-12-ITERM-6290"></a>
two PCI buses. Plugging more than one bus in a single system is
accomplished by means of
<span class="docEmphasis">bridges</span><a name="chp-12-ITERM-6291"></a>,
special-purpose PCI peripherals whose task is joining two buses. The
overall layout of a PCI system is a tree where each bus is connected
to an upper-layer bus, up to bus 0 at the root of the tree. The
CardBus PC-card system is also connected to the PCI system via
bridges. A typical PCI system is represented in <a class="docLink" href="chp-12-sect-1.shtml#chp-12-FIG-1">Figure 12-1</a>, where the various
bridges are highlighted.</p>

<a name="chp-12-FIG-1"></a><p><center>
<H5 class="docFigureTitle">Figure 12-1. Layout of a typical PCI system</h5>
<img border="0" alt="" width="442" height="235" SRC="images/0596005903/figs/ldr3_1201.gif"></center></P><br>

<p class="docText">The 16-bit hardware addresses associated with PCI peripherals,
although mostly hidden in the <tt>struct pci_dev</tt>
object, are still visible occasionally, especially when lists of
devices are being used. One such situation is the output of
<span class="docEmphasis">lspci</span> (part of the <span class="docEmphasis">pciutils</span>
package, available with most distributions) and the layout of
information in <i>/proc/pci</i> and
<i>/proc/bus/pci</i>. The sysfs representation of PCI
devices also shows this addressing scheme, with the addition of the
PCI domain information.<sup class="docFootnote"><a class="docLink" href="chp-12-sect-1.shtml#chp-12-FNOTE-1">[1]</a></sup> When the hardware address is displayed, it
can be shown as two values (an 8-bit bus number and an 8-bit device
and function number), as three values (bus, device, and function), or
as four values (domain, bus, device, and function); all the values
are usually displayed in hexadecimal.</p><blockquote><p class="docFootnote"><sup><a name="chp-12-FNOTE-1">[1]</a></sup> Some architectures also
display the PCI domain information in the
<span class="docEmphasis">/proc/pci</span> and <span class="docEmphasis">/proc/bus/pci</span>
files.</p></blockquote>

<p class="docText">For example, <i>/proc/bus/pci/devices</i> uses a single
16-bit field (to ease parsing and sorting), while
<i>/proc/bus/</i><tt><i>busnumber</i></tt>
splits the address into three fields. The following shows how those
addresses appear, showing only the beginning of the output lines:</P>

<pre>$ <b>lspci | cut -d: -f1-3</b>
0000:00:00.0 Host bridge
0000:00:00.1 RAM memory
0000:00:00.2 RAM memory
0000:00:02.0 USB Controller
0000:00:04.0 Multimedia audio controller
0000:00:06.0 Bridge
0000:00:07.0 ISA bridge
0000:00:09.0 USB Controller
0000:00:09.1 USB Controller
0000:00:09.2 USB Controller
0000:00:0c.0 CardBus bridge
0000:00:0f.0 IDE interface
0000:00:10.0 Ethernet controller
0000:00:12.0 Network controller
0000:00:13.0 FireWire (IEEE 1394)
0000:00:14.0 VGA compatible controller
$ <B>cat /proc/bus/pci/devices | cut -f1</b>
0000
0001
0002
0010
0020
0030
0038
0048
0049
004a
0060
0078
0080
0090
0098
00a0
$ <B>tree /sys/bus/pci/devices/</b>
/sys/bus/pci/devices/
|-- 0000:00:00.0 -&gt; ../../../devices/pci0000:00/0000:00:00.0
|-- 0000:00:00.1 -&gt; ../../../devices/pci0000:00/0000:00:00.1
|-- 0000:00:00.2 -&gt; ../../../devices/pci0000:00/0000:00:00.2
|-- 0000:00:02.0 -&gt; ../../../devices/pci0000:00/0000:00:02.0
|-- 0000:00:04.0 -&gt; ../../../devices/pci0000:00/0000:00:04.0
|-- 0000:00:06.0 -&gt; ../../../devices/pci0000:00/0000:00:06.0
|-- 0000:00:07.0 -&gt; ../../../devices/pci0000:00/0000:00:07.0
|-- 0000:00:09.0 -&gt; ../../../devices/pci0000:00/0000:00:09.0
|-- 0000:00:09.1 -&gt; ../../../devices/pci0000:00/0000:00:09.1
|-- 0000:00:09.2 -&gt; ../../../devices/pci0000:00/0000:00:09.2
|-- 0000:00:0c.0 -&gt; ../../../devices/pci0000:00/0000:00:0c.0
|-- 0000:00:0f.0 -&gt; ../../../devices/pci0000:00/0000:00:0f.0
|-- 0000:00:10.0 -&gt; ../../../devices/pci0000:00/0000:00:10.0
|-- 0000:00:12.0 -&gt; ../../../devices/pci0000:00/0000:00:12.0
|-- 0000:00:13.0 -&gt; ../../../devices/pci0000:00/0000:00:13.0
`-- 0000:00:14.0 -&gt; ../../../devices/pci0000:00/0000:00:14.0</pre><br>


<p class="docText">All three lists of devices are sorted in the same order, since
<span class="docEmphasis">lspci</span> uses the <i>/proc</i> files
as its source of information. Taking the VGA video controller as an
example, <tt>0x00a0</tt> means
<tt>0000:00:14.0</tt> when split into domain (16 bits), bus
(8 bits), device (5 bits) and function (3 bits).</P>

<p class="docText">The hardware circuitry of each peripheral board answers queries
pertaining to three address spaces: memory locations, I/O ports, and
configuration registers. The first two address spaces are shared by
all the devices on the same PCI bus (i.e., when you access a memory
location, all the devices on that PCI bus see the bus cycle at the
same time). The configuration space, on the other hand, exploits
<span class="docEmphasis">geographical
addressing</span><a name="chp-12-ITERM-6292"></a>. Configuration queries address only
one slot at a time, so they never collide.</p>

<p class="docText">As far as the driver is concerned,
<a name="chp-12-ITERM-6293"></a>
<a name="chp-12-ITERM-6294"></a>
<a name="chp-12-ITERM-6295"></a>memory
and I/O regions are accessed in the usual ways via
<span class="docEmphasis">inb</span>, <span class="docEmphasis">readb</span>, and so forth.
Configuration transactions, on the other hand, are performed by
calling specific kernel functions to access configuration registers.
With regard to interrupts, every PCI slot has four interrupt pins,
and each device function can use one of them without being concerned
about how those pins are routed to the CPU. Such routing is the
responsibility of the computer platform and is implemented outside of
the PCI bus. Since the PCI specification requires interrupt lines to
be shareable, even a processor with a limited number of IRQ lines,
such as the x86, can host many PCI interface boards (each with four
interrupt pins).</P>

<p class="docText">The I/O space in a PCI bus uses a 32-bit address bus (leading to 4 GB
of I/O ports), while the memory space can be accessed with either
32-bit or 64-bit addresses. 64-bit addresses are available on more
recent platforms. Addresses are supposed to be unique to one device,
but software may erroneously configure two devices to the same
address, making it impossible to access either one. But this problem
never occurs unless a driver is willingly playing with registers it
shouldn't touch. The good news is that every memory
and I/O address region offered by the interface board can be remapped
by means of configuration transactions. That is, the firmware
<a name="chp-12-ITERM-6296"></a>initializes
PCI hardware at system boot, mapping each region to a different
address to avoid collisions.<sup class="docFootnote"><a class="docLink" href="chp-12-sect-1.shtml#chp-12-FNOTE-2">[2]</a></sup> The addresses to which these regions are currently mapped
can be read from the configuration space, so the Linux driver can
access its devices without probing. After reading the configuration
registers, the driver can safely access its hardware.</P><blockquote><p class="docFootnote"><sup><a name="chp-12-FNOTE-2">[2]</a></sup> Actually, that
configuration is not restricted to the time the system boots;
hotpluggable devices, for example, cannot be available at boot time
and appear later instead. The main point here is that the device
driver must not change the address of I/O or memory regions.</P></blockquote>

<p class="docText">The PCI configuration
<a name="chp-12-ITERM-6297"></a>space
consists of 256 bytes for each device function (except for PCI
Express devices, which have 4 KB of configuration space for each
function), and the layout of the configuration registers is
standardized. Four bytes of the configuration space hold a unique
function ID, so the driver can identify its device by looking for the
specific ID for that peripheral.<sup class="docFootnote"><a class="docLink" href="chp-12-sect-1.shtml#chp-12-FNOTE-3">[3]</a></sup> In
summary, each device board is geographically addressed to retrieve
its configuration registers; the information in those registers can
then be used to perform normal I/O access, without the need for
further geographic addressing.</p><blockquote><p class="docFootnote"><sup><a name="chp-12-FNOTE-3">[3]</a></sup> You'll find the ID of any device in its own
hardware manual. A list is included in the file
<i>pci.ids</i>, part of the
<span class="docEmphasis">pciutils</span> package and the kernel sources; it
doesn't pretend to be complete but just lists the
most renowned vendors and devices. The kernel version of this file
will not be included in future kernel series.</p></blockquote>

<p class="docText">It should be clear from this description that the main innovation of
the PCI interface standard over ISA is the configuration address
space. Therefore, in addition to the usual driver code, a PCI driver
needs the ability to access the configuration space, in order to save
itself from risky probing tasks.</P>

<p class="docText">For the remainder of this chapter, we use the word
<span class="docEmphasis">device</span> to refer to a device function, because
each function in a multifunction board acts as an independent entity.
When we refer to a device, we mean the tuple "domain
number, bus number, device number, and function
number."</P>


<a name="chp-12-sect-1.2"></a>
<H4 class="docSection2Title">12.1.2. Boot Time</h4>

<p class="docText">To see how PCI works, we<a name="chp-12-ITERM-6298"></a>
<a name="chp-12-ITERM-6299"></a> start from system boot, since
that's when the devices are configured.</P>

<p class="docText">When power is applied to a PCI device, the hardware remains inactive.
In other words, the device responds only to configuration
transactions. At power on, the device has no memory and no I/O ports
mapped in the computer's address space; every other
device-specific feature, such as interrupt reporting, is disabled as
well.</P>

<p class="docText">Fortunately, every PCI motherboard is equipped with PCI-aware
firmware, called the BIOS, NVRAM, or PROM, depending on the platform.
The firmware offers access to the device configuration address space
by reading and writing registers in the PCI controller.</p>

<p class="docText">At system boot, the
<a name="chp-12-ITERM-6300"></a>firmware (or the Linux kernel,
if so configured) performs configuration transactions with every PCI
peripheral in order to allocate a safe place for each address region
it offers. By the time a device driver accesses the device, its
memory and I/O regions have already been mapped into the
processor's address space. The driver can change
this default assignment, but it never needs to do that.</p>

<p class="docText">As suggested, the user can look at the PCI device list and the
devices' configuration registers by reading
<i>/proc/bus/pci/devices</i> and
<I>/proc/bus/pci/*/*</i>. The former is a text file
with (hexadecimal) device information, and the latter are binary
files that report a snapshot of the configuration registers of each
device, one file per device. The individual PCI device directories in
the sysfs tree can be found in
<i>/sys/bus/pci/devices</I>. A PCI device directory
contains a number of different files:</p>

<pre>$ <b>tree /sys/bus/pci/devices/0000:00:10.0</b>
/sys/bus/pci/devices/0000:00:10.0
|-- class
|-- config
|-- detach_state
|-- device
|-- irq
|-- power
|   `-- state
|-- resource
|-- subsystem_device
|-- subsystem_vendor
`-- vendor</pre><BR>


<p class="docText">The file <i>config</I> is a binary file that allows the
raw PCI config information to be read from the device (just like the
<i>/proc/bus/pci/*/*</i> provides.) The files
<i>vendor</i>, <i>device</i>,
<i>subsystem_device</i>,
<i>subsystem_vendor</i>, and <i>class</i>
all refer to the specific values of this PCI device (all PCI devices
provide this information.) The file <i>irq</I> shows
the current IRQ assigned to this PCI device, and the file
<i>resource</I> shows the current memory resources
allocated by this device.</P>


<a name="chp-12-sect-1.3"></a>
<h4 class="docSection2Title">12.1.3. Configuration Registers and Initialization</h4>

<p class="docText">In this section, we look
<a name="chp-12-ITERM-6301"></a>
<a name="chp-12-ITERM-6302"></a>
<a name="chp-12-ITERM-6303"></a>at the configuration registers that PCI
devices contain. All PCI devices feature at least a 256-byte address
space. The first 64 bytes are standardized, while the rest are device
dependent. <a class="docLink" href="chp-12-sect-1.shtml#chp-12-FIG-2">Figure 12-2</a> shows
the layout of the device-independent configuration space.</p>

<a name="chp-12-FIG-2"></a><P><center>
<h5 class="docFigureTitle">Figure 12-2. The standardized PCI configuration registers</H5>
<img border="0" alt="" width="481" height="268" SRC="images/0596005903/figs/ldr3_1202.gif"></center></P><BR>

<p class="docText">As the figure shows, some of the PCI configuration registers are
required and some are optional. Every PCI device must contain
meaningful values in the required registers, whereas the contents of
the optional registers depend on the actual capabilities of the
peripheral. The optional fields are not used unless the contents of
the required fields indicate that they are valid. Thus, the required
fields assert the board's capabilities, including
whether the other fields are usable.</p>

<p class="docText">It's interesting to note that the PCI registers are
always little-endian. Although the standard is designed to be
architecture independent, the PCI designers sometimes show a slight
bias toward the PC environment. The driver writer should be careful
about byte ordering when accessing multibyte configuration registers;
code that works on the PC might not work on other platforms. The
Linux developers have taken care of the byte-ordering problem (see
the next section, <a class="docLink" href="chp-12-sect-1.shtml#chp-12-sect-1.8">Section 12.1.8</a>), but the issue must be kept
in mind. If you ever need to convert data from host order to PCI
order or vice versa, you can resort to the functions defined in
<i>&lt;asm/byteorder.h&gt;</i>, introduced in <a class="docLink" href="chp-11.shtml#chp-11">Chapter 11</a>, knowing that PCI byte
order is little-endian.</p>

<p class="docText">Describing all the configuration items is beyond the scope of this
book. Usually, the technical documentation released with each device
describes the supported registers. What we're
interested in is how a driver can look for its device and how it can
access the device's configuration space.</P>

<p class="docText">Three or five PCI registers identify a device:
<tt>vendorID</tt>, <tt>deviceID</tt>, and
<tt>class</tt> are the three that are always used. Every
PCI manufacturer assigns proper values to these read-only registers,
and the driver can use them to look for the device. Additionally, the
fields <tt>subsystem vendorID</tt> and <tt>subsystem
deviceID</tt> are sometimes set by the vendor to further
differentiate similar devices.</P>

<p class="docText">Let's look at these registers in more detail:</P>

<a name="chp-12-ITERM-6304"></a><a name="chp-12-ITERM-6305"></a><a name="chp-12-ITERM-6306"></a><a name="chp-12-ITERM-6307"></a><a name="chp-12-ITERM-6308"></a><a name="chp-12-ITERM-6309"></a><a name="chp-12-ITERM-6310"></a><a name="chp-12-ITERM-6311"></a><a name="chp-12-ITERM-6312"></a><a name="chp-12-ITERM-6313"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">vendorID</span></span><a name="chp-12-ITERM-6304"></a>
<a name="chp-12-ITERM-6305"></a></span></dt></P>
<dd>
<p class="docList">This 16-bit register identifies a hardware manufacturer. For
instance, every Intel device is marked with the same vendor number,
<tt>0x8086</tt>. There is a global registry of such
numbers, maintained by the PCI Special Interest Group, and
manufacturers must apply to have a unique number assigned to them.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">deviceID</span></span><a name="chp-12-ITERM-6306"></a>
<a name="chp-12-ITERM-6307"></a></span></dt></p>
<dd>
<p class="docList">This is another 16-bit register, selected by the manufacturer; no
official registration is required for the device ID. This ID is
usually paired with the vendor ID to make a unique 32-bit identifier
for a hardware device. We use the word
<I>signature</i> to refer to the vendor and device ID
pair. A device driver usually relies on the signature to identify its
device; you can find what value to look for in the hardware manual
for the target device.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">class</span></span><a name="chp-12-ITERM-6308"></a>
<a name="chp-12-ITERM-6309"></a></span></dt></p>
<dd>
<p class="docList">Every peripheral device belongs to a <span class="docEmphasis">class</span>. The
<tt>class</tt> register is a 16-bit value whose top 8 bits
identify the "base class" (or
<I>group</i>). For example,
"ethernet" and
"token ring" are two classes
belonging to the "network" group,
while the "serial" and
"parallel" classes belong to the
"communication" group. Some drivers
can support several similar devices, each of them featuring a
different signature but all belonging to the same class; these
drivers can rely on the <tt>class</tt> register to identify
their peripherals, as shown later.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">subsystem vendorID</span></span><a name="chp-12-ITERM-6310"></a>
<a name="chp-12-ITERM-6311"></a></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">subsystem deviceID</span></span><a name="chp-12-ITERM-6312"></a>
<a name="chp-12-ITERM-6313"></a></span></dt></p>
<dd>
<p class="docList">These fields can be used for further identification of a device. If
the chip is a generic interface chip to a local (onboard) bus, it is
often used in several completely different roles, and the driver must
identify the actual device it is talking with. The subsystem
identifiers are used to this end.</p>
</dd>
</dl>

<p class="docText">Using these different identifiers, a PCI driver can tell the kernel
what kind of devices it supports. The
<tt>struct</tt><a name="chp-12-ITERM-6314"></a>
<tt>pci_device_id</tt> structure is used to define a list
of the different types of PCI devices that a driver supports. This
structure contains the following fields:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _u32 vendor;</span></span>  </span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _u32 device;</span></span>  </span></dt></P>
<dd>
<p class="docList">These specify the PCI vendor and device IDs of a device. If a driver
can handle any vendor or device ID, the value
<tt>PCI_ANY_ID</tt> should be used for these fields.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _u32 subvendor;</span></span>  </span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _u32 subdevice;</span></span>  </span></dt></P>
<dd>
<p class="docList">These specify the PCI subsystem vendor and subsystem device IDs of a
device. If a driver can handle any type of subsystem ID, the value
<tt>PCI_ANY_ID</tt> should be used for these fields.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _u32 class;</span></span>  </span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _u32 class_mask;</span></span>  </span></dt></p>
<dd>
<p class="docList">These two values allow the driver to specify that it supports a type
of PCI class device. The different classes of PCI devices (a VGA
controller is one example) are described in the PCI specification. If
a driver can handle any type of subsystem ID, the value
<tt>PCI_ANY_ID</tt> should be used for these fields.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">kernel_ulong_t driver_data;</span></span>  </span></dt></P>
<dd>
<p class="docList">This value is not used to match a device but is used to hold
information that the PCI driver can use to differentiate between
different devices if it wants to.</p>
</dd>
</dl>

<p class="docText">There are two helper macros that should be used to initialize a
<tt>struct</tt> <tt>pci_device_id</tt> structure:</P>

<a name="chp-12-ITERM-6315"></a><a name="chp-12-ITERM-6316"></a><a name="chp-12-ITERM-6317"></a><a name="chp-12-ITERM-6318"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PCI_DEVICE(vendor, device)</span></span><a name="chp-12-ITERM-6315"></a>
<a name="chp-12-ITERM-6316"></a>  </span></dt></p>
<dd>
<p class="docList">This creates a <tt>struct</tt>
<tt>pci_device_id</tt> that matches only the specific
vendor and device ID. The macro sets the <tt>subvendor</tt>
and <tt>subdevice</tt> fields of the structure to
<tt>PCI_ANY_ID</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">PCI_DEVICE_CLASS(device_class, device_class_mask)</span></span><a name="chp-12-ITERM-6317"></a>
<a name="chp-12-ITERM-6318"></a>  </span></dt></p>
<dd>
<p class="docList">This creates a <tt>struct</tt>
<tt>pci_device_id</tt> that matches a specific PCI class.</p>
</dd>
</dl>

<p class="docText">An example of using these macros to define the type of devices a
driver supports can be found in the following kernel files:</P>

<pre>drivers/usb/host/ehci-hcd.c:

static const struct pci_device_id pci_ids[  ] = { {
        /* handle any USB 2.0 EHCI controller */
        PCI_DEVICE_CLASS(((PCI_CLASS_SERIAL_USB &lt;&lt; 8) | 0x20), ~0),
        .driver_data =  (unsigned long) &amp;ehci_driver,
        },
        { /* end: all zeroes */ }
};

drivers/i2c/busses/i2c-i810.c:

static struct pci_device_id i810_ids[  ] = {
    { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810_IG1) },
    { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810_IG3) },
    { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810E_IG) },
    { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_CGC) },
    { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82845G_IG) },
    { 0, },
};</pre><br>


<p class="docText">These examples create a list of <tt>struct</tt>
<tt>pci_device_id</tt> structures, with an empty structure
set to all zeros as the last value in the list. This array of IDs is
used in the <tt>struct</tt> <tt>pci_driver</tt>
(described below), and it is also used to tell user space which
devices this specific driver supports.</p>


<a name="chp-12-sect-1.4"></a>
<H4 class="docSection2Title">12.1.4. MODULE_DEVICE_TABLE</h4>

<p class="docText">This <tt>pci_device_id</tt> structure needs to be exported
to user space to allow the hotplug and module loading systems know
what module works with what hardware devices. The macro
<tt>MODULE_DEVICE_TABLE</tt><a name="chp-12-ITERM-6319"></a>
<a name="chp-12-ITERM-6320"></a>
accomplishes this. An example is:</P>

<pre>MODULE_DEVICE_TABLE(pci, i810_ids);</pre><br>


<p class="docText">This statement creates a local variable called <tt>_
_mod_pci_device_table</tt> that points to the list of
<tt>struct</tt> <tt>pci_device_id</tt>. Later in
the kernel build process, the <tt>depmod</tt> program
searches all modules for the symbol <tt>_
_mod_pci_device_table</tt>. If that symbol is found, it pulls
the data out of the module and adds it to the file
<i>/lib/modules/KERNEL_VERSION/modules.pcimap</i>.
After <tt>depmod</tt> completes, all PCI devices that are
supported by modules in the kernel are listed, along with their
module names, in that file. When the kernel tells the hotplug system
that a new PCI device has been found, the hotplug system uses the
<span class="docEmphasis">modules.pcimap</span> file to find the proper driver to
load.</p>


<a name="chp-12-sect-1.5"></a>
<h4 class="docSection2Title">12.1.5. Registering a PCI Driver</h4>

<p class="docText">The main structure that all
<a name="chp-12-ITERM-6321"></a>PCI drivers must create in order to be
registered with the kernel properly is the <tt>struct
pci_driver</tt> structure. This structure consists of a number
of function callbacks and variables that describe the PCI driver to
the PCI core. Here are the fields in this structure that a PCI driver
needs to be aware of:</p>

<a name="chp-12-ITERM-6322"></a><a name="chp-12-ITERM-6323"></a><a name="chp-12-ITERM-6324"></a><a name="chp-12-ITERM-6325"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">const char *name;</span></span><a name="chp-12-ITERM-6322"></a>  </span></dt></p>
<dd>
<p class="docList">The name of the driver. It must be unique among all PCI drivers in
the kernel and is normally set to the same name as the module name of
the driver. It shows up in sysfs under
<i>/sys/bus/pci/drivers/</i> when the driver is in the
kernel.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">const struct pci_device_id *id_table;</span></span><a name="chp-12-ITERM-6323"></a>  </span></dt></P>
<dd>
<p class="docList">Pointer to the <tt>struct</tt>
<tt>pci_device_id</tt> table described earlier in this
chapter.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*probe) (struct pci_dev *dev, const struct pci_device_id *id);</span></span><a name="chp-12-ITERM-6324"></a>  </span></dt></p>
<dd>
<p class="docList">Pointer to the probe function in the PCI driver. This function is
called by the PCI core when it has a <tt>struct
pci_dev</tt> that it thinks this driver wants to control. A
pointer to the <tt>struct</tt>
<tt>pci_device_id</tt> that the PCI core used to make this
decision is also passed to this function. If the PCI driver claims
the <tt>struct</tt> <tt>pci_dev</tt> that is
passed to it, it should initialize the device properly and return
<tt>0</tt>. If the driver does not want to claim the
device, or an error occurs, it should return a negative error value.
More details about this function follow later in this chapter.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void (*remove) (struct pci_dev *dev);</span></span><a name="chp-12-ITERM-6325"></a>  </span></dt></P>
<dd>
<p class="docList">Pointer to the function that the PCI core calls when the
<tt>struct</tt> <tt>pci_dev</tt> is being removed
from the system, or when the PCI driver is being unloaded from the
kernel. More details about this function follow later in this
chapter.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*suspend) (struct pci_dev *dev, u32 state);</span></span>  </span></dt></p>
<dd>
<p class="docList">Pointer to the function that the PCI core calls when the
<tt>struct</tt> <tt>pci_dev</tt> is being
suspended. The suspend state is passed in the
<tt>state</tt> variable. This function is optional; a
driver does not have to provide it.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int (*resume) (struct pci_dev *dev);</span></span>  </span></dt></P>
<dd>
<p class="docList">Pointer to the function that the PCI core calls when the
<tt>struct pci_dev</tt> is being resumed. It is always
called after <tt>suspend</tt> has been called. This
function is optional; a driver does not have to provide it.</p>
</dd>
</dl>

<p class="docText">In summary, to create a proper <tt>struct</tt>
<tt>pci_driver</tt> structure, only four fields need to be
initialized:</P>

<pre>static struct pci_driver pci_driver = {
    .name = "pci_skel",
    .id_table = ids,
    .probe = probe,
    .remove = remove,
};</pre><BR>


<p class="docText">To register the <tt>struct pci_driver</tt> with the PCI
core, a call to <span class="docEmphasis">pci_register_driver</span> is made with
a pointer to the <tt>struct</tt>
<tt>pci_driver</tt>. This is traditionally done in the
module initialization code for the PCI driver:</p>

<pre>static int _ _init pci_skel_init(void)
{
    return pci_register_driver(&amp;pci_driver);
}</pre><br>


<p class="docText">Note that the <span class="docEmphasis">pci_register_driver</span> function
either returns a negative error number or <tt>0</tt> if
everything was registered successfully. It does not return the number
of devices that were bound to the driver or an error number if no
devices were bound to the driver. This is a change from kernels prior
to the 2.6 release and was done because of the following situations:</p>

<ul><LI><p class="docList">On systems that support PCI hotplug, or CardBus systems, a PCI device
can appear or disappear at any point in time. It is helpful if
drivers can be loaded before the device appears, to reduce the time
it takes to initialize a device.</p></li><LI><p class="docList">The 2.6 kernel allows new PCI IDs to be dynamically allocated to a
driver after it has been loaded. This is done through the file
<tt>new_id</tt> that is created in all PCI driver
directories in sysfs. This is very useful if a new device is being
used that the kernel doesn't know about just yet. A
user can write the PCI ID values to the <span class="docEmphasis">new_id</span>
file, and then the driver binds to the new device. If a driver was
not allowed to load until a device was present in the system, this
interface would not be able to work.</p></li></UL>
<p class="docText">When the PCI driver is to be unloaded, the <tt>struct
pci_driver</tt> needs to be unregistered from the kernel. This
is done with a call to <span class="docEmphasis">pci_unregister_driver</span>.
When this call happens, any PCI devices that were currently bound to
this driver are removed, and the <span class="docEmphasis">remove</span> function
for this PCI driver is called before the
<span class="docEmphasis">pci_unregister_driver</span> function returns.</p>

<pre>static void _ _exit pci_skel_exit(void)
{
    pci_unregister_driver(&amp;pci_driver);
}</pre><BR>



<a name="chp-12-sect-1.6"></a>
<h4 class="docSection2Title">12.1.6. Old-Style PCI Probing</h4>

<p class="docText">In older kernel
<a name="chp-12-ITERM-6326"></a>versions,
the function, <span class="docEmphasis">pci_register_driver</span>, was not
always used by PCI drivers. Instead, they would either walk the list
of PCI devices in the system by hand, or they would call a function
that could search for a specific PCI device. The ability to walk the
list of PCI devices in the system within a driver has been removed
from the 2.6 kernel in order to prevent drivers from crashing the
kernel if they happened to modify the PCI device lists while a device
was being removed at the same time.</p>

<p class="docText">If the ability to find a specific PCI device is really needed, the
following functions are available:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct pci_dev *pci_get_device(unsigned int vendor, unsigned int device</span></span>, </span></dt></p>
<dt><span class="docPubcolor">                               <span class="docPubcolor"><span class="docMonofont">struct pci_dev *from);</span></span>  </span></dt></p>
<dd>
<p class="docList">This function scans the list of PCI devices currently present in the
system, and if the input arguments match the specified
<tt>vendor</tt> and <tt>device</tt> IDs, it
increments the reference count on the <tt>struct</tt>
<tt>pci_dev</tt> variable found, and returns it to the
caller. This prevents the structure from disappearing without any
notice and ensures that the kernel does not oops. After the driver is
done with the <tt>struct</tt> <tt>pci_dev</tt>
returned by the function, it must call the function
<span class="docEmphasis">pci_dev_put</span> to decrement the usage count
properly back to allow the kernel to clean up the device if it is
removed.</p>
</dd>
</dl>
<p class="docText">The <tt>from</tt> argument is used to get hold of multiple
devices with the same signature; the argument should point to the
last device that has been found, so that the search can continue
instead of restarting from the head of the list. To find the first
device, <tt>from</tt> is specified as
<tt>NULL</tt>. If no (further) device is found,
<tt>NULL</tt> is returned.</p>

<p class="docText">An example of how to use this function properly is:</p>

<pre>struct pci_dev *dev;
dev = pci_get_device(PCI_VENDOR_FOO, PCI_DEVICE_FOO, NULL);
if (dev) {
    /* Use the PCI device */
    ...
    pci_dev_put(dev);
}</pre><BR>


<p class="docText">This function can not be called from interrupt context. If it is, a
warning is printed out to the system log.</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct pci_dev *pci_get_subsys(unsigned int vendor, unsigned int device</span></span>, </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">unsigned int ss_vendor, unsigned int ss_device, struct pci_dev *from);</span></span>  </span></dt></P>
<dd>
<p class="docList">This function works just like <span class="docEmphasis">pci_get_device</span>,
but it allows the subsystem vendor and subsystem device IDs to be
specified when looking for the device.</p>
</dd>
</dl>
<p class="docText">This function can not be called from interrupt context. If it is, a
warning is printed out to the system log.</P>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">struct pci_dev *pci_get_slot(struct pci_bus *bus, unsigned int devfn);</span></span>  </span></dt></p>
<dd>
<p class="docList">This function searches the list of PCI devices in the system on the
specified <tt>struct pci_bus</tt> for the specified device
and function number of the PCI device. If a device is found that
matches, its reference count is incremented and a pointer to it is
returned. When the caller is finished accessing the
<tt>struct</tt> <tt>pci_dev</tt>, it must call
<span class="docEmphasis">pci_dev_put</span>.</p>
</dd>
</dl>

<p class="docText">All of these functions can not be called from interrupt context. If
they are, a warning is printed out to the system log.</p>


<a name="chp-12-sect-1.7"></a>
<h4 class="docSection2Title">12.1.7. Enabling the PCI Device</H4>

<p class="docText">In the <span class="docEmphasis">probe</span> function for the PCI driver,
<a name="chp-12-ITERM-6327"></a>before the driver can access any
device resource (I/O region or interrupt) of the PCI device, the
driver must call the <span class="docEmphasis">pci_enable_device</span> function:</P>

<a name="chp-12-ITERM-6328"></a><a name="chp-12-ITERM-6329"></a><dl class="docList"><dt><span class="docPubcolor"> <a name="chp-12-ITERM-6328"></a>
<a name="chp-12-ITERM-6329"></a> <span class="docPubcolor"><span class="docMonofont">int pci_enable_device(struct pci_dev *dev);</span></span>  </span></dt></P>
<dd>
<p class="docList">This function actually enables the device. It wakes up the device and
in some cases also assigns its interrupt line and I/O regions. This
happens, for example, with CardBus devices (which have been made
completely equivalent to PCI at the driver level).</P>
</dd>
</dl>


<a name="chp-12-sect-1.8"></a>
<h4 class="docSection2Title">12.1.8. Accessing the Configuration Space</h4>

<p class="docText">After the driver has
<a name="chp-12-ITERM-6330"></a>
<a name="chp-12-ITERM-6331"></a>detected the device, it
usually needs to read from or write to the three address spaces:
memory, port, and configuration. In particular, accessing the
configuration space is vital to the driver, because it is the only
way it can find out where the device is mapped in memory and in the
I/O space.</p>

<p class="docText">Because the microprocessor has no way to access the configuration
space directly, the computer vendor has to provide a way to do it. To
access configuration space, the CPU must write and read registers in
the PCI controller, but the exact implementation is vendor dependent
and not relevant to this discussion, because Linux offers a standard
interface to access the configuration space.</p>

<p class="docText">As far as the driver is concerned, the configuration space can be
accessed through 8-bit, 16-bit, or 32-bit data transfers. The
relevant functions are prototyped in
<I>&lt;linux/pci.h&gt;</i>:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_read_config_byte(struct pci_dev *dev, int where, u8 *val);</span></span>  </span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_read_config_word(struct pci_dev *dev, int where, u16 *val);</span></span>  </span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_read_config_dword(struct pci_dev *dev, int where, u32 *val);</span></span>  </span></dt></p>
<dd>
<p class="docList">Read one, two, or four bytes from the configuration space of the
device identified by <tt>dev</tt>. The
<tt>where</tt> argument is the byte offset from the
beginning of the configuration space. The value fetched from the
configuration space is returned through the <tt>val</tt>
pointer, and the return value of the functions is an error code. The
<span class="docEmphasis">word</span> and <span class="docEmphasis">dword</span> functions
convert the value just read from little-endian to the native byte
order of the processor, so you need not deal with byte ordering.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_write_config_byte(struct pci_dev *dev, int where, u8 val);</span></span>  </span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_write_config_word(struct pci_dev *dev, int where, u16 val);</span></span>  </span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_write_config_dword(struct pci_dev *dev, int where, u32 val);</span></span>  </span></dt></p>
<dd>
<p class="docList">Write one, two, or four bytes to the configuration space. The device
is identified by <tt>dev</tt> as usual, and the value being
written is passed as <tt>val</tt>. The
<span class="docEmphasis">word</span> and <span class="docEmphasis">dword</span> functions
convert the value to little-endian before writing to the peripheral
device.</P>
</dd>
</dl>

<p class="docText">All of the previous functions are implemented as inline functions
that really call the following functions. Feel free to use these
functions instead of the above in case the driver does not have
access to a <tt>struct pci_dev</tt> at any paticular moment
in time:</p>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_bus_read_config_byte (struct pci_bus *bus, unsigned int devfn, int</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">where, u8 *val);</span></span>  </span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_bus_read_config_word (struct pci_bus *bus, unsigned int devfn, int</span></span> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">where, u16 *val);</span></span>  </span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_bus_read_config_dword (struct pci_bus *bus, unsigned int devfn, int</span></span> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">where, u32 *val);</span></span>  </span></dt></p>
<dd>
<p class="docList">Just like the <span class="docEmphasis">pci_read_</span> functions, but
<tt>struct</tt> <tt>pci_bus</tt>
<tt>*</tt> and <tt>devfn</tt> variables are
needed instead of a <tt>struct</tt> <tt>pci_dev
*</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_bus_write_config_byte (struct pci_bus *bus, unsigned int devfn, int</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">where, u8 val);</span></span>  </span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_bus_write_config_word (struct pci_bus *bus, unsigned int devfn, int</span></span> </span></dt></P>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">where, u16 val);</span></span>  </span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int pci_bus_write_config_dword (struct pci_bus *bus, unsigned int devfn, int</span></span> </span></dt></p>
<dt><span class="docPubcolor">  <span class="docPubcolor"><span class="docMonofont">where, u32 val);</span></span>  </span></dt></p>
<dd>
<p class="docList">Just like the <span class="docEmphasis">pci_write_</span> functions, but
<tt>struct</tt> <tt>pci_bus</tt>
<tt>*</tt> and <tt>devfn</tt> variables are
needed instead of a <tt>struct pci_dev *</tt>.</p>
</dd>
</dl>

<p class="docText">The best way to address the configuration variables using the
<span class="docEmphasis">pci_read_</span> functions is by means of the symbolic
names defined in <i>&lt;linux/pci.h&gt;</i>. For
example, the following small function retrieves the revision ID of a
device by passing the symbolic name for <tt>where</tt> to
<span class="docEmphasis">pci_read_config_byte</span>:</p>

<pre>static unsigned char skel_get_revision(struct pci_dev *dev)
{
    u8 revision;

    pci_read_config_byte(dev, PCI_REVISION_ID, &amp;revision);
    return revision;
}</pre><br>



<a name="chp-12-sect-1.9"></a>
<h4 class="docSection2Title">12.1.9. Accessing the I/O and Memory Spaces</h4>

<p class="docText">A PCI device
implements<a name="chp-12-ITERM-6332"></a>
<a name="chp-12-ITERM-6333"></a>
<a name="chp-12-ITERM-6334"></a> up to six I/O address
regions. Each region consists of either memory or I/O locations. Most
devices implement their I/O registers in memory regions, because
it's generally a saner approach.
However, unlike normal
memory, I/O registers should not be cached by the CPU because each
access can have side effects. The PCI device that implements I/O
registers as a memory region marks the difference by setting a
"memory-is-prefetchable" bit in its
configuration register.<sup class="docFootnote"><a class="docLink" href="chp-12-sect-1.shtml#chp-12-FNOTE-4">[4]</a></sup> If the memory region is marked as prefetchable, the CPU
can cache its contents and do all sorts of optimization with it;
nonprefetchable memory access, on the other hand,
can't be optimized because each access can have side
effects, just as with I/O ports. Peripherals that map their control
registers to a memory address range declare that range as
nonprefetchable, whereas something like video memory on PCI boards is
prefetchable. In this section, we use the word
<span class="docEmphasis">region</span><a name="chp-12-ITERM-6335"></a>
<a name="chp-12-ITERM-6336"></a>
<a name="chp-12-ITERM-6337"></a>
<a name="chp-12-ITERM-6338"></a> to refer to a generic I/O address
space that is memory-mapped or port-mapped.</p><blockquote><p class="docFootnote"><sup><a name="chp-12-FNOTE-4">[4]</a></sup> The information lives in one
of the low-order bits of the base address PCI registers. The bits are
defined in <span class="docEmphasis">&lt;linux/pci.h&gt;</span>.</p></blockquote>

<p class="docText">An interface board reports the size and current location of its
regions using configuration registersthe six 32-bit registers
shown in <a class="docLink" href="chp-12-sect-1.shtml#chp-12-FIG-2">Figure 12-2</a>, whose
symbolic names are <tt>PCI_BASE_ADDRESS_0</tt> tHRough
<tt>PCI_BASE_ADDRESS_5</tt>. Since the I/O space defined by
PCI is a 32-bit address space, it makes sense to use the same
configuration interface for memory and I/O. If the device uses a
64-bit address bus, it can declare regions in the 64-bit memory space
by using two consecutive <tt>PCI_BASE_ADDRESS</tt>
registers for each region, low bits first. It is possible for one
device to offer both 32-bit regions and 64-bit regions.</p>

<p class="docText">In the kernel, the I/O regions of PCI devices have been integrated
into the generic resource management. For this reason, you
don't need to access the configuration variables in
order to know where your device is mapped in memory or I/O space. The
preferred interface for getting region information consists of the
following functions:</P>

<a name="chp-12-ITERM-6339"></a><a name="chp-12-ITERM-6340"></a><a name="chp-12-ITERM-6341"></a><a name="chp-12-ITERM-6342"></a><a name="chp-12-ITERM-6343"></a><a name="chp-12-ITERM-6344"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long pci_resource_start(struct pci_dev *dev, int bar);</span></span><a name="chp-12-ITERM-6339"></a>
<a name="chp-12-ITERM-6340"></a>  </span></dt></p>
<dd>
<p class="docList">The function returns the first address (memory address or I/O port
number) associated with one of the six PCI I/O regions. The region is
selected by the integer <tt>bar</tt> (the base address
register), ranging from 0-5 (inclusive).</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long pci_resource_end(struct pci_dev *dev, int bar);</span></span><a name="chp-12-ITERM-6341"></a>
<a name="chp-12-ITERM-6342"></a>  </span></dt></P>
<dd>
<p class="docList">The function returns the last address that is part of the I/O region
number <tt>bar</tt>. Note that this is the last usable
address, not the first address after the region.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned long pci_resource_flags(struct pci_dev *dev, int bar);</span></span><a name="chp-12-ITERM-6343"></a>
<a name="chp-12-ITERM-6344"></a>  </span></dt></p>
<dd>
<p class="docList">This function returns the flags associated with this resource.</p>
</dd>
</dl>

<p class="docText">Resource flags are used to define some features of the individual
resource. For PCI resources associated with PCI I/O regions, the
information is extracted from the base address registers, but can
come from elsewhere for resources not associated with PCI devices.</p>

<p class="docText">All resource flags <a name="chp-12-ITERM-6345"></a>
<a name="chp-12-ITERM-6346"></a>are defined in
<I>&lt;linux/ioport.h&gt;</I>; the most important are:</P>

<dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">IORESOURCE_IO</span></span>  </span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">IORESOURCE_MEM</span></span>  </span></dt></p>
<dd>
<p class="docList">If the associated I/O region exists, one and only one of these flags
is set.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">IORESOURCE_PREFETCH</span></span>  </span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">IORESOURCE_READONLY</span></span>  </span></dt></p>
<dd>
<p class="docList">These flags tell whether a memory region is prefetchable and/or write
protected. The latter flag is never set for PCI resources.</P>
</dd>
</dl>

<p class="docText">By making use of the
<span class="docEmphasis">pci_resource_</span><a name="chp-12-ITERM-6347"></a>
<a name="chp-12-ITERM-6348"></a>
functions, a device driver can completely ignore the underlying PCI
registers, since the system already used them to structure resource
information.</p>


<a name="chp-12-sect-1.10"></a>
<H4 class="docSection2Title">12.1.10. PCI Interrupts</h4>

<p class="docText">As far as interrupts are
<a name="chp-12-ITERM-6349"></a>concerned,
PCI is easy to handle. By the time Linux boots, the
computer's firmware has already assigned a unique
interrupt number to the device, and the driver just needs to use it.
The interrupt number is stored in configuration register 60
(<tt>PCI_INTERRUPT_LINE</tt>), which is one byte wide. This
allows for as many as 256 interrupt lines, but the actual limit
depends on the CPU being used. The driver doesn't
need to bother checking the interrupt number, because the value found
in <tt>PCI_INTERRUPT_LINE</tt> is guaranteed to be the
right one.</p>

<p class="docText">If the device doesn't support interrupts, register
61 (<tt>PCI_INTERRUPT_PIN</tt>) is <tt>0</tt>;
otherwise, it's nonzero. However, since the driver
knows if its device is interrupt driven or not, it
doesn't usually need to read
<tt>PCI_INTERRUPT_PIN</tt>.</p>

<p class="docText">Thus, PCI-specific code for dealing with interrupts just needs to
read the configuration byte to obtain the interrupt number that is
saved in a local variable, as shown in the following code. Beyond
that, the information in <a class="docLink" href="chp-10.shtml#chp-10">Chapter 10</a> applies.</p>

<pre>result = pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &amp;myirq);
if (result) {
    /* deal with error */
}</pre><br>


<p class="docText">The rest of this section provides additional information for the
curious reader but isn't needed for writing drivers.</p>

<p class="docText">A PCI connector has four interrupt pins, and peripheral boards can
use any or all of them. Each pin is individually routed to the
motherboard's interrupt controller, so interrupts
can be shared without any electrical problems. The interrupt
controller is then responsible for mapping the interrupt wires (pins)
to the processor's hardware; this platform-dependent
operation is left to the controller in order to achieve platform
independence in the bus itself.</p>

<p class="docText">The read-only configuration register located at
<tt>PCI_INTERRUPT_PIN</tt> is used to tell the computer
which single pin is actually used. It's worth
remembering that each device board can host up to eight devices; each
device uses a single interrupt pin and reports it in its own
configuration register. Different devices on the same device board
can use different interrupt pins or share the same one.</p>

<p class="docText">The <tt>PCI_INTERRUPT_LINE</tt> register, on the other
hand, is read/write. When the computer is booted, the firmware scans
its PCI devices and sets the register for each device according to
how the interrupt pin is routed for its PCI slot. The value is
assigned by the firmware, because only the firmware knows how the
motherboard routes the different interrupt pins to the processor. For
the device driver, however, the <tt>PCI_INTERRUPT_LINE</tt>
register is read-only. Interestingly, recent versions of the Linux
kernel under some circumstances can assign interrupt lines without
resorting to the BIOS.</p>


<a name="chp-12-sect-1.11"></a>
<h4 class="docSection2Title">12.1.11. Hardware Abstractions</h4>

<p class="docText">We complete the discussion
<a name="chp-12-ITERM-6350"></a>
<a name="chp-12-ITERM-6351"></a>of
PCI by taking a quick look at how the system handles the plethora of
PCI controllers<a name="chp-12-ITERM-6352"></a> available on the marketplace. This is
just an informational section, meant to show the curious reader how
the object-oriented layout of the kernel extends down to the lowest
levels.</p>

<p class="docText">The mechanism used to implement hardware abstraction is the usual
structure containing methods. It's a powerful
technique that adds just the minimal overhead of dereferencing a
pointer to the normal overhead of a function call. In the case of PCI
management, the only hardware-dependent operations are the ones that
read and write configuration registers, because everything else in
the PCI world is accomplished by directly reading and writing the I/O
and memory address spaces, and those are under direct control of the
CPU.</p>

<p class="docText">Thus, the relevant structure for configuration register access
includes only two fields:</P>

<pre>struct pci_ops {
    int (*read)(struct pci_bus *bus, unsigned int devfn, int where, int size, 
                u32 *val);
    int (*write)(struct pci_bus *bus, unsigned int devfn, int where, int size, 
                 u32 val);
};</pre><br>


<p class="docText">The structure is defined in <I>&lt;linux/pci.h&gt;</I>
and used by <span class="docEmphasis">drivers/pci/pci.c</span>, where the actual
public functions are defined.</p>

<p class="docText">The two functions that act on the PCI configuration space have more
overhead than dereferencing a pointer; they use cascading pointers
due to the high object-orientedness of the code, but the overhead is
not an issue in operations that are performed quite rarely and never
in speed-critical paths. The actual implementation of
<span class="docEmphasis">pci_read_config_byte(dev, where, val)</span>, for
instance, expands to:</p>

<pre>dev-&gt;bus-&gt;ops-&gt;read(bus, devfn, where, 8, val);</pre><br>


<p class="docText">The various PCI buses in the system are detected at system boot, and
that's when the <tt>struct pci_bus</tt>
items are created and associated with their features, including the
<tt>ops</tt> field.</P>

<p class="docText">Implementing <a name="chp-12-ITERM-6353"></a> <a name="chp-12-ITERM-6354"></a> <a name="chp-12-ITERM-6355"></a>hardware abstraction via
"hardware operations" data
structures is typical in the Linux kernel. One important example is
the <tt>struct</tt> <tt>alpha_machine_vector</tt>
data structure. It is defined in
<i>&lt;asm-alpha/machvec.h&gt;</I> and takes care of
everything that may change across different Alpha-based computers.</P>



<UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-12.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-12-sect-2.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
