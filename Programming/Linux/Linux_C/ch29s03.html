<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. VFS</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch29.html" title="第 29 章 文件系统" /><link rel="prev" href="ch29s02.html" title="2. ext2文件系统" /><link rel="next" href="ch30.html" title="第 30 章 进程" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. VFS</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch29s02.html">上一页</a> </td><th width="60%" align="center">第 29 章 文件系统</th><td width="20%" align="right"> <a accesskey="n" href="ch30.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2860197"></a>3. VFS</h2></div></div></div><p>Linux支持各种各样的文件系统格式，如ext2、ext3、reiserfs、FAT、NTFS、iso9660等等，不同的磁盘分区、光盘或其它存储设备都有不同的文件系统格式，然而这些文件系统都可以<code class="literal">mount</code>到某个目录下，使我们看到一个统一的目录树，各种文件系统上的目录和文件我们用<code class="literal">ls</code>命令看起来是一样的，读写操作用起来也都是一样的，这是怎么做到的呢？Linux内核在各种不同的文件系统格式之上做了一个抽象层，使得文件、目录、读写访问等概念成为抽象层的概念，因此各种文件系统看起来用起来都一样，这个抽象层称为虚拟文件系统（VFS，Virtual Filesystem）<a id="id2860253" class="indexterm"></a>。上一节我们介绍了一种典型的文件系统在磁盘上的存储布局，这一节我们介绍运行时文件系统在内核中的表示。</p><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2860264"></a>3.1. 内核数据结构</h3></div></div></div><p>Linux内核的VFS子系统可以图示如下：</p><div class="figure"><a id="id2860273"></a><p class="title"><b>图 29.8. VFS</b></p><div class="figure-contents"><div><img src="images/fs.vfs.png" alt="VFS" /></div></div></div><br class="figure-break" /><p>在<a class="xref" href="ch28.html#io">第 28 章 <i>文件与I/O</i></a>中讲过，每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用<code class="literal">file</code>结构体表示，文件描述符表中的指针指向<code class="literal">file</code>结构体。</p><p>在<code class="literal">file</code>结构体中维护File Status Flag（<code class="literal">file</code>结构体的成员<code class="literal">f_flags</code>）和当前读写位置（<code class="literal">file</code>结构体的成员<code class="literal">f_pos</code>）。在上图中，进程1和进程2都打开同一文件，但是对应不同的<code class="literal">file</code>结构体，因此可以有不同的File Status Flag和读写位置。<code class="literal">file</code>结构体中比较重要的成员还有<code class="literal">f_count</code>，表示引用计数（Reference Count）<a id="id2860367" class="indexterm"></a>，后面我们会讲到，<code class="literal">dup</code>、<code class="literal">fork</code>等系统调用会导致多个文件描述符指向同一个<code class="literal">file</code>结构体，例如有<code class="literal">fd1</code>和<code class="literal">fd2</code>都引用同一个<code class="literal">file</code>结构体，那么它的引用计数就是2，当<code class="literal">close(fd1)</code>时并不会释放<code class="literal">file</code>结构体，而只是把引用计数减到1，如果再<code class="literal">close(fd2)</code>，引用计数就会减到0同时释放<code class="literal">file</code>结构体，这才真的关闭了文件。</p><p>每个<code class="literal">file</code>结构体都指向一个<code class="literal">file_operations</code>结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中<code class="literal">read</code>一个文件描述符，<code class="literal">read</code>通过系统调用进入内核，然后找到这个文件描述符所指向的<code class="literal">file</code>结构体，找到<code class="literal">file</code>结构体所指向的<code class="literal">file_operations</code>结构体，调用它的<code class="literal">read</code>成员所指向的内核函数以完成用户请求。在用户程序中调用<code class="literal">lseek</code>、<code class="literal">read</code>、<code class="literal">write</code>、<code class="literal">ioctl</code>、<code class="literal">open</code>等函数，最终都由内核调用<code class="literal">file_operations</code>的各成员所指向的内核函数完成用户请求。<code class="literal">file_operations</code>结构体中的<code class="literal">release</code>成员用于完成用户程序的<code class="literal">close</code>请求，之所以叫<code class="literal">release</code>而不叫<code class="literal">close</code>是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，<code class="literal">read</code>、<code class="literal">write</code>等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的<code class="literal">file</code>结构体指向同一个<code class="literal">file_operations</code>结构体。如果打开一个字符设备文件，那么它的<code class="literal">read</code>、<code class="literal">write</code>操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以<code class="literal">file</code>结构体应该指向不同的<code class="literal">file_operations</code>结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p><p>每个<code class="literal">file</code>结构体都有一个指向<code class="literal">dentry</code>结构体的指针，“<span class="quote">dentry</span>”是directory entry（目录项）的缩写。我们传给<code class="literal">open</code>、<code class="literal">stat</code>等函数的参数的是一个路径，例如<code class="literal">/home/akaedu/a</code>，需要根据路径找到文件的inode。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache<a id="id2860666" class="indexterm"></a>，其中每个节点是一个<code class="literal">dentry</code>结构体，只要沿着路径各部分的dentry搜索即可，从根目录<code class="literal">/</code>找到<code class="literal">home</code>目录，然后找到<code class="literal">akaedu</code>目录，然后找到文件<code class="literal">a</code>。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p><p>每个<code class="literal">dentry</code>结构体都有一个指针指向<code class="literal">inode</code>结构体。<code class="literal">inode</code>结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示<code class="literal">/home/akaedu/a</code>和<code class="literal">/home/akaedu/b</code>，它们都指向同一个inode，说明这两个文件互为硬链接。<code class="literal">inode</code>结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个<code class="literal">inode</code>结构体都有一个指向<code class="literal">inode_operations</code>结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。和<code class="literal">file_operations</code>不同，<code class="literal">inode_operations</code>所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各<code class="literal">inode</code>结构体可以指向同一个<code class="literal">inode_operations</code>结构体。</p><p><code class="literal">inode</code>结构体有一个指向<code class="literal">super_block</code>结构体的指针。<code class="literal">super_block</code>结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。<code class="literal">super_block</code>结构体的<code class="literal">s_root</code>成员是一个指向<code class="literal">dentry</code>的指针，表示这个文件系统的根目录被<code class="literal">mount</code>到哪里，在上图的例子中这个分区被<code class="literal">mount</code>到<code class="literal">/home</code>目录下。</p><p><code class="literal">file</code>、<code class="literal">dentry</code>、<code class="literal">inode</code>、<code class="literal">super_block</code>这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能<code class="literal">mount</code>到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是<code class="literal">rwxrwxrwx</code>，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2860911"></a>3.2. dup和dup2函数</h3></div></div></div><p><code class="literal">dup</code>和<code class="literal">dup2</code>都可用来复制一个现存的文件描述符，使两个文件描述符指向同一个<code class="literal">file</code>结构体。如果两个文件描述符指向同一个<code class="literal">file</code>结构体，File Status Flag和读写位置只保存一份在<code class="literal">file</code>结构体中，并且<code class="literal">file</code>结构体的引用计数是2。如果两次<code class="literal">open</code>同一文件得到两个文件描述符，则每个描述符对应一个不同的<code class="literal">file</code>结构体，可以有不同的File Status Flag和读写位置。请注意区分这两种情况。</p><pre class="programlisting">#include &lt;unistd.h&gt;

int dup(int oldfd);
int dup2(int oldfd, int newfd);</pre><p>如果调用成功，这两个函数都返回新分配或指定的文件描述符，如果出错则返回-1。<code class="literal">dup</code>返回的新文件描述符一定该进程未使用的最小文件描述符，这一点和<code class="literal">open</code>类似。<code class="literal">dup2</code>可以用<code class="literal">newfd</code>参数指定新描述符的数值。如果<code class="literal">newfd</code>当前已经打开，则先将其关闭再做<code class="literal">dup2</code>操作，如果<code class="literal">oldfd</code>等于<code class="literal">newfd</code>，则<code class="literal">dup2</code>直接返回<code class="literal">newfd</code>而不用先关闭<code class="literal">newfd</code>再复制。</p><p>下面这个例子演示了<code class="literal">dup</code>和<code class="literal">dup2</code>函数的用法，请结合后面的连环画理解程序的执行过程。</p><div class="example"><a id="id2861068"></a><p class="title"><b>例 29.2. dup和dup2示例程序</b></p><div class="example-contents"><pre class="programlisting">#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
	int fd, save_fd;
	char msg[] = "This is a test\n";

	fd = open("somefile", O_RDWR|O_CREAT, S_IRUSR|S_IWUSR);
	if(fd&lt;0) {
		perror("open");
		exit(1);
	}
	save_fd = dup(STDOUT_FILENO);
	dup2(fd, STDOUT_FILENO);
	close(fd);
	write(STDOUT_FILENO, msg, strlen(msg));
	dup2(save_fd, STDOUT_FILENO);
	write(STDOUT_FILENO, msg, strlen(msg));
	close(save_fd);
	return 0;
}</pre></div></div><br class="example-break" /><div class="figure"><a id="id2861076"></a><p class="title"><b>图 29.9. dup/dup2示例程序</b></p><div class="figure-contents"><div><img src="images/fs.dup.png" alt="dup/dup2示例程序" /></div></div></div><br class="figure-break" /><p>重点解释两个地方：</p><div class="itemizedlist"><ul type="disc"><li><p>第3幅图，要执行<code class="literal">dup2(fd, 1);</code>，文件描述符1原本指向<code class="literal">tty</code>，现在要指向新的文件<code class="literal">somefile</code>，就把原来的关闭了，但是<code class="literal">tty</code>这个文件原本有两个引用计数，还有文件描述符<code class="literal">save_fd</code>也指向它，所以只是将引用计数减1，并不真的关闭文件。</p></li><li><p>第5幅图，要执行<code class="literal">dup2(save_fd, 1);</code>，文件描述符1原本指向<code class="literal">somefile</code>，现在要指向新的文件<code class="literal">tty</code>，就把原来的关闭了，<code class="literal">somefile</code>原本只有一个引用计数，所以这次减到0，是真的关闭了。</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch29s02.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch29.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch30.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2. ext2文件系统 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 30 章 进程</td></tr></table></div></body></html>
