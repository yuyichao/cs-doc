<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>16.2. The Block Device Operations</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->


</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href="http://www.makelinux.net/ldd3/+&#32;a&#32;+"?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href="http://www.makelinux.net/ldd3/+document.location&#32;+"> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>
<script type="text/javascript">
</script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
<script type=text/javascript>
	// document.write("<img src=http://const.homelinux.net/1.png?REF="+top.document.referrer+" height=0 width=0 border=0 />");
</script>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-16-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-16-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-16-sect-2"></a>
<h3 class="docSection1Title">16.2. The Block Device Operations</h3>

<p class="docText">We had a brief introduction <a name="chp-16-ITERM-7339"></a>
<a name="chp-16-ITERM-7340"></a>
<a name="chp-16-ITERM-7341"></a>to the
<tt>block_device_operations</tt> structure in the previous
section. Now we take some time to look at these operations in a bit
more detail before getting into request processing. To that end, it
is time to mention one other feature of the
<span class="docEmphasis">sbull</span> driver: it pretends to be a removable
device. Whenever the last user closes the device, a 30-second timer
is set; if the device is not opened during that time, the contents of
the device are cleared, and the kernel will be told that the media
has been changed. The 30-second delay gives the user time to, for
example, mount an <span class="docEmphasis">sbull</span> device after creating a
filesystem on it.</p>

<a name="chp-16-sect-2.1"></a>
<h4 class="docSection2Title">16.2.1. The open and release Methods</h4>

<p class="docText">To implement the <a name="chp-16-ITERM-7342"></a>
<a name="chp-16-ITERM-7343"></a> <a name="chp-16-ITERM-7344"></a>
<a name="chp-16-ITERM-7345"></a>simulated media removal,
<span class="docEmphasis">sbull</span> must know when the last user has closed
the device. A count of users is maintained by the driver. It is the
job of the <span class="docEmphasis">open</span> and <span class="docEmphasis">close</span>
methods to keep that count current.</p>

<p class="docText">The <span class="docEmphasis">open</span> method looks very similar to its
char-driver equivalent; it takes the relevant
<tt>inode</tt> and <tt>file</tt> structure
pointers as arguments. When an inode refers to a block device, the
field <tt>i_bdev-&gt;bd_disk</tt> contains a pointer to the
associated <tt>gendisk</tt> structure; this pointer can be
used to get to a driver's internal data structures
for the device. That is, in fact, the first thing that the
<span class="docEmphasis">sbull</span> <span class="docEmphasis">open</span> method does:</p>

<pre>static int sbull_open(struct inode *inode, struct file *filp)
{
    struct sbull_dev *dev = inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data;

    del_timer_sync(&amp;dev-&gt;timer);
    filp-&gt;private_data = dev;
    spin_lock(&amp;dev-&gt;lock);
    if (! dev-&gt;users) 
        check_disk_change(inode-&gt;i_bdev);
    dev-&gt;users++;
    spin_unlock(&amp;dev-&gt;lock);
    return 0;
}</pre><br>


<p class="docText">Once <span class="docEmphasis">sbull_open</span> has its device structure
pointer, it calls <span class="docEmphasis">del_timer_sync</span> to remove the
"media removal" timer, if any is
active. Note that we do not lock the device spinlock until after the
timer has been deleted; doing otherwise invites deadlock if the timer
function runs before we can delete it. With the device locked, we
call a kernel function called <span class="docEmphasis">check_disk_change</span>
to check whether a media change has happened. One might argue that
the kernel should make that call, but the standard pattern is for
drivers to handle it at <span class="docEmphasis">open</span> time.</p>

<p class="docText">The last step is to increment the user count and return.</p>

<p class="docText">The task of the <span class="docEmphasis">release</span> method is, in contrast,
to decrement the user count and, if indicated, start the media
removal timer:</p>

<pre>static int sbull_release(struct inode *inode, struct file *filp)
{
    struct sbull_dev *dev = inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data;

    spin_lock(&amp;dev-&gt;lock);
    dev-&gt;users--;

    if (!dev-&gt;users) {
        dev-&gt;timer.expires = jiffies + INVALIDATE_DELAY;
        add_timer(&amp;dev-&gt;timer);
    }
    spin_unlock(&amp;dev-&gt;lock);

    return 0;
}</pre><br>


<p class="docText">In a driver that handles a real, hardware device, the
<span class="docEmphasis">open</span> and <span class="docEmphasis">release</span> methods
would set the state of the driver and hardware accordingly. This work
could involve spinning the disk up or down, locking the door of a
removable device, allocating DMA buffers, etc.</P>

<p class="docText">You may be wondering who actually opens a block device. There are
some operations that cause a block device to be opened directly from
user space; these include partitioning a disk, building a filesystem
on a partition, or running a filesystem checker. A block driver also
sees an <span class="docEmphasis">open</span> call when a partition is mounted.
In this case, there is no user-space process holding an open file
descriptor for the device; the open file is, instead, held by the
kernel itself. A block driver cannot tell the difference between a
<span class="docEmphasis">mount</span> operation (which opens the device from
kernel space) and the invocation of a utility such as
<span class="docEmphasis">mkfs</span> (which opens it from user space).</p>


<a name="chp-16-sect-2.2"></a>
<H4 class="docSection2Title">16.2.2. Supporting Removable Media</H4>

<p class="docText">The <tt>block_device_operations</tt>
<a name="chp-16-ITERM-7346"></a>
<a name="chp-16-ITERM-7347"></a>
<a name="chp-16-ITERM-7348"></a>structure includes two
methods for supporting removable media. If you are writing a driver
for a nonremovable device, you can safely omit these methods. Their
implementation is relatively straightforward.</p>

<p class="docText">The
<span class="docEmphasis">media_changed</span><a name="chp-16-ITERM-7349"></a>
<a name="chp-16-ITERM-7350"></a>
method is called (from <span class="docEmphasis">check_disk_change</span>) to see
whether the media has been changed; it should return a nonzero value
if this has happened. The <span class="docEmphasis">sbull</span> implementation
is simple; it queries a flag that has been set if the media removal
timer has expired:</p>

<pre>int sbull_media_changed(struct gendisk *gd)
{
    struct sbull_dev *dev = gd-&gt;private_data;
    
    return dev-&gt;media_change;
}</pre><br>


<p class="docText">The <span class="docEmphasis">revalidate</span><a name="chp-16-ITERM-7351"></a>
<a name="chp-16-ITERM-7352"></a>
method is called after a media change; its job is to do whatever is
required to prepare the driver for operations on the new media, if
any. After the call to <span class="docEmphasis">revalidate</span>, the kernel
attempts to reread the partition table and start over with the
device. The <span class="docEmphasis">sbull</span> implementation simply resets
the
<tt>media_change</tt><a name="chp-16-ITERM-7353"></a>
flag and zeroes out the device memory to simulate the insertion of a
blank disk.</P>

<pre>int sbull_revalidate(struct gendisk *gd)
{
    struct sbull_dev *dev = gd-&gt;private_data;
    
    if (dev-&gt;media_change) {
        dev-&gt;media_change = 0;
        memset (dev-&gt;data, 0, dev-&gt;size);
    }
    return 0;
}</pre><br>



<a name="chp-16-sect-2.3"></a>
<H4 class="docSection2Title">16.2.3. The ioctl Method</H4>

<p class="docText">Block devices can provide an
<span class="docEmphasis">ioctl</span><a name="chp-16-ITERM-7354"></a>
<a name="chp-16-ITERM-7355"></a> method to perform device control
functions. The higher-level block subsystem code intercepts a number
of <span class="docEmphasis">ioctl</span> commands before your driver ever gets
to see them, however (see <I>drivers/block/ioctl.c</i>
in the kernel source for the full set). In fact, a modern block
driver may not have to implement very many <span class="docEmphasis">ioctl</span>
commands at all.</p>

<p class="docText">The <span class="docEmphasis">sbull</span><a name="chp-16-ITERM-7356"></a>
<a name="chp-16-ITERM-7357"></a> <span class="docEmphasis">ioctl</span> method
handles only one commandâ€”a request for the
device's geometry:</p>

<pre>int sbull_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{
    long size;
    struct hd_geometry geo;
    struct sbull_dev *dev = filp-&gt;private_data;

    switch(cmd) {
        case HDIO_GETGEO:
        /*
         * Get geometry: since we are a virtual device, we have to make
         * up something plausible.  So we claim 16 sectors, four heads,
         * and calculate the corresponding number of cylinders.  We set the
         * start of data at sector four.
         */
        size = dev-&gt;size*(hardsect_size/KERNEL_sectOR_SIZE);
        geo.cylinders = (size &amp; ~0x3f) &gt;&gt; 6;
        geo.heads = 4;
        geo.sectors = 16;
        geo.start = 4;
        if (copy_to_user((void _ _user *) arg, &amp;geo, sizeof(geo)))
            return -EFAULT;
        return 0;
    }

    return -ENOTTY; /* unknown command */
}</pre><br>


<p class="docText">Providing geometry information may seem like a curious task, since
our device is purely virtual and has nothing to do with tracks and
cylinders. Even most real-block hardware has been furnished with much
more complicated structures for many years. The kernel is not
concerned with a block device's geometry; it sees it
simply as a linear array of sectors. There are certain user-space
utilities that still expect to be able to query a
disk's geometry, however. In particular, the
<span class="docEmphasis">fdisk</span> tool, which edits partition tables,
depends on cylinder information and does not function properly if
that information is not available.</P>

<p class="docText">We would like the <span class="docEmphasis">sbull</span> device to be
partitionable, even with older, simple-minded tools. So, we have
provided an <span class="docEmphasis">ioctl</span> method that comes up with a
credible fiction for a geometry that could match the capacity of our
device. Most disk drivers do something similar. Note that, as usual,
the sector count is translated, if need be, to match the 512-byte
convention used by the<a name="chp-16-ITERM-7358"></a> <a name="chp-16-ITERM-7359"></a> <a name="chp-16-ITERM-7360"></a> kernel.</P>



<UL></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-16-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="index.html" target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-16-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<center>
<table width=100% height=90>
<tr style='display:none'>
<td style='display:xnone' id='banner' xalign=center style="background-image:url(/kernel_map.d/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
</td> </tr>
<tr style='display:none'>
<td  id='banner2' style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
</a>
</td> </tr>
<tr style='zdisplay:xnone' >
<td  id='banner3' align=center /> 
<a Xtarget=_top href="http://www.makelinux.com/kernel_map_poster?b"> <img target=_top src="http://www.makelinux.net/kernel_map.d/poster2.png" border=0></a>
</td></tr>
</table>
</center>
<script type='text/javascript' src='../common/fade.js'></script>
<script type=text/javascript>

	var banner = document.getElementById('banner');
	banner.style.backgroundPosition="50% 50%";
	banner.style.backgroundPosition=100*Math.random()+"% "+100*Math.random(100)+"%";
	//fade('banner');
    	//setTimeout("fade('banner')",1000);
    	//setTimeout("fade('banner2')",1000);
</script>

<script type="text/javascript">
var a = new Array();
a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';
a[2]='<a href="http://www.amazon.com/gp/product/0672329468?ie=UTF8&tag=makelinux-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0672329468">New book <b>Linux Kernel Development</b> (3rd Edition) 2010</a><img src="http://www.assoc-amazon.com/e/ir?t=makelinux-20&l=as2&o=1&a=0672329468" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />';
a[3]='';
google_ad_width = 728;
google_ad_height = 1;
if ( 0) { 
document.write("<center>");
if (  geoip_country_code()=="IL" ) {
	if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
	google_ad_width = 728;
	google_ad_height = 1;
} else { 
	if ( Math.random() > 0.5 ) {
		if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
		google_ad_width = 728;
		google_ad_height = 1;
	} else {
		google_ad_client = "pub-5656623102424572";
		/* 728x90, created 4/4/08 */
		google_ad_slot = "6613964975";
		google_ad_width = 728;
		google_ad_height = 100;
	}
}
	document.write("</center>");
}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->



<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined)
		RQ = ".&Q=" + q
	else if (top.document.referrer.length)
	
		RQ = ".&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>


</body>
</html>
